---
title: Capítulo 3 - Componentes funcionais do Azure RTOS ThreadX SMP
description: Este capítulo contém uma descrição do kernel SMP Azure RTOS ThreadX de uma perspetiva funcional.
author: philmea
ms.author: philmea
ms.date: 06/04/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 6a72acb111aa986f4621e8747568ce3ce3e5e080
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: MT
ms.contentlocale: pt-PT
ms.lasthandoff: 03/22/2021
ms.locfileid: "104827458"
---
# <a name="chapter-3---functional-components-of-azure-rtos-threadx-smp"></a><span data-ttu-id="4bf72-103">Capítulo 3 - Componentes funcionais do Azure RTOS ThreadX SMP</span><span class="sxs-lookup"><span data-stu-id="4bf72-103">Chapter 3 - Functional Components of Azure RTOS ThreadX SMP</span></span>

<span data-ttu-id="4bf72-104">Este capítulo contém uma descrição do kernel SMP Azure RTOS ThreadX de uma perspetiva funcional.</span><span class="sxs-lookup"><span data-stu-id="4bf72-104">This chapter contains a description of the highperformance Azure RTOS ThreadX SMP kernel from a functional perspective.</span></span> <span data-ttu-id="4bf72-105">Cada componente funcional é apresentado de forma fácil de entender.</span><span class="sxs-lookup"><span data-stu-id="4bf72-105">Each functional component is presented in an easy-to-understand manner.</span></span>

## <a name="execution-overview"></a><span data-ttu-id="4bf72-106">Visão geral da execução</span><span class="sxs-lookup"><span data-stu-id="4bf72-106">Execution Overview</span></span>

<span data-ttu-id="4bf72-107">Existem quatro tipos de execução de programas dentro de uma aplicação ThreadX SMP: Inicialização, Execução de Fios, Rotinas de Serviço de Interrupção (ISRs) e Temporizadores de Aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-107">There are four types of program execution within a ThreadX SMP application: Initialization, Thread Execution, Interrupt Service Routines (ISRs), and Application Timers.</span></span>

<span data-ttu-id="4bf72-108">A figura 1 na página 45 mostra cada tipo diferente de execução do programa.</span><span class="sxs-lookup"><span data-stu-id="4bf72-108">Figure 1 on page 45 shows each different type of program execution.</span></span> <span data-ttu-id="4bf72-109">Informações mais pormenorizadas sobre cada um destes tipos encontram-se nas secções subsequentes deste capítulo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-109">More detailed information about each of these types is found in subsequent sections of this chapter.</span></span>

### <a name="initialization"></a><span data-ttu-id="4bf72-110">Inicialização</span><span class="sxs-lookup"><span data-stu-id="4bf72-110">Initialization</span></span>
<span data-ttu-id="4bf72-111">Como o nome indica, este é o primeiro tipo de execução do programa numa aplicação ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="4bf72-111">As the name implies, this is the first type of program execution in a ThreadX SMP application.</span></span> <span data-ttu-id="4bf72-112">A inicialização inclui toda a execução do programa entre o reset do processador e o ponto de entrada do ciclo de agendamento do *fio.*</span><span class="sxs-lookup"><span data-stu-id="4bf72-112">Initialization includes all program execution between processor reset and the entry point of the *thread scheduling loop.*</span></span>

> [!IMPORTANT]
> <span data-ttu-id="4bf72-113">A inicialização é realizada por ou iniciada pelo núcleo 0, que é o núcleo de execução padrão após o reset.</span><span class="sxs-lookup"><span data-stu-id="4bf72-113">Initialization is performed by or initiated by core 0, which is the default running core after reset.</span></span>

### <a name="thread-execution"></a><span data-ttu-id="4bf72-114">Execução de fios</span><span class="sxs-lookup"><span data-stu-id="4bf72-114">Thread Execution</span></span>
<span data-ttu-id="4bf72-115">Após a inicialização estar concluída, cada núcleo que executa o ThreadX SMP introduz o seu ciclo de agendamento de fios.</span><span class="sxs-lookup"><span data-stu-id="4bf72-115">After initialization is complete, each core running ThreadX SMP enters its thread scheduling loop.</span></span> <span data-ttu-id="4bf72-116">O ciclo de agendamento procura um fio de aplicação pronto para a execução nesse núcleo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-116">The scheduling loop looks for an application thread ready for execution on that core.</span></span> <span data-ttu-id="4bf72-117">Quando um fio pronto é encontrado, a ThreadX SMP transfere o controlo para o mesmo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-117">When a ready thread is found, ThreadX SMP transfers control to it.</span></span> <span data-ttu-id="4bf72-118">Depois de terminar o fio (ou se preparar outro fio de maior prioridade), a execução transfere-se de volta para o circuito de agendamento de linhas para encontrar o próximo fio pronto de prioridade máxima em cada núcleo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-118">After the thread is finished (or another higher-priority thread becomes ready), execution transfers back to the thread scheduling loop to find the next highest priority ready thread on each core.</span></span>

<span data-ttu-id="4bf72-119">Este processo de execução contínua e agendamento de fios é o tipo mais comum de execução de programas em aplicações SMP ThreadX.</span><span class="sxs-lookup"><span data-stu-id="4bf72-119">This process of continually executing and scheduling threads is the most common type of program execution in ThreadX SMP applications.</span></span>

![Execução de fios](media/image4.png)

<span data-ttu-id="4bf72-121">**FIGURA 1. Tipos de Execução de Programas**</span><span class="sxs-lookup"><span data-stu-id="4bf72-121">**FIGURE 1. Types of Program Execution**</span></span>

### <a name="interrupt-service-routines-isr"></a><span data-ttu-id="4bf72-122">Interrupção de Rotinas de Serviço (ISR)</span><span class="sxs-lookup"><span data-stu-id="4bf72-122">Interrupt Service Routines (ISR)</span></span>
<span data-ttu-id="4bf72-123">As interrupções são a pedra angular dos sistemas em tempo real.</span><span class="sxs-lookup"><span data-stu-id="4bf72-123">Interrupts are the cornerstone of real-time systems.</span></span> <span data-ttu-id="4bf72-124">Sem interrupções seria extremamente difícil responder às mudanças no mundo externo em tempo oportuno.</span><span class="sxs-lookup"><span data-stu-id="4bf72-124">Without interrupts it would be extremely difficult to respond to changes in the external world in a timely manner.</span></span> <span data-ttu-id="4bf72-125">Ao detetar uma interrupção, o processador guarda informações chave sobre a execução do programa atual (normalmente na pilha), transferindo o controlo para uma área de programa predefinida.</span><span class="sxs-lookup"><span data-stu-id="4bf72-125">On detection of an interrupt, the processor saves key information about the current program execution (usually on the stack), then transfers control to a predefined program area.</span></span> <span data-ttu-id="4bf72-126">Esta área de programa predefinida é geralmente chamada de Rotina de Serviço de Interrupção.</span><span class="sxs-lookup"><span data-stu-id="4bf72-126">This predefined program area is commonly called an Interrupt Service Routine.</span></span>

<span data-ttu-id="4bf72-127">Na maioria dos casos, ocorrem interrupções durante a execução do fio (ou no ciclo de agendamento do fio).</span><span class="sxs-lookup"><span data-stu-id="4bf72-127">In most cases, interrupts occur during thread execution (or in the thread scheduling loop).</span></span> <span data-ttu-id="4bf72-128">No entanto, podem também ocorrer interrupções no interior de um ISR de execução ou de um Temporizador de Aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-128">However, interrupts may also occur inside of an executing ISR or an Application Timer.</span></span>

<span data-ttu-id="4bf72-129">Todos os núcleos podem processar interrupções.</span><span class="sxs-lookup"><span data-stu-id="4bf72-129">All cores are allowed to process interrupts.</span></span> <span data-ttu-id="4bf72-130">O mapeamento das interrupções nos núcleos está sob o controlo direto da aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-130">The mapping of interrupts to cores is under the direct control of the application.</span></span> <span data-ttu-id="4bf72-131">A interrupção do temporizador ThreadX SMP é por predefinição atribuída ao núcleo 0 para processamento.</span><span class="sxs-lookup"><span data-stu-id="4bf72-131">The ThreadX SMP timer interrupt is by default assigned to core 0 for processing.</span></span> <span data-ttu-id="4bf72-132">Por favor, veja o código em *tx_timer_interrupt. S* para implementação desta missão.</span><span class="sxs-lookup"><span data-stu-id="4bf72-132">Please see the code in *tx_timer_interrupt.S* for implementation of this assignment.</span></span>

### <a name="application-timers"></a><span data-ttu-id="4bf72-133">Temporizadores de aplicação</span><span class="sxs-lookup"><span data-stu-id="4bf72-133">Application Timers</span></span>
<span data-ttu-id="4bf72-134">Os Tempos de Aplicação são semelhantes aos ISRs, exceto que a implementação do hardware (normalmente é utilizada uma única interrupção de hardware periódico) está escondida da aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-134">Application Timers are similar to ISRs, except the hardware implementation (usually a single periodic hardware interrupt is used) is hidden from the application.</span></span> <span data-ttu-id="4bf72-135">Estes temporizadores são utilizados por aplicações para a realização de tempos de descanso, periódicos e/ou serviços de vigilância.</span><span class="sxs-lookup"><span data-stu-id="4bf72-135">Such timers are used by applications to perform time-outs, periodics, and/or watchdog services.</span></span> <span data-ttu-id="4bf72-136">Tal como os ISRs, os Temporizadores de Aplicação interrompem frequentemente a execução do fio.</span><span class="sxs-lookup"><span data-stu-id="4bf72-136">Just like ISRs, Application Timers most often interrupt thread execution.</span></span> <span data-ttu-id="4bf72-137">No entanto, ao contrário dos ISRs, os Temporizadores de Aplicação não podem interromper-se mutuamente.</span><span class="sxs-lookup"><span data-stu-id="4bf72-137">Unlike ISRs, however, Application Timers cannot interrupt each other.</span></span>

> [!NOTE]
> <span data-ttu-id="4bf72-138">Tal como os fios, os temporizadores de aplicação podem ser excluídos da execução em qualquer núcleo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-138">That like threads, application timers can be excluded from execution on any core.</span></span>

## <a name="memory-usage"></a><span data-ttu-id="4bf72-139">Utilização de Memória</span><span class="sxs-lookup"><span data-stu-id="4bf72-139">Memory Usage</span></span>

<span data-ttu-id="4bf72-140">A ThreadX SMP reside juntamente com o programa de aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-140">ThreadX SMP resides along with the application program.</span></span> <span data-ttu-id="4bf72-141">Como resultado, a utilização da memória estática (ou memória fixa) da ThreadX SMP é determinada pelas ferramentas de desenvolvimento; por exemplo, o compilador, linker e localizador.</span><span class="sxs-lookup"><span data-stu-id="4bf72-141">As a result, the static memory (or fixed memory) usage of ThreadX SMP is determined by the development tools; e.g., the compiler, linker, and locator.</span></span> <span data-ttu-id="4bf72-142">A utilização da memória dinâmica (ou memória de tempo de execução) está sob controlo direto da aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-142">Dynamic memory (or run-time memory) usage is under direct control of the application.</span></span>

> [!NOTE]
> <span data-ttu-id="4bf72-143">Toda a memória acedida pela ThreadX SMP deve ser coerente e acessível a partir de todos os núcleos que executam o ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="4bf72-143">All the memory accessed by ThreadX SMP must be cache coherent and accessible from all cores executing ThreadX SMP.</span></span>

### <a name="static-memory-usage"></a><span data-ttu-id="4bf72-144">Utilização da memória estática</span><span class="sxs-lookup"><span data-stu-id="4bf72-144">Static Memory Usage</span></span>
<span data-ttu-id="4bf72-145">A maioria das ferramentas de desenvolvimento divide a imagem do programa de aplicação em cinco áreas básicas: *instrução,* dados *constantes,* *inicializados,* *dados não ininitializados* e *pilha de sistemas.*</span><span class="sxs-lookup"><span data-stu-id="4bf72-145">Most of the development tools divide the application program image into five basic areas: *instruction*, *constant*, *initialized data*, *uninitialized data*, and *system stack*.</span></span> <span data-ttu-id="4bf72-146">A figura 2 na página 47 mostra um exemplo destas áreas de memória.</span><span class="sxs-lookup"><span data-stu-id="4bf72-146">Figure 2 on page 47 shows an example of these memory areas.</span></span>

![Utilização da memória estática](media/image5.png)

<span data-ttu-id="4bf72-148">**FIGURA 2. Exemplo da área da memória**</span><span class="sxs-lookup"><span data-stu-id="4bf72-148">**FIGURE 2. Memory Area Example**</span></span>

<span data-ttu-id="4bf72-149">É importante compreender que este é apenas um exemplo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-149">It is important to understand that this is only an example.</span></span> <span data-ttu-id="4bf72-150">O layout real da memória estática é específico para o processador, ferramentas de desenvolvimento e o hardware subjacente.</span><span class="sxs-lookup"><span data-stu-id="4bf72-150">The actual static memory layout is specific to the processor, development tools, and the underlying hardware.</span></span>

<span data-ttu-id="4bf72-151">A área de instrução contém todas as instruções do processador do programa.</span><span class="sxs-lookup"><span data-stu-id="4bf72-151">The instruction area contains all of the program’s processor instructions.</span></span> <span data-ttu-id="4bf72-152">Esta área é tipicamente a maior e está frequentemente localizada em ROM.</span><span class="sxs-lookup"><span data-stu-id="4bf72-152">This area is typically the largest and is often located in ROM.</span></span>

<span data-ttu-id="4bf72-153">A área constante contém várias constantes compiladas, incluindo cordas definidas ou referenciadas dentro do programa.</span><span class="sxs-lookup"><span data-stu-id="4bf72-153">The constant area contains various compiled constants, including strings defined or referenced within the program.</span></span> <span data-ttu-id="4bf72-154">Além disso, esta área contém a "cópia inicial" da área de dados inicializada.</span><span class="sxs-lookup"><span data-stu-id="4bf72-154">In addition, this area contains the “initial copy” of the initialized data area.</span></span> <span data-ttu-id="4bf72-155">Durante o processo de inicialização do compilador, esta parte da área constante é usada para configurar a área de dados inicializada na RAM.</span><span class="sxs-lookup"><span data-stu-id="4bf72-155">During the compiler’s initialization process, this portion of the constant area is used to set up the initialized data area in RAM.</span></span> <span data-ttu-id="4bf72-156">A área constante segue geralmente a área de instrução e está frequentemente localizada em ROM.</span><span class="sxs-lookup"><span data-stu-id="4bf72-156">The constant area usually follows the instruction area and is often located in ROM.</span></span>

<span data-ttu-id="4bf72-157">Os dados inicializados e as áreas de dados não iniializadas contêm todas as variáveis globais e estáticas.</span><span class="sxs-lookup"><span data-stu-id="4bf72-157">The initialized data and uninitialized data areas contain all of the global and static variables.</span></span> <span data-ttu-id="4bf72-158">Estas áreas estão sempre localizadas na RAM.</span><span class="sxs-lookup"><span data-stu-id="4bf72-158">These areas are always located in RAM.</span></span>

<span data-ttu-id="4bf72-159">A pilha do sistema é geralmente configurada imediatamente após as áreas de dados inicializadas e não iniializadas.</span><span class="sxs-lookup"><span data-stu-id="4bf72-159">The system stack is generally set up immediately following the initialized and uninitialized data areas.</span></span> <span data-ttu-id="4bf72-160">A pilha do sistema é utilizada pelo compilador durante a inicialização, em seguida, por ThreadX SMP durante a inicialização e, posteriormente, no processamento do ISR.</span><span class="sxs-lookup"><span data-stu-id="4bf72-160">The system stack is used by the compiler during initialization, then by ThreadX SMP during initialization and, subsequently, in ISR processing.</span></span>

### <a name="dynamic-memory-usage"></a><span data-ttu-id="4bf72-161">Utilização dinâmica da memória</span><span class="sxs-lookup"><span data-stu-id="4bf72-161">Dynamic Memory Usage</span></span>
<span data-ttu-id="4bf72-162">Como mencionado anteriormente, o uso dinâmico da memória está sob o controlo direto da aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-162">As mentioned before, dynamic memory usage is under direct control of the application.</span></span> <span data-ttu-id="4bf72-163">Os blocos de controlo e áreas de memória associadas a pilhas, filas e piscinas de memória podem ser colocados em qualquer lugar no espaço de memória do alvo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-163">Control blocks and memory areas associated with stacks, queues, and memory pools can be placed anywhere in the target’s memory space.</span></span> <span data-ttu-id="4bf72-164">Esta é uma característica importante porque facilita a fácil utilização de diferentes tipos de memória física.</span><span class="sxs-lookup"><span data-stu-id="4bf72-164">This is an important feature because it facilitates easy utilization of different types of physical memory.</span></span>

<span data-ttu-id="4bf72-165">Por exemplo, suponha que um ambiente de hardware alvo tenha memória rápida e memória lenta.</span><span class="sxs-lookup"><span data-stu-id="4bf72-165">For example, suppose a target hardware environment has both fast memory and slow memory.</span></span> <span data-ttu-id="4bf72-166">Se a aplicação necessitar de um desempenho extra para um fio de alta prioridade, o seu bloco de controlo (TX_THREAD) e a pilha podem ser colocadas na área da memória rápida, o que pode melhorar consideravelmente o seu desempenho.</span><span class="sxs-lookup"><span data-stu-id="4bf72-166">If the application needs extra performance for a high-priority thread, its control block (TX_THREAD) and stack can be placed in the fast memory area, which may greatly enhance its performance.</span></span>

## <a name="initialization"></a><span data-ttu-id="4bf72-167">Inicialização</span><span class="sxs-lookup"><span data-stu-id="4bf72-167">Initialization</span></span> 
<span data-ttu-id="4bf72-168">Compreender o processo de inicialização é importante.</span><span class="sxs-lookup"><span data-stu-id="4bf72-168">Understanding the initialization process is important.</span></span> <span data-ttu-id="4bf72-169">O ambiente de hardware inicial é criado aqui.</span><span class="sxs-lookup"><span data-stu-id="4bf72-169">The initial hardware environment is set up here.</span></span> <span data-ttu-id="4bf72-170">Além disso, é aqui que a aplicação é dada a sua personalidade inicial.</span><span class="sxs-lookup"><span data-stu-id="4bf72-170">In addition, this is where the application is given its initial personality.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="4bf72-171">A ThreadX SMP tenta utilizar (sempre que possível) o processo de inicialização da ferramenta de desenvolvimento completo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-171">ThreadX SMP attempts to utilize (whenever possible) the complete development tool’s initialization process.</span></span> <span data-ttu-id="4bf72-172">Isto facilita o upgrade para novas versões das ferramentas de desenvolvimento no futuro.</span><span class="sxs-lookup"><span data-stu-id="4bf72-172">This makes it easier to upgrade to new versions of the development tools in the future.</span></span>

### <a name="system-reset-vector"></a><span data-ttu-id="4bf72-173">Vetor de reset do sistema</span><span class="sxs-lookup"><span data-stu-id="4bf72-173">System Reset Vector</span></span> 
<span data-ttu-id="4bf72-174">Todos os microprocessadores têm lógica de reset.</span><span class="sxs-lookup"><span data-stu-id="4bf72-174">All microprocessors have reset logic.</span></span> <span data-ttu-id="4bf72-175">Quando ocorre um reset (hardware ou software), o endereço do ponto de entrada da aplicação é recuperado a partir de um local de memória específico.</span><span class="sxs-lookup"><span data-stu-id="4bf72-175">When a reset occurs (either hardware or software), the address of the application’s entry point is retrieved from a specific memory location.</span></span> <span data-ttu-id="4bf72-176">Após a recuperação do ponto de entrada, o processador transfere o controlo para aquele local.</span><span class="sxs-lookup"><span data-stu-id="4bf72-176">After the entry point is retrieved, the processor transfers control to that location.</span></span> 

<span data-ttu-id="4bf72-177">O ponto de entrada da aplicação é muitas vezes escrito na língua de montagem nativa e é geralmente fornecido pelas ferramentas de desenvolvimento (pelo menos no modelo).</span><span class="sxs-lookup"><span data-stu-id="4bf72-177">The application entry point is quite often written in the native assembly language and is usually supplied by the development tools (at least in template form).</span></span> <span data-ttu-id="4bf72-178">Em alguns casos, uma versão especial do programa de entrada é fornecida com ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="4bf72-178">In some cases, a special version of the entry program is supplied with ThreadX SMP.</span></span> 

### <a name="development-tool-initialization"></a><span data-ttu-id="4bf72-179">Inicialização da ferramenta de desenvolvimento</span><span class="sxs-lookup"><span data-stu-id="4bf72-179">Development Tool Initialization</span></span>
<span data-ttu-id="4bf72-180">Após a inicialização de baixo nível estar concluída, o controlo transfere-se para a inicialização de alto nível da ferramenta de desenvolvimento.</span><span class="sxs-lookup"><span data-stu-id="4bf72-180">After the low-level initialization is complete, control transfers to the development tool’s high-level initialization.</span></span> <span data-ttu-id="4bf72-181">Este é geralmente o lugar onde são criadas variáveis C globais e estáticas inicializadas.</span><span class="sxs-lookup"><span data-stu-id="4bf72-181">This is usually the place where initialized global and static C variables are set up.</span></span> <span data-ttu-id="4bf72-182">Lembre-se que os seus valores iniciais são recuperados da área constante.</span><span class="sxs-lookup"><span data-stu-id="4bf72-182">Remember their initial values are retrieved from the constant area.</span></span> <span data-ttu-id="4bf72-183">O processamento exato da inicialização é específico da ferramenta de desenvolvimento.</span><span class="sxs-lookup"><span data-stu-id="4bf72-183">Exact initialization processing is development tool specific.</span></span>

### <a name="main-function"></a><span data-ttu-id="4bf72-184">Função principal</span><span class="sxs-lookup"><span data-stu-id="4bf72-184">main Function</span></span> 
<span data-ttu-id="4bf72-185">Quando a inicialização da ferramenta de desenvolvimento estiver concluída, o controlo transfere-se para a função *principal* fornecida pelo utilizador.</span><span class="sxs-lookup"><span data-stu-id="4bf72-185">When the development tool initialization is complete, control transfers to the user-supplied *main* function.</span></span> <span data-ttu-id="4bf72-186">Neste momento, a aplicação controla o que acontece a seguir.</span><span class="sxs-lookup"><span data-stu-id="4bf72-186">At this point, the application controls what happens next.</span></span> <span data-ttu-id="4bf72-187">Para a maioria das aplicações, a função principal simplesmente chama *tx_kernel_enter*, que é a entrada no ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="4bf72-187">For most applications, the main function simply calls *tx_kernel_enter*, which is the entry into ThreadX SMP.</span></span> <span data-ttu-id="4bf72-188">No entanto, as aplicações podem realizar o processamento preliminar (geralmente para a inicialização de hardware) antes de entrar em ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="4bf72-188">However, applications can perform preliminary processing (usually for hardware initialization) prior to entering ThreadX SMP.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="4bf72-189">A chamada para tx_kernel_enter não regressa, por isso não faça nenhum processamento depois dele!</span><span class="sxs-lookup"><span data-stu-id="4bf72-189">The call to tx_kernel_enter does not return, so do not place any processing after it!</span></span>

### <a name="tx_kernel_enter"></a><span data-ttu-id="4bf72-190">tx_kernel_enter</span><span class="sxs-lookup"><span data-stu-id="4bf72-190">tx_kernel_enter</span></span> 
<span data-ttu-id="4bf72-191">A função de entrada coordena a inicialização de várias estruturas internas de dados ThreadX SMP e, em seguida, chama a função de definição da aplicação *tx_application_define*.</span><span class="sxs-lookup"><span data-stu-id="4bf72-191">The entry function coordinates initialization of various internal ThreadX SMP data structures and then calls the application’s definition function *tx_application_define*.</span></span>

<span data-ttu-id="4bf72-192">Quando *tx_application_define* retorna, o controlo é transferido para o circuito de agendamento de fios.</span><span class="sxs-lookup"><span data-stu-id="4bf72-192">When *tx_application_define* returns, control is transferred to the thread scheduling loop.</span></span> <span data-ttu-id="4bf72-193">Isto marca o fim da inicialização!</span><span class="sxs-lookup"><span data-stu-id="4bf72-193">This marks the end of initialization!</span></span>

### <a name="application-definition-function"></a><span data-ttu-id="4bf72-194">Função de definição de aplicação</span><span class="sxs-lookup"><span data-stu-id="4bf72-194">Application Definition Function</span></span>
<span data-ttu-id="4bf72-195">A função *tx_application_define* define todos os fios de aplicação iniciais, filas, semáforos, mutantes, bandeiras de eventos, piscinas de memória e temporizadores.</span><span class="sxs-lookup"><span data-stu-id="4bf72-195">The *tx_application_define* function defines all of the initial application threads, queues, semaphores, mutexes, event flags, memory pools, and timers.</span></span> <span data-ttu-id="4bf72-196">Também é possível criar e eliminar recursos do sistema a partir de fios durante o funcionamento normal da aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-196">It is also possible to create and delete system resources from threads during the normal operation of the application.</span></span> <span data-ttu-id="4bf72-197">No entanto, todos os recursos de aplicação iniciais são definidos aqui.</span><span class="sxs-lookup"><span data-stu-id="4bf72-197">However, all initial application resources are defined here.</span></span>

<span data-ttu-id="4bf72-198">A *função tx_application_define* tem um único parâmetro de entrada e vale certamente a pena mencionar.</span><span class="sxs-lookup"><span data-stu-id="4bf72-198">The *tx_application_define* function has a single input parameter and it is certainly worth mentioning.</span></span> <span data-ttu-id="4bf72-199">O primeiro endereço *RAM disponível* é o único parâmetro de entrada para esta função.</span><span class="sxs-lookup"><span data-stu-id="4bf72-199">The *first-available* RAM address is the sole input parameter to this function.</span></span> <span data-ttu-id="4bf72-200">É tipicamente usado como ponto de partida para alocações iniciais de memória de pilhas de fios, filas e piscinas de memória.</span><span class="sxs-lookup"><span data-stu-id="4bf72-200">It is typically used as a starting point for initial run-time memory allocations of thread stacks, queues, and memory pools.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="4bf72-201">Após a inicialização estar concluída, apenas um fio de execução pode criar e eliminar recursos do sistema , incluindo outros fios.</span><span class="sxs-lookup"><span data-stu-id="4bf72-201">After initialization is complete, only an executing thread can create and delete system resources—including other threads.</span></span> <span data-ttu-id="4bf72-202">Portanto, pelo menos um fio deve ser criado durante a inicialização.</span><span class="sxs-lookup"><span data-stu-id="4bf72-202">Therefore, at least one thread must be created during initialization.</span></span>

### <a name="interrupts"></a><span data-ttu-id="4bf72-203">Interrupções</span><span class="sxs-lookup"><span data-stu-id="4bf72-203">Interrupts</span></span> 
<span data-ttu-id="4bf72-204">As interrupções são deixadas desativadas durante todo o processo de inicialização.</span><span class="sxs-lookup"><span data-stu-id="4bf72-204">Interrupts are left disabled during the entire initialization process.</span></span> <span data-ttu-id="4bf72-205">Se a aplicação de alguma forma permitir interrupções, pode ocorrer um comportamento imprevisível.</span><span class="sxs-lookup"><span data-stu-id="4bf72-205">If the application somehow enables interrupts, unpredictable behavior may occur.</span></span> <span data-ttu-id="4bf72-206">A figura 3 na página 52 mostra todo o processo de inicialização, desde o reset do sistema através da inicialização específica da aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-206">Figure 3 on page 52 shows the entire initialization process, from system reset through application-specific initialization.</span></span>

## <a name="thread-execution"></a><span data-ttu-id="4bf72-207">Execução de fios</span><span class="sxs-lookup"><span data-stu-id="4bf72-207">Thread Execution</span></span>

<span data-ttu-id="4bf72-208">Agendar e executar fios de aplicação é a atividade mais importante da ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="4bf72-208">Scheduling and executing application threads is the most important activity of ThreadX SMP.</span></span> <span data-ttu-id="4bf72-209">Um fio é tipicamente definido como um segmento de programa semi-independente com um propósito dedicado.</span><span class="sxs-lookup"><span data-stu-id="4bf72-209">A thread is typically defined as a semi-independent program segment with a dedicated purpose.</span></span> <span data-ttu-id="4bf72-210">O processamento combinado de todos os fios faz uma aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-210">The combined processing of all threads makes an application.</span></span>

<span data-ttu-id="4bf72-211">Os fios são criados dinamicamente chamando *tx_thread_create* durante a inicialização ou durante a execução do fio.</span><span class="sxs-lookup"><span data-stu-id="4bf72-211">Threads are created dynamically by calling *tx_thread_create* during initialization or during thread execution.</span></span> <span data-ttu-id="4bf72-212">Os fios são criados num estado *pronto* ou *suspenso.*</span><span class="sxs-lookup"><span data-stu-id="4bf72-212">Threads are created in either a *ready* or *suspended* state.</span></span>

![Processo de inicialização do SMP](media/image6.png)

<span data-ttu-id="4bf72-214">**FIGURA 3. Processo de inicialização do SMP**</span><span class="sxs-lookup"><span data-stu-id="4bf72-214">**FIGURE 3. SMP Initialization Process**</span></span>

### <a name="thread-execution-states"></a><span data-ttu-id="4bf72-215">Estados de execução de fios</span><span class="sxs-lookup"><span data-stu-id="4bf72-215">Thread Execution States</span></span>  
<span data-ttu-id="4bf72-216">Compreender os diferentes estados de processamento dos fios é um ingrediente chave para entender todo o ambiente multi-liscado.</span><span class="sxs-lookup"><span data-stu-id="4bf72-216">Understanding the different processing states of threads is a key ingredient to understanding the entire multithreaded environment.</span></span> <span data-ttu-id="4bf72-217">Na ThreadX SMP, existem cinco estados de linha distintos: *prontos,* *suspensos,* *executados,* *encerrados* e *concluídos*.</span><span class="sxs-lookup"><span data-stu-id="4bf72-217">In ThreadX SMP, there are five distinct thread states: *ready*, *suspended*, *executing*, *terminated*, and *completed*.</span></span> <span data-ttu-id="4bf72-218">A figura 4 mostra o diagrama de transição do estado do fio para ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="4bf72-218">Figure 4 shows the thread state transition diagram for ThreadX SMP.</span></span>

![Estados de execução de fios](media/image7.png)

<span data-ttu-id="4bf72-220">**FIGURA 4. Transição do Estado do Fio**</span><span class="sxs-lookup"><span data-stu-id="4bf72-220">**FIGURE 4. Thread State Transition**</span></span>

<span data-ttu-id="4bf72-221">Um fio está em estado *de preparação* quando está pronto para a execução.</span><span class="sxs-lookup"><span data-stu-id="4bf72-221">A thread is in a *ready* state when it is ready for execution.</span></span> <span data-ttu-id="4bf72-222">Um fio pronto não é executado até que seja o fio de prioridade mais elevado em estado pronto.</span><span class="sxs-lookup"><span data-stu-id="4bf72-222">A ready thread is not executed until it is the highest priority thread in ready state.</span></span> <span data-ttu-id="4bf72-223">Quando isto acontece, a ThreadX SMP executa o fio, que depois muda o seu estado para *executar*.</span><span class="sxs-lookup"><span data-stu-id="4bf72-223">When this happens, ThreadX SMP executes the thread, which then changes its state to *executing*.</span></span>

<span data-ttu-id="4bf72-224">Se um fio de maior prioridade ficar pronto, o fio de execução volta para um estado *pronto.*</span><span class="sxs-lookup"><span data-stu-id="4bf72-224">If a higher-priority thread becomes ready, the executing thread reverts back to a *ready* state.</span></span> <span data-ttu-id="4bf72-225">O fio de alta prioridade recentemente pronto é executado, o que altera o seu estado lógico para *executar*.</span><span class="sxs-lookup"><span data-stu-id="4bf72-225">The newly ready high-priority thread is then executed, which changes its logical state to *executing*.</span></span> <span data-ttu-id="4bf72-226">Esta transição entre estados *prontos* e *de execução* ocorre sempre que ocorre a preempção do fio.</span><span class="sxs-lookup"><span data-stu-id="4bf72-226">This transition between *ready* and *executing* states occurs every time thread preemption occurs.</span></span>

<span data-ttu-id="4bf72-227">A qualquer momento, apenas um fio está em estado *de execução.*</span><span class="sxs-lookup"><span data-stu-id="4bf72-227">At any given moment, only one thread is in an *executing* state.</span></span> <span data-ttu-id="4bf72-228">Isto porque um fio no estado *de execução* tem o controlo do processador subjacente.</span><span class="sxs-lookup"><span data-stu-id="4bf72-228">This is because a thread in the *executing* state has control of the underlying processor.</span></span>

<span data-ttu-id="4bf72-229">Os fios num estado *suspenso* não são elegíveis para execução.</span><span class="sxs-lookup"><span data-stu-id="4bf72-229">Threads in a *suspended* state are not eligible for execution.</span></span> <span data-ttu-id="4bf72-230">As razões para estar em estado *suspenso* incluem suspensão por tempo, mensagens de fila, semáforos, mutantes, bandeiras de eventos, memória e suspensão básica do fio.</span><span class="sxs-lookup"><span data-stu-id="4bf72-230">Reasons for being in a *suspended* state include suspension for time, queue messages, semaphores, mutexes, event flags, memory, and basic thread suspension.</span></span> <span data-ttu-id="4bf72-231">Depois de a causa da suspensão ser removida, a rosca é colocada de volta num estado *de preparação.*</span><span class="sxs-lookup"><span data-stu-id="4bf72-231">After the cause for suspension is removed, the thread is placed back in a *ready* state.</span></span>

<span data-ttu-id="4bf72-232">Um fio num estado *completo* é um fio que completou o seu processamento e regressou da sua função de entrada.</span><span class="sxs-lookup"><span data-stu-id="4bf72-232">A thread in a *completed* state is a thread that has completed its processing and returned from its entry function.</span></span> <span data-ttu-id="4bf72-233">A função de entrada é especificada durante a criação do fio.</span><span class="sxs-lookup"><span data-stu-id="4bf72-233">The entry function is specified during thread creation.</span></span> <span data-ttu-id="4bf72-234">Um fio num estado *completo* não pode ser executado novamente.</span><span class="sxs-lookup"><span data-stu-id="4bf72-234">A thread in a *completed* state cannot execute again.</span></span>

<span data-ttu-id="4bf72-235">Um fio está em estado *de terminação* porque outro fio ou o próprio fio chamado *serviço tx_thread_terminate.*</span><span class="sxs-lookup"><span data-stu-id="4bf72-235">A thread is in a *terminated* state because another thread or the thread itself called the *tx_thread_terminate* service.</span></span> <span data-ttu-id="4bf72-236">Um fio num estado *encerrado* não pode ser executado novamente.</span><span class="sxs-lookup"><span data-stu-id="4bf72-236">A thread in a *terminated* state cannot execute again.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="4bf72-237">Se desejar o reinsegroso fio concluído ou terminado, a aplicação deve primeiro eliminar o fio.</span><span class="sxs-lookup"><span data-stu-id="4bf72-237">If re-starting a completed or terminated thread is desired, the application must first delete the thread.</span></span> <span data-ttu-id="4bf72-238">Pode então ser recriada e reinicia.</span><span class="sxs-lookup"><span data-stu-id="4bf72-238">It can then be re-created and re-started.</span></span>

### <a name="thread-entryexit-notification"></a><span data-ttu-id="4bf72-239">Notificação de entrada/saída de linha</span><span class="sxs-lookup"><span data-stu-id="4bf72-239">Thread Entry/Exit Notification</span></span>  
<span data-ttu-id="4bf72-240">Algumas aplicações podem achar vantajoso ser notificado quando um fio específico é introduzido pela primeira vez, quando este completa, ou é terminado.</span><span class="sxs-lookup"><span data-stu-id="4bf72-240">Some applications may find it advantageous to be notified when a specific thread is entered for the first time, when it completes, or is terminated.</span></span> <span data-ttu-id="4bf72-241">A ThreadX SMP fornece esta capacidade através do serviço *tx_thread_entry_exit_notify.*</span><span class="sxs-lookup"><span data-stu-id="4bf72-241">ThreadX SMP provides this ability through the *tx_thread_entry_exit_notify* service.</span></span> <span data-ttu-id="4bf72-242">Este serviço regista uma função de notificação de aplicação para um fio específico, que é chamado pela ThreadX SMP sempre que o fio começa a funcionar, completa ou é terminado.</span><span class="sxs-lookup"><span data-stu-id="4bf72-242">This service registers an application notification function for a specific thread, which is called by ThreadX SMP whenever the thread starts running, completes, or is terminated.</span></span> <span data-ttu-id="4bf72-243">Depois de invocado, a função de notificação de aplicação pode realizar o processamento específico da aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-243">After being invoked, the application notification function can perform the applicationspecific processing.</span></span> <span data-ttu-id="4bf72-244">Isto normalmente envolve informar outro fio de aplicação do evento através de uma sincronização de SMP threadX primitiva.</span><span class="sxs-lookup"><span data-stu-id="4bf72-244">This typically involves informing another application thread of the event via a ThreadX SMP synchronization primitive.</span></span>

### <a name="thread-priorities"></a><span data-ttu-id="4bf72-245">Prioridades do Fio</span><span class="sxs-lookup"><span data-stu-id="4bf72-245">Thread Priorities</span></span>  
<span data-ttu-id="4bf72-246">Como mencionado anteriormente, um fio é um segmento de programa semi-independente com um propósito dedicado.</span><span class="sxs-lookup"><span data-stu-id="4bf72-246">As mentioned before, a thread is a semi-independent program segment with a dedicated purpose.</span></span> <span data-ttu-id="4bf72-247">No entanto, todos os fios não são criados iguais!</span><span class="sxs-lookup"><span data-stu-id="4bf72-247">However, all threads are not created equal!</span></span> <span data-ttu-id="4bf72-248">O propósito dedicado de alguns fios é muito mais importante do que outros.</span><span class="sxs-lookup"><span data-stu-id="4bf72-248">The dedicated purpose of some threads is much more important than others.</span></span> <span data-ttu-id="4bf72-249">Este tipo heterogéneo de importância do fio é uma marca de aplicações em tempo real incorporadas.</span><span class="sxs-lookup"><span data-stu-id="4bf72-249">This heterogeneous type of thread importance is a hallmark of embedded realtime applications.</span></span>

<span data-ttu-id="4bf72-250">A ThreadX SMP determina a importância de um fio quando o fio é criado atribuindo um valor numérico que representa a sua *prioridade*.</span><span class="sxs-lookup"><span data-stu-id="4bf72-250">ThreadX SMP determines a thread’s importance when the thread is created by assigning a numerical value representing its *priority*.</span></span> <span data-ttu-id="4bf72-251">O número máximo de prioridades da ThreadX SMP é configurável de 32 a 1024 em incrementos de 32.</span><span class="sxs-lookup"><span data-stu-id="4bf72-251">The maximum number of ThreadX SMP priorities is configurable from 32 through 1024 in increments of 32.</span></span> <span data-ttu-id="4bf72-252">O número máximo real de prioridades é determinado pela *TX_MAX_PRIORITIES* constante durante a compilação da biblioteca ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="4bf72-252">The actual maximum number of priorities is determined by the *TX_MAX_PRIORITIES* constant during compilation of the ThreadX SMP library.</span></span> <span data-ttu-id="4bf72-253">Ter um maior número de prioridades não aumenta significativamente o processamento de despesas gerais.</span><span class="sxs-lookup"><span data-stu-id="4bf72-253">Having a larger number of priorities does not significantly increase processing overhead.</span></span> <span data-ttu-id="4bf72-254">No entanto, para cada grupo de 32 níveis prioritários são necessários mais 128 bytes de RAM para os gerir.</span><span class="sxs-lookup"><span data-stu-id="4bf72-254">However, for each group of 32 priority levels an additional 128 bytes of RAM is required to manage them.</span></span> <span data-ttu-id="4bf72-255">Por exemplo, 32 níveis prioritários requerem 128 bytes de RAM, 64 níveis prioritários requerem 256 bytes de RAM, e 96 níveis prioritários requer 384 bytes de RAM.</span><span class="sxs-lookup"><span data-stu-id="4bf72-255">For example, 32 priority levels require 128 bytes of RAM, 64 priority levels require 256 bytes of RAM, and 96 priority levels requires 384 bytes of RAM.</span></span>

<span data-ttu-id="4bf72-256">Por predefinição, a ThreadX SMP tem 32 níveis prioritários, que vão desde a prioridade 0 até à prioridade 31.</span><span class="sxs-lookup"><span data-stu-id="4bf72-256">By default, ThreadX SMP has 32 priority levels, ranging from priority 0 through priority 31.</span></span>

<span data-ttu-id="4bf72-257">Valores numericamente menores implicam maior prioridade.</span><span class="sxs-lookup"><span data-stu-id="4bf72-257">Numerically smaller values imply higher priority.</span></span> <span data-ttu-id="4bf72-258">Assim, a prioridade 0 representa a prioridade máxima, enquanto a prioridade *(TX_MAX_PRIORITIES*-1) representa a menor prioridade.</span><span class="sxs-lookup"><span data-stu-id="4bf72-258">Hence, priority 0 represents the highest priority, while priority (*TX_MAX_PRIORITIES*-1) represents the lowest priority.</span></span>

<span data-ttu-id="4bf72-259">Múltiplos fios podem ter a mesma prioridade, dependendo do agendamento cooperativo ou do corte de tempo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-259">Multiple threads can have the same priority relying on cooperative scheduling or time-slicing.</span></span> <span data-ttu-id="4bf72-260">Além disso, as prioridades dos fios podem ser alteradas durante o tempo de funcionaamento.</span><span class="sxs-lookup"><span data-stu-id="4bf72-260">In addition, thread priorities can be changed during run-time.</span></span>

### <a name="thread-scheduling"></a><span data-ttu-id="4bf72-261">Agendamento de fios</span><span class="sxs-lookup"><span data-stu-id="4bf72-261">Thread Scheduling</span></span> 
<span data-ttu-id="4bf72-262">ThreadX SMP programa linhas com base na sua prioridade.</span><span class="sxs-lookup"><span data-stu-id="4bf72-262">ThreadX SMP schedules threads based on their priority.</span></span> <span data-ttu-id="4bf72-263">O fio pronto com a maior prioridade é executado primeiro.</span><span class="sxs-lookup"><span data-stu-id="4bf72-263">The ready thread with the highest priority is executed first.</span></span> <span data-ttu-id="4bf72-264">Se várias linhas da mesma prioridade estiverem prontas, são executadas *de forma primeira no primeiro* lugar (FIFO).</span><span class="sxs-lookup"><span data-stu-id="4bf72-264">If multiple threads of the same priority are ready, they are executed in a *first-in-first-out* (FIFO) manner.</span></span>

<span data-ttu-id="4bf72-265">Por predefinição, a ThreadX SMP programa os fios de prioridade máxima "n" nos processadores "n" disponíveis.</span><span class="sxs-lookup"><span data-stu-id="4bf72-265">By default, ThreadX SMP schedules the “n” highest priority threads on the “n” available processors.</span></span> <span data-ttu-id="4bf72-266">Se for necessário um processamento simultâneo apenas em fios prontos da mesma prioridade, a biblioteca ThreadX SMP deve ser construída com **TX_THREAD_SMP_EQUAL_PRIORITY** definida.</span><span class="sxs-lookup"><span data-stu-id="4bf72-266">If concurrent processing is only required on ready threads of the same priority, the ThreadX SMP library must be built with **TX_THREAD_SMP_EQUAL_PRIORITY** defined.</span></span>

> [!NOTE]
> <span data-ttu-id="4bf72-267">Que todos os fios podem ser inicialmente padrão para funcionar apenas no núcleo 0, construindo a biblioteca ThreadX SMP com **TX_THREAD_SMP_ONLY_CORE_0_DEFAULT** definidas.</span><span class="sxs-lookup"><span data-stu-id="4bf72-267">That all threads can be initially defaulted to only run on core 0, by building the ThreadX SMP library with **TX_THREAD_SMP_ONLY_CORE_0_DEFAULT** defined.</span></span>

### <a name="round-robin-scheduling"></a><span data-ttu-id="4bf72-268">Horário redondo</span><span class="sxs-lookup"><span data-stu-id="4bf72-268">Round-robin Scheduling</span></span>  
<span data-ttu-id="4bf72-269">A ThreadX SMP suporta o agendamento *de rodadas* de vários fios com a mesma prioridade.</span><span class="sxs-lookup"><span data-stu-id="4bf72-269">ThreadX SMP supports *round-robin* scheduling of multiple threads having the same priority.</span></span> <span data-ttu-id="4bf72-270">Isto é conseguido através de apelos cooperativos a *tx_thread_relinquish.*</span><span class="sxs-lookup"><span data-stu-id="4bf72-270">This is accomplished through cooperative calls to *tx_thread_relinquish*.</span></span> <span data-ttu-id="4bf72-271">Este serviço dá a todas as outras linhas prontas da mesma prioridade uma oportunidade de executar antes que o *tx_thread_relinquish* de chamada execute novamente.</span><span class="sxs-lookup"><span data-stu-id="4bf72-271">This service gives all other ready threads of the same priority a chance to execute before the *tx_thread_relinquish* caller executes again.</span></span>

### <a name="time-slicing"></a><span data-ttu-id="4bf72-272">Time-Slicing</span><span class="sxs-lookup"><span data-stu-id="4bf72-272">Time-Slicing</span></span> 
<span data-ttu-id="4bf72-273">*Cortar o tempo* é outra forma de agendamento de rodapé.</span><span class="sxs-lookup"><span data-stu-id="4bf72-273">*Time-slicing* is another form of round-robin scheduling.</span></span> <span data-ttu-id="4bf72-274">Uma fatia de tempo especifica o número máximo de carraças temporizador (o temporizador interrompe) que um fio pode executar sem abdicar do processador.</span><span class="sxs-lookup"><span data-stu-id="4bf72-274">A time-slice specifies the maximum number of timer ticks (timer interrupts) that a thread can execute without giving up the processor.</span></span> <span data-ttu-id="4bf72-275">No ThreadX SMP, o corte de tempo está disponível numa base de perthread.</span><span class="sxs-lookup"><span data-stu-id="4bf72-275">In ThreadX SMP, time-slicing is available on a perthread basis.</span></span> <span data-ttu-id="4bf72-276">A fatia de tempo do fio é atribuída durante a criação e pode ser modificada durante o tempo de funcionação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-276">The thread’s time-slice is assigned during creation and can be modified during run-time.</span></span> <span data-ttu-id="4bf72-277">Quando uma fatia de tempo expira, todos os outros fios prontos do mesmo nível de prioridade têm a oportunidade de executar antes que o fio cortado no tempo volte a ser executado.</span><span class="sxs-lookup"><span data-stu-id="4bf72-277">When a time-slice expires, all other ready threads of the same priority level are given a chance to execute before the time-sliced thread executes again.</span></span>

<span data-ttu-id="4bf72-278">Uma fatia de tempo de fio fresca é dada a um fio depois de suspender, renunciar, fazer uma chamada de serviço ThreadX SMP que causa preempção, ou é ele próprio com um tempo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-278">A fresh thread time-slice is given to a thread after it suspends, relinquishes, makes a ThreadX SMP service call that causes preemption, or is itself timesliced.</span></span>

<span data-ttu-id="4bf72-279">Quando um fio cortado no tempo for previamente antecipado, ele retomará antes de outros fios prontos de igual prioridade para o restante da sua rodela temporal.</span><span class="sxs-lookup"><span data-stu-id="4bf72-279">When a time-sliced thread is preempted, it will resume before other ready threads of equal priority for the remainder of its time-slice.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="4bf72-280">A utilização de corte de tempo resulta numa ligeira quantidade de sobrecarga do sistema.</span><span class="sxs-lookup"><span data-stu-id="4bf72-280">Using time-slicing results in a slight amount of system overhead.</span></span> <span data-ttu-id="4bf72-281">Como o corte de tempo só é útil nos casos em que múltiplos fios partilham a mesma prioridade, os fios que têm uma prioridade única não devem ser atribuídos a uma fatia de tempo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-281">Because time-slicing is only useful in cases in which multiple threads share the same priority, threads having a unique priority should not be assigned a time-slice.</span></span>

### <a name="preemption"></a><span data-ttu-id="4bf72-282">Preempção</span><span class="sxs-lookup"><span data-stu-id="4bf72-282">Preemption</span></span> 
<span data-ttu-id="4bf72-283">A preempção é o processo de interromper temporariamente um fio de execução em favor de um fio de maior prioridade.</span><span class="sxs-lookup"><span data-stu-id="4bf72-283">Preemption is the process of temporarily interrupting an executing thread in favor of a higher-priority thread.</span></span> <span data-ttu-id="4bf72-284">Este processo é invisível para o fio de execução.</span><span class="sxs-lookup"><span data-stu-id="4bf72-284">This process is invisible to the executing thread.</span></span> <span data-ttu-id="4bf72-285">Quando o fio de maior prioridade estiver terminado, o controlo é transferido de volta para o local exato onde ocorreu a pré-substituição.</span><span class="sxs-lookup"><span data-stu-id="4bf72-285">When the higher-priority thread is finished, control is transferred back to the exact place where the preemption took place.</span></span>

<span data-ttu-id="4bf72-286">Esta é uma característica muito importante nos sistemas em tempo real, pois facilita uma resposta rápida a importantes eventos de aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-286">This is a very important feature in real-time systems because it facilitates fast response to important application events.</span></span> <span data-ttu-id="4bf72-287">Embora uma característica muito importante, a preempção também pode ser uma fonte de uma variedade de problemas, incluindo fome, sobrecarga excessiva e inversão prioritária.</span><span class="sxs-lookup"><span data-stu-id="4bf72-287">Although a very important feature, preemption can also be a source of a variety of problems, including starvation, excessive overhead, and priority inversion.</span></span>

### <a name="preemption-threshold"></a><span data-ttu-id="4bf72-288">Preempção-Limiar™</span><span class="sxs-lookup"><span data-stu-id="4bf72-288">Preemption-Threshold™</span></span> 
<span data-ttu-id="4bf72-289">Para aliviar alguns dos problemas inerentes à preempção, a ThreadX SMP fornece uma característica única e avançada chamada *limiar de pré-edição*.</span><span class="sxs-lookup"><span data-stu-id="4bf72-289">To ease some of the inherent problems of preemption, ThreadX SMP provides a unique and advanced feature called *preemption-threshold*.</span></span>

<span data-ttu-id="4bf72-290">Um limiar de pré-substituição permite que um fio especifique um *limite* prioritário para desativar a preempção.</span><span class="sxs-lookup"><span data-stu-id="4bf72-290">A preemption-threshold allows a thread to specify a priority *ceiling* for disabling preemption.</span></span> <span data-ttu-id="4bf72-291">Os fios que têm prioridades mais elevadas do que o teto ainda podem ser preempeded, enquanto aqueles que não têm limites máximos não podem ser antecipados.</span><span class="sxs-lookup"><span data-stu-id="4bf72-291">Threads that have higher priorities than the ceiling are still allowed to preempt, while those less than the ceiling are not allowed to preempt.</span></span>

<span data-ttu-id="4bf72-292">Por exemplo, suponha que um fio de prioridade 20 interage apenas com um grupo de fios que têm prioridades entre 15 e 20.</span><span class="sxs-lookup"><span data-stu-id="4bf72-292">For example, suppose a thread of priority 20 only interacts with a group of threads that have priorities between 15 and 20.</span></span> <span data-ttu-id="4bf72-293">Durante as suas secções críticas, o fio da prioridade 20 pode definir o seu limiar de prevenção para 15, evitando assim a preempção de todos os fios com os quais interage.</span><span class="sxs-lookup"><span data-stu-id="4bf72-293">During its critical sections, the thread of priority 20 can set its preemption-threshold to 15, thereby preventing preemption from all of the threads that it interacts with.</span></span> <span data-ttu-id="4bf72-294">Isto ainda permite que linhas realmente importantes (prioridades entre 0 e 14) preempam este fio durante o seu processamento de secção crítica, o que resulta num processamento muito mais responsivo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-294">This still permits really important threads (priorities between 0 and 14) to preempt this thread during its critical section processing, which results in much more responsive processing.</span></span>

<span data-ttu-id="4bf72-295">É claro que ainda é possível que um fio desative todas as preempção, fixando o seu limiar de pré-deposição para 0.</span><span class="sxs-lookup"><span data-stu-id="4bf72-295">Of course, it is still possible for a thread to disable all preemption by setting its preemption-threshold to 0.</span></span> <span data-ttu-id="4bf72-296">Além disso, o limiar de pré-substituição pode ser alterado durante o tempo de funcionaamento.</span><span class="sxs-lookup"><span data-stu-id="4bf72-296">In addition, preemption-threshold can be changed during run-time.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="4bf72-297">A utilização do limiar de pré-substituição desativa o corte de tempo para o fio especificado.</span><span class="sxs-lookup"><span data-stu-id="4bf72-297">Using preemption-threshold disables time-slicing for the specified thread.</span></span>

### <a name="priority-inheritance"></a><span data-ttu-id="4bf72-298">Herança Prioritária</span><span class="sxs-lookup"><span data-stu-id="4bf72-298">Priority Inheritance</span></span> 
<span data-ttu-id="4bf72-299">A ThreadX SMP também suporta a herança prioritária opcional dentro dos seus serviços de mutex descritos mais tarde neste capítulo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-299">ThreadX SMP also supports optional priority inheritance within its mutex services described later in this chapter.</span></span> <span data-ttu-id="4bf72-300">A herança prioritária permite que um fio de prioridade inferior assuma temporariamente a prioridade de um fio de alta prioridade que está à espera de um mutex propriedade do fio de menor prioridade.</span><span class="sxs-lookup"><span data-stu-id="4bf72-300">Priority inheritance allows a lower priority thread to temporarily assume the priority of a high priority thread that is waiting for a mutex owned by the lower priority thread.</span></span> <span data-ttu-id="4bf72-301">Esta capacidade ajuda a aplicação a evitar a inversão de prioridade não determinística, eliminando a preempção das prioridades do fio intermédio.</span><span class="sxs-lookup"><span data-stu-id="4bf72-301">This capability helps the application to avoid nondeterministic priority inversion by eliminating preemption of intermediate thread priorities.</span></span> <span data-ttu-id="4bf72-302">É claro que o *limiar de pré-edição* pode ser utilizado para obter um resultado semelhante.</span><span class="sxs-lookup"><span data-stu-id="4bf72-302">Of course, *preemption-threshold* may be used to achieve a similar result.</span></span>

### <a name="thread-creation"></a><span data-ttu-id="4bf72-303">Criação de fios</span><span class="sxs-lookup"><span data-stu-id="4bf72-303">Thread Creation</span></span> 
<span data-ttu-id="4bf72-304">Os fios de aplicação são criados durante a inicialização ou durante a execução de outros fios de aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-304">Application threads are created during initialization or during the execution of other application threads.</span></span> <span data-ttu-id="4bf72-305">Não há limite para o número de fios que podem ser criados por uma aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-305">There is no limit on the number of threads that can be created by an application.</span></span>

### <a name="thread-control-block-tx_thread"></a><span data-ttu-id="4bf72-306">TX_THREAD do bloco de controlo de fios</span><span class="sxs-lookup"><span data-stu-id="4bf72-306">Thread Control Block TX_THREAD</span></span> 
<span data-ttu-id="4bf72-307">As características de cada fio estão contidas no seu bloco de controlo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-307">The characteristics of each thread are contained in its control block.</span></span> <span data-ttu-id="4bf72-308">Esta estrutura é definida no ficheiro ***tx_api.h.***</span><span class="sxs-lookup"><span data-stu-id="4bf72-308">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="4bf72-309">O bloco de controlo de um fio pode ser localizado em qualquer lugar da memória, mas é mais comum fazer do bloco de controlo uma estrutura global definindo-o fora do âmbito de qualquer função.</span><span class="sxs-lookup"><span data-stu-id="4bf72-309">A thread’s control block can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

<span data-ttu-id="4bf72-310">Localizar o bloco de controlo noutras áreas requer um pouco mais de cuidado, assim como toda a memória dinamicamente alocada.</span><span class="sxs-lookup"><span data-stu-id="4bf72-310">Locating the control block in other areas requires a bit more care, just like all dynamically allocated memory.</span></span> <span data-ttu-id="4bf72-311">Se um bloco de controlo for alocado dentro de uma função C, a memória associada a ele faz parte da pilha do fio de chamada.</span><span class="sxs-lookup"><span data-stu-id="4bf72-311">If a control block is allocated within a C function, the memory associated with it is part of the calling thread’s stack.</span></span> <span data-ttu-id="4bf72-312">Em geral, evite usar o armazenamento local para blocos de controlo porque após o retorno da função, todo o seu espaço de pilha variável local é libertado - independentemente de outro fio estar a usá-lo para um bloco de controlo!</span><span class="sxs-lookup"><span data-stu-id="4bf72-312">In general, avoid using local storage for control blocks because after the function returns, all of its local variable stack space is released—regardless of whether another thread is using it for a control block!</span></span>

<span data-ttu-id="4bf72-313">Na maioria dos casos, a aplicação é alheia ao conteúdo do bloco de controlo do fio.</span><span class="sxs-lookup"><span data-stu-id="4bf72-313">In most cases, the application is oblivious to the contents of the thread’s control block.</span></span> <span data-ttu-id="4bf72-314">No entanto, existem algumas situações, especialmente durante o depurg, em que olhar para certos membros é útil.</span><span class="sxs-lookup"><span data-stu-id="4bf72-314">However, there are some situations, especially during debug, in which looking at certain members is useful.</span></span> <span data-ttu-id="4bf72-315">Seguem-se alguns dos membros mais úteis do bloco de controlo:</span><span class="sxs-lookup"><span data-stu-id="4bf72-315">The following are some of the more useful control block members:</span></span>

- <span data-ttu-id="4bf72-316">**tx_thread_run_count** contém um contador do número de muitas vezes que o fio foi programado.</span><span class="sxs-lookup"><span data-stu-id="4bf72-316">**tx_thread_run_count** contains a counter of the number of many times the thread has been scheduled.</span></span> <span data-ttu-id="4bf72-317">Um contador crescente indica que o fio está a ser programado e executado.</span><span class="sxs-lookup"><span data-stu-id="4bf72-317">An increasing counter indicates the thread is being scheduled and executed.</span></span>

- <span data-ttu-id="4bf72-318">**tx_thread_state** contém o estado do fio associado.</span><span class="sxs-lookup"><span data-stu-id="4bf72-318">**tx_thread_state** contains the state of the associated thread.</span></span> <span data-ttu-id="4bf72-319">As seguintes listas são os possíveis estados de linha:</span><span class="sxs-lookup"><span data-stu-id="4bf72-319">The following lists the possible thread states:</span></span>

    - <span data-ttu-id="4bf72-320">TX_READY(0x00)</span><span class="sxs-lookup"><span data-stu-id="4bf72-320">TX_READY(0x00)</span></span>
    - <span data-ttu-id="4bf72-321">TX_COMPLETED(0x01)</span><span class="sxs-lookup"><span data-stu-id="4bf72-321">TX_COMPLETED(0x01)</span></span>
    - <span data-ttu-id="4bf72-322">TX_TERMINATED(0x02)</span><span class="sxs-lookup"><span data-stu-id="4bf72-322">TX_TERMINATED(0x02)</span></span>
    - <span data-ttu-id="4bf72-323">TX_SUSPENDED(0x03)</span><span class="sxs-lookup"><span data-stu-id="4bf72-323">TX_SUSPENDED(0x03)</span></span>
    - <span data-ttu-id="4bf72-324">TX_SLEEP(0x04)</span><span class="sxs-lookup"><span data-stu-id="4bf72-324">TX_SLEEP(0x04)</span></span>
    - <span data-ttu-id="4bf72-325">TX_QUEUE_SUSP(0x05)</span><span class="sxs-lookup"><span data-stu-id="4bf72-325">TX_QUEUE_SUSP(0x05)</span></span>
    - <span data-ttu-id="4bf72-326">TX_SEMAPHORE_SUSP(0x06)</span><span class="sxs-lookup"><span data-stu-id="4bf72-326">TX_SEMAPHORE_SUSP(0x06)</span></span>
    - <span data-ttu-id="4bf72-327">TX_EVENT_FLAG (0x07)</span><span class="sxs-lookup"><span data-stu-id="4bf72-327">TX_EVENT_FLAG (0x07)</span></span>
    - <span data-ttu-id="4bf72-328">TX_BLOCK_MEMORY(0x08)</span><span class="sxs-lookup"><span data-stu-id="4bf72-328">TX_BLOCK_MEMORY(0x08)</span></span>
    - <span data-ttu-id="4bf72-329">TX_BYTE_MEMORY (0x09)</span><span class="sxs-lookup"><span data-stu-id="4bf72-329">TX_BYTE_MEMORY (0x09)</span></span>
    - <span data-ttu-id="4bf72-330">TX_MUTEX_SUSP(0x0D)</span><span class="sxs-lookup"><span data-stu-id="4bf72-330">TX_MUTEX_SUSP(0x0D)</span></span>

> [!IMPORTANT]
> <span data-ttu-id="4bf72-331">Claro que há muitos outros campos interessantes no bloco de controlo de fios, incluindo o ponteiro da pilha, valor de corte de tempo, prioridades, etc. Os utilizadores são bem-vindos a rever os membros do bloco de controlo, mas as modificações são estritamente proibidas!</span><span class="sxs-lookup"><span data-stu-id="4bf72-331">Of course there are many other interesting fields in the thread control block, including the stack pointer, time-slice value, priorities, etc. Users are welcome to review control block members, but modifications are strictly prohibited!</span></span>

> [!IMPORTANT]
> <span data-ttu-id="4bf72-332">Não há equiparia para o estado de "execução" mencionado anteriormente nesta secção.</span><span class="sxs-lookup"><span data-stu-id="4bf72-332">There is no equate for the “executing” state mentioned earlier in this section.</span></span> <span data-ttu-id="4bf72-333">Não é necessário porque só há um fio de execução num dado momento.</span><span class="sxs-lookup"><span data-stu-id="4bf72-333">It is not necessary because there is only one executing thread at a given time.</span></span> <span data-ttu-id="4bf72-334">O estado de um fio de execução também é ***TX_READY***.</span><span class="sxs-lookup"><span data-stu-id="4bf72-334">The state of an executing thread is also ***TX_READY***.</span></span>

### <a name="currently-executing-thread"></a><span data-ttu-id="4bf72-335">Atualmente Executando fio</span><span class="sxs-lookup"><span data-stu-id="4bf72-335">Currently Executing Thread</span></span> 
<span data-ttu-id="4bf72-336">Como mencionado anteriormente, há apenas uma linha executando em qualquer momento.</span><span class="sxs-lookup"><span data-stu-id="4bf72-336">As mentioned before, there is only one thread executing at any given time.</span></span> <span data-ttu-id="4bf72-337">Existem várias formas de identificar o fio de execução, dependendo de qual fio está a fazer o pedido.</span><span class="sxs-lookup"><span data-stu-id="4bf72-337">There are several ways to identify the executing thread, depending on which thread is making the request.</span></span>

<span data-ttu-id="4bf72-338">Um segmento de programa pode obter o endereço do bloco de controlo do fio de execução chamando ***tx_thread_identify***.</span><span class="sxs-lookup"><span data-stu-id="4bf72-338">A program segment can get the control block address of the executing thread by calling ***tx_thread_identify***.</span></span> <span data-ttu-id="4bf72-339">Isto é útil em partes partilhadas do código de aplicação que são executados a partir de vários fios.</span><span class="sxs-lookup"><span data-stu-id="4bf72-339">This is useful in shared portions of application code that are executed from multiple threads.</span></span>

<span data-ttu-id="4bf72-340">Nas sessões de depurar, os utilizadores podem examinar a matriz interna de ponteiro ThreadX SMP ***_tx_thread_current_ptr[core]***.</span><span class="sxs-lookup"><span data-stu-id="4bf72-340">In debug sessions, users can examine the internal ThreadX SMP pointer array ***_tx_thread_current_ptr[core]***.</span></span> <span data-ttu-id="4bf72-341">Contém o endereço do bloco de controlo do fio atualmente executado.</span><span class="sxs-lookup"><span data-stu-id="4bf72-341">It contains the control block address of the currently executing thread.</span></span> <span data-ttu-id="4bf72-342">Se este ponteiro for NU, não está a executar nenhum fio de aplicação; ou seja, a ThreadX SMP está à espera no seu ciclo de agendamento para que um fio se prepare.</span><span class="sxs-lookup"><span data-stu-id="4bf72-342">If this pointer is NULL, no application thread is executing; i.e., ThreadX SMP is waiting in its scheduling loop for a thread to become ready.</span></span>

### <a name="thread-stack-area"></a><span data-ttu-id="4bf72-343">Área de pilha de fio</span><span class="sxs-lookup"><span data-stu-id="4bf72-343">Thread Stack Area</span></span> 
<span data-ttu-id="4bf72-344">Cada fio deve ter a sua própria pilha para salvar o contexto da sua última execução e utilização do compilador.</span><span class="sxs-lookup"><span data-stu-id="4bf72-344">Each thread must have its own stack for saving the context of its last execution and compiler use.</span></span> <span data-ttu-id="4bf72-345">A maioria dos compiladores C usa a pilha para fazer chamadas de função e para alocar temporariamente variáveis locais.</span><span class="sxs-lookup"><span data-stu-id="4bf72-345">Most C compilers use the stack for making function calls and for temporarily allocating local variables.</span></span> <span data-ttu-id="4bf72-346">A figura 5 na página 61 mostra uma pilha típica de fio.</span><span class="sxs-lookup"><span data-stu-id="4bf72-346">Figure 5 on page 61 shows a typical thread’s stack.</span></span>

![Área de pilha de fio](media/image8.png)

<span data-ttu-id="4bf72-348">**FIGURA 5. Pilha de fio típica**</span><span class="sxs-lookup"><span data-stu-id="4bf72-348">**FIGURE 5. Typical Thread Stack**</span></span>

<span data-ttu-id="4bf72-349">Onde uma pilha de fios está localizada na memória é até a aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-349">Where a thread stack is located in memory is up to the application.</span></span> <span data-ttu-id="4bf72-350">A área da pilha é especificada durante a criação do fio e pode ser localizada em qualquer lugar no espaço de endereço do alvo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-350">The stack area is specified during thread creation and can be located anywhere in the target’s address space.</span></span> <span data-ttu-id="4bf72-351">Esta é uma característica importante porque permite que as aplicações melhorem o desempenho de fios importantes colocando a sua pilha em RAM de alta velocidade.</span><span class="sxs-lookup"><span data-stu-id="4bf72-351">This is an important feature because it allows applications to improve performance of important threads by placing their stack in high-speed RAM.</span></span>

<span data-ttu-id="4bf72-352">Quão grande deve ser uma pilha é uma das perguntas mais frequentes sobre fios.</span><span class="sxs-lookup"><span data-stu-id="4bf72-352">How big a stack should be is one of the most frequently asked questions about threads.</span></span> <span data-ttu-id="4bf72-353">A área de pilha de um fio deve ser grande o suficiente para acomodar a pior fase de cartotação de função, alocação variável local, e salvar o seu último contexto de execução.</span><span class="sxs-lookup"><span data-stu-id="4bf72-353">A thread’s stack area must be large enough to accommodate worst-case function call nesting, local variable allocation, and saving its last execution context.</span></span>

<span data-ttu-id="4bf72-354">O tamanho mínimo da pilha, **TX_MINIMUM_STACK,** é definido pela ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="4bf72-354">The minimum stack size, **TX_MINIMUM_STACK**, is defined by ThreadX SMP.</span></span> <span data-ttu-id="4bf72-355">Uma pilha deste tamanho suporta a poupança do contexto de um fio e a quantidade mínima de chamadas de função e alocação variável local.</span><span class="sxs-lookup"><span data-stu-id="4bf72-355">A stack of this size supports saving a thread’s context and minimum amount of function calls and local variable allocation.</span></span>

<span data-ttu-id="4bf72-356">No entanto, para a maioria dos fios, o tamanho mínimo da pilha é demasiado pequeno, e o utilizador deve determinar o requisito de tamanho mais reduzido examinando o nidificação de chamada de função e a atribuição variável local.</span><span class="sxs-lookup"><span data-stu-id="4bf72-356">For most threads, however, the minimum stack size is too small, and the user must ascertain the worstcase size requirement by examining function-call nesting and local variable allocation.</span></span> <span data-ttu-id="4bf72-357">Claro, é sempre melhor começar com uma área de pilha maior.</span><span class="sxs-lookup"><span data-stu-id="4bf72-357">Of course, it is always better to start with a larger stack area.</span></span>

<span data-ttu-id="4bf72-358">Depois de depurada a aplicação, é possível sintonizar os tamanhos da pilha de fio se a memória for escassa.</span><span class="sxs-lookup"><span data-stu-id="4bf72-358">After the application is debugged, it is possible to tune the thread stack sizes if memory is scarce.</span></span> <span data-ttu-id="4bf72-359">Um truque favorito é pré-definidor todas as áreas de pilha com um padrão de dados facilmente identificável como (0xEFEF) antes de criar os fios.</span><span class="sxs-lookup"><span data-stu-id="4bf72-359">A favorite trick is to preset all stack areas with an easily identifiable data pattern like (0xEFEF) prior to creating the threads.</span></span> <span data-ttu-id="4bf72-360">Depois de a aplicação ter sido completamente submetida aos seus ritmos, as áreas de pilha podem ser examinadas para ver quanto stack foi realmente usado encontrando a área da pilha onde o padrão de dados ainda está intacto.</span><span class="sxs-lookup"><span data-stu-id="4bf72-360">After the application has been thoroughly put through its paces, the stack areas can be examined to see how much stack was actually used by finding the area of the stack where the data pattern is still intact.</span></span> <span data-ttu-id="4bf72-361">A figura 6 mostra uma pilha predefinida para 0xEFEF após a execução completa do fio.</span><span class="sxs-lookup"><span data-stu-id="4bf72-361">Figure 6 shows a stack preset to 0xEFEF after thorough thread execution.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="4bf72-362">Por predefinição, o ThreadX SMP inicializa cada byte de cada pilha de fios com um valor de 0xEF.</span><span class="sxs-lookup"><span data-stu-id="4bf72-362">By default, ThreadX SMP initializes every byte of each thread stack with a value of 0xEF.</span></span>

### <a name="memory-pitfalls"></a><span data-ttu-id="4bf72-363">Armadilhas de memória</span><span class="sxs-lookup"><span data-stu-id="4bf72-363">Memory Pitfalls</span></span> 
<span data-ttu-id="4bf72-364">Os requisitos da pilha para fios podem ser grandes.</span><span class="sxs-lookup"><span data-stu-id="4bf72-364">The stack requirements for threads can be large.</span></span> <span data-ttu-id="4bf72-365">Por isso, é importante conceber a aplicação para ter um número razoável de fios.</span><span class="sxs-lookup"><span data-stu-id="4bf72-365">Therefore, it is important to design the application to have a reasonable number of threads.</span></span> <span data-ttu-id="4bf72-366">Além disso, há que ter alguns cuidados para evitar uma utilização excessiva da pilha dentro dos fios.</span><span class="sxs-lookup"><span data-stu-id="4bf72-366">Furthermore, some care must be taken to avoid excessive stack usage within threads.</span></span> <span data-ttu-id="4bf72-367">Devem ser evitados algoritmos recursivos e grandes estruturas de dados locais.</span><span class="sxs-lookup"><span data-stu-id="4bf72-367">Recursive algorithms and large local data structures should be avoided.</span></span>

<span data-ttu-id="4bf72-368">Na maioria dos casos, uma pilha transbordada causa a execução do fio para corromper a memória adjacente (geralmente</span><span class="sxs-lookup"><span data-stu-id="4bf72-368">In most cases, an overflowed stack causes thread execution to corrupt memory adjacent (usually</span></span> 

![Armadilhas de memória](media/image9.png)

<span data-ttu-id="4bf72-370">**FIGURA 6. Stack Predefinição para 0xEFEF**</span><span class="sxs-lookup"><span data-stu-id="4bf72-370">**FIGURE 6. Stack Preset to 0xEFEF**</span></span>

<span data-ttu-id="4bf72-371">antes) a sua área de pilha.</span><span class="sxs-lookup"><span data-stu-id="4bf72-371">before) its stack area.</span></span> <span data-ttu-id="4bf72-372">Os resultados são imprevisíveis, mas na maioria das vezes resultam numa mudança não natural no balcão do programa.</span><span class="sxs-lookup"><span data-stu-id="4bf72-372">The results are unpredictable, but most often result in an un-natural change in the program counter.</span></span> <span data-ttu-id="4bf72-373">Isto é muitas vezes chamado de "saltar para as casas de fora".</span><span class="sxs-lookup"><span data-stu-id="4bf72-373">This is often called “jumping into the weeds.”</span></span> <span data-ttu-id="4bf72-374">Claro que a única maneira de prevenir isto é garantir que todas as pilhas de fios são grandes o suficiente.</span><span class="sxs-lookup"><span data-stu-id="4bf72-374">Of course, the only way to prevent this is to ensure all thread stacks are large enough.</span></span>

### <a name="optional-run-time-stack-checking"></a><span data-ttu-id="4bf72-375">Verificação opcional do tempo de execução</span><span class="sxs-lookup"><span data-stu-id="4bf72-375">Optional Run-time Stack Checking</span></span>  
<span data-ttu-id="4bf72-376">A ThreadX SMP fornece a capacidade de verificar a pilha de cada fio por corrupção durante o tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="4bf72-376">ThreadX SMP provides the ability to check each thread's stack for corruption during run-time.</span></span> <span data-ttu-id="4bf72-377">Por predefinição, o ThreadX SMP preenche todos os bytes de pilhas de fios com um 0xEF padrão de dados durante a criação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-377">By default, ThreadX SMP fills every byte of thread stacks with a 0xEF data pattern during creation.</span></span> <span data-ttu-id="4bf72-378">Se a aplicação construir a biblioteca ThreadX SMP com \***TX_ENABLE_STACK_CHECKING** _ definida, a ThreadX SMP examinará a pilha de cada fio para corrupção à medida que for suspensa ou retomada.</span><span class="sxs-lookup"><span data-stu-id="4bf72-378">If the application builds the ThreadX SMP library with \***TX_ENABLE_STACK_CHECKING** _ defined, ThreadX SMP will examine each thread's stack for corruption as it is suspended or resumed.</span></span> <span data-ttu-id="4bf72-379">Se for detetada corrupção de pilha, a ThreadX SMP chamará a rotina de tratamento de erros de stack da aplicação, conforme especificado pela chamada para _tx_thread_stack_error_notify\*.</span><span class="sxs-lookup"><span data-stu-id="4bf72-379">If stack corruption is detected, ThreadX SMP will call the application's stack error handling routine as specified by the call to _tx_thread_stack_error_notify\*.</span></span> <span data-ttu-id="4bf72-380">Caso contrário, se não for especificado nenhum manipulador de erros de pilha, a ThreadX SMP chamará a rotina de *_tx_thread_stack_error_handler* interna.</span><span class="sxs-lookup"><span data-stu-id="4bf72-380">Otherwise, if no stack error handler was specified, ThreadX SMP will call the internal *_tx_thread_stack_error_handler* routine.</span></span>

### <a name="reentrancy"></a><span data-ttu-id="4bf72-381">Reentrada</span><span class="sxs-lookup"><span data-stu-id="4bf72-381">Reentrancy</span></span> 
<span data-ttu-id="4bf72-382">Uma das verdadeiras belezas da multi-leitura é que a mesma função C pode ser chamada de vários fios.</span><span class="sxs-lookup"><span data-stu-id="4bf72-382">One of the real beauties of multithreading is that the same C function can be called from multiple threads.</span></span> <span data-ttu-id="4bf72-383">Isto fornece uma grande potência e também ajuda a reduzir o espaço de código.</span><span class="sxs-lookup"><span data-stu-id="4bf72-383">This provides great power and also helps reduce code space.</span></span> <span data-ttu-id="4bf72-384">No entanto, requer que as funções C chamadas de múltiplos fios sejam *reentrantes*.</span><span class="sxs-lookup"><span data-stu-id="4bf72-384">However, it does require that C functions called from multiple threads are *reentrant*.</span></span>

<span data-ttu-id="4bf72-385">Basicamente, uma função de reentrante armazena o endereço de retorno do chamador na pilha atual e não se baseia em variáveis C globais ou estáticas que previamente configura.</span><span class="sxs-lookup"><span data-stu-id="4bf72-385">Basically, a reentrant function stores the caller’s return address on the current stack and does not rely on global or static C variables that it previously set up.</span></span> <span data-ttu-id="4bf72-386">A maioria dos compiladores coloca o endereço de retorno na pilha.</span><span class="sxs-lookup"><span data-stu-id="4bf72-386">Most compilers place the return address on the stack.</span></span> <span data-ttu-id="4bf72-387">Assim, os desenvolvedores de aplicações só devem preocupar-se com a utilização de *globais* e *estáticas.*</span><span class="sxs-lookup"><span data-stu-id="4bf72-387">Hence, application developers must only worry about the use of *globals* and *statics*.</span></span>

<span data-ttu-id="4bf72-388">Um exemplo de uma função não-reentrante é a função de símbolo de corda "strtok" encontrada na biblioteca C padrão.</span><span class="sxs-lookup"><span data-stu-id="4bf72-388">An example of a non-reentrant function is the string token function “strtok” found in the standard C library.</span></span> <span data-ttu-id="4bf72-389">Esta função lembra-se do ponteiro de cordas anterior nas chamadas subsequentes.</span><span class="sxs-lookup"><span data-stu-id="4bf72-389">This function remembers the previous string pointer on subsequent calls.</span></span> <span data-ttu-id="4bf72-390">Faz isto com um ponteiro estático de cordas.</span><span class="sxs-lookup"><span data-stu-id="4bf72-390">It does this with a static string pointer.</span></span> <span data-ttu-id="4bf72-391">Se esta função for chamada de vários fios, provavelmente devolverá um ponteiro inválido.</span><span class="sxs-lookup"><span data-stu-id="4bf72-391">If this function is called from multiple threads, it would most likely return an invalid pointer.</span></span>

### <a name="thread-priority-pitfalls"></a><span data-ttu-id="4bf72-392">Armadilhas prioritárias de linha</span><span class="sxs-lookup"><span data-stu-id="4bf72-392">Thread Priority Pitfalls</span></span> 
<span data-ttu-id="4bf72-393">A seleção das prioridades de linha é um dos aspetos mais importantes da multi-leitura.</span><span class="sxs-lookup"><span data-stu-id="4bf72-393">Selecting thread priorities is one of the most important aspects of multithreading.</span></span> <span data-ttu-id="4bf72-394">Por vezes, é muito tentador atribuir prioridades baseadas numa noção percebida de importância do fio, em vez de determinar o que é exatamente necessário durante o período de tempo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-394">It is sometimes very tempting to assign priorities based on a perceived notion of thread importance rather than determining what is exactly required during run-time.</span></span> <span data-ttu-id="4bf72-395">O uso indevido das prioridades dos fios pode passar fome noutros fios, criar inversão prioritária, reduzir a largura de banda de processamento e dificultar a compreensão do comportamento da aplicação no tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="4bf72-395">Misuse of thread priorities can starve other threads, create priority inversion, reduce processing bandwidth, and make the application’s run-time behavior difficult to understand.</span></span>

<span data-ttu-id="4bf72-396">Como mencionado anteriormente, a ThreadX SMP fornece um algoritmo de agendamento preventivo baseado em prioridades.</span><span class="sxs-lookup"><span data-stu-id="4bf72-396">As mentioned before, ThreadX SMP provides a priority-based, preemptive scheduling algorithm.</span></span> <span data-ttu-id="4bf72-397">Os fios de prioridade inferior não executam até que não existam fios de prioridade mais elevados prontos para a execução.</span><span class="sxs-lookup"><span data-stu-id="4bf72-397">Lower priority threads do not execute until there are no higher priority threads ready for execution.</span></span> <span data-ttu-id="4bf72-398">Se um fio de prioridade superior estiver sempre pronto, os fios de prioridade inferior nunca executam.</span><span class="sxs-lookup"><span data-stu-id="4bf72-398">If a higher priority thread is always ready, the lower priority threads never execute.</span></span> <span data-ttu-id="4bf72-399">Esta condição é chamada *de fome de fio.*</span><span class="sxs-lookup"><span data-stu-id="4bf72-399">This condition is called *thread starvation*.</span></span>

<span data-ttu-id="4bf72-400">A maioria dos problemas de fome dos fios são detetados no início do depurar e podem ser resolvidos garantindo que os fios de maior prioridade não executam continuamente.</span><span class="sxs-lookup"><span data-stu-id="4bf72-400">Most thread starvation problems are detected early in debug and can be solved by ensuring that higher priority threads don’t execute continuously.</span></span> <span data-ttu-id="4bf72-401">Em alternativa, a lógica pode ser adicionada à aplicação que gradualmente aumenta a prioridade dos fios famintos até que tenham a oportunidade de executar.</span><span class="sxs-lookup"><span data-stu-id="4bf72-401">Alternatively, logic can be added to the application that gradually raises the priority of starved threads until they get a chance to execute.</span></span>

<span data-ttu-id="4bf72-402">Outra armadilha associada às prioridades do fio é *a inversão prioritária.*</span><span class="sxs-lookup"><span data-stu-id="4bf72-402">Another pitfall associated with thread priorities is *priority inversion*.</span></span> <span data-ttu-id="4bf72-403">A inversão prioritária ocorre quando um fio de prioridade superior é suspenso porque um fio de prioridade inferior tem um recurso necessário.</span><span class="sxs-lookup"><span data-stu-id="4bf72-403">Priority inversion takes place when a higher priority thread is suspended because a lower priority thread has a needed resource.</span></span> <span data-ttu-id="4bf72-404">Naturalmente, em alguns casos, é necessário que dois fios de prioridade diferente partilhem um recurso comum.</span><span class="sxs-lookup"><span data-stu-id="4bf72-404">Of course, in some instances it is necessary for two threads of different priority to share a common resource.</span></span> <span data-ttu-id="4bf72-405">Se estes fios forem os únicos ativos, o tempo de inversão prioritário é limitado pelo momento em que o fio de prioridade inferior detém o recurso.</span><span class="sxs-lookup"><span data-stu-id="4bf72-405">If these threads are the only ones active, the priority inversion time is bounded by the time the lower priority thread holds the resource.</span></span> <span data-ttu-id="4bf72-406">Esta condição é determinística e normal.</span><span class="sxs-lookup"><span data-stu-id="4bf72-406">This condition is both deterministic and quite normal.</span></span> <span data-ttu-id="4bf72-407">No entanto, se os fios de prioridade intermédia se tornarem ativos durante esta condição prioritária de inversão, o tempo de inversão prioritário já não é determinístico e pode causar uma falha de aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-407">However, if threads of intermediate priority become active during this priority inversion condition, the priority inversion time is no longer deterministic and could cause an application failure.</span></span>

<span data-ttu-id="4bf72-408">Existem principalmente três métodos distintos de prevenção da inversão de prioridade não determinística no ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="4bf72-408">There are principally three distinct methods of preventing nondeterministic priority inversion in ThreadX SMP.</span></span> <span data-ttu-id="4bf72-409">Em primeiro lugar, as seleções prioritárias de aplicação e o comportamento em tempo de execução podem ser projetados de uma forma que impeça o problema de inversão prioritária.</span><span class="sxs-lookup"><span data-stu-id="4bf72-409">First, the application priority selections and run-time behavior can be designed in a manner that prevents the priority inversion problem.</span></span> <span data-ttu-id="4bf72-410">Em segundo lugar, os fios de prioridade inferior podem utilizar *o limiar de pré-edição* para bloquear a preempção dos fios intermédios, enquanto partilham recursos com fios de prioridade mais elevados.</span><span class="sxs-lookup"><span data-stu-id="4bf72-410">Second, lower priority threads can utilize *preemption-threshold* to block preemption from intermediate threads while they share resources with higher priority threads.</span></span> <span data-ttu-id="4bf72-411">Finalmente, os fios que utilizam objetos mutex ThreadX SMP para proteger os recursos do sistema podem utilizar a *herança prioritária* de mutex opcional para eliminar a inversão de prioridade não determinativa.</span><span class="sxs-lookup"><span data-stu-id="4bf72-411">Finally, threads using ThreadX SMP mutex objects to protect system resources may utilize the optional mutex *priority inheritance* to eliminate nondeterministic priority inversion.</span></span>

### <a name="priority-overhead"></a><span data-ttu-id="4bf72-412">Prioridade Overhead</span><span class="sxs-lookup"><span data-stu-id="4bf72-412">Priority Overhead</span></span> 
<span data-ttu-id="4bf72-413">Uma das formas mais negligenciadas de reduzir a sobrecarga em multi-leitura é reduzir o número de interruptores de contexto.</span><span class="sxs-lookup"><span data-stu-id="4bf72-413">One of the most overlooked ways to reduce overhead in multithreading is to reduce the number of context switches.</span></span> <span data-ttu-id="4bf72-414">Como mencionado anteriormente, ocorre um interruptor de contexto quando a execução de um fio de prioridade superior é favorecida em relação à do fio de execução.</span><span class="sxs-lookup"><span data-stu-id="4bf72-414">As previously mentioned, a context switch occurs when execution of a higher priority thread is favored over that of the executing thread.</span></span> <span data-ttu-id="4bf72-415">Vale a pena mencionar que os fios de prioridade mais elevados podem ficar prontos como resultado tanto de eventos externos (como interrupções) como de chamadas de serviço efetuadas pelo fio de execução.</span><span class="sxs-lookup"><span data-stu-id="4bf72-415">It is worthwhile to mention that higher priority threads can become ready as a result of both external events (like interrupts) and from service calls made by the executing thread.</span></span>

<span data-ttu-id="4bf72-416">Para ilustrar os efeitos que as prioridades do fio têm na sobrecarga do interruptor de contexto, assuma um ambiente de três fios com fios denominados *thread_1*, *thread_2* e *thread_3*.</span><span class="sxs-lookup"><span data-stu-id="4bf72-416">To illustrate the effects thread priorities have on context switch overhead, assume a three thread environment with threads named *thread_1*, *thread_2*, and *thread_3*.</span></span> <span data-ttu-id="4bf72-417">Assuma ainda que todos os fios estão em estado de suspensão à espera de uma mensagem.</span><span class="sxs-lookup"><span data-stu-id="4bf72-417">Assume further that all of the threads are in a state of suspension waiting for a message.</span></span> <span data-ttu-id="4bf72-418">Quando thread_1 recebe uma mensagem, encaminha-a imediatamente para thread_2.</span><span class="sxs-lookup"><span data-stu-id="4bf72-418">When thread_1 receives a message, it immediately forwards it to thread_2.</span></span> <span data-ttu-id="4bf72-419">Thread_2 reencaminha a mensagem para thread_3.</span><span class="sxs-lookup"><span data-stu-id="4bf72-419">Thread_2 then forwards the message to thread_3.</span></span> <span data-ttu-id="4bf72-420">Thread_3 apenas descarta a mensagem.</span><span class="sxs-lookup"><span data-stu-id="4bf72-420">Thread_3 just discards the message.</span></span> <span data-ttu-id="4bf72-421">Depois de cada fio processar a sua mensagem, ela volta e espera por outra mensagem.</span><span class="sxs-lookup"><span data-stu-id="4bf72-421">After each thread processes its message, it goes back and waits for another message.</span></span>

<span data-ttu-id="4bf72-422">O processamento necessário para executar estes três fios varia muito dependendo das suas prioridades.</span><span class="sxs-lookup"><span data-stu-id="4bf72-422">The processing required to execute these three threads varies greatly depending on their priorities.</span></span> <span data-ttu-id="4bf72-423">Se todos os fios tiverem a mesma prioridade, ocorre um único interruptor de contexto antes da execução de cada fio.</span><span class="sxs-lookup"><span data-stu-id="4bf72-423">If all of the threads have the same priority, a single context switch occurs before the execution of each thread.</span></span> <span data-ttu-id="4bf72-424">O interruptor de contexto ocorre quando cada fio suspende numa fila de mensagens vazias.</span><span class="sxs-lookup"><span data-stu-id="4bf72-424">The context switch occurs when each thread suspends on an empty message queue.</span></span>

<span data-ttu-id="4bf72-425">No entanto, se thread_2 é maior prioridade do que thread_1 e thread_3 é maior prioridade do que thread_2, o número de interruptores de contexto duplica.</span><span class="sxs-lookup"><span data-stu-id="4bf72-425">However, if thread_2 is higher priority than thread_1 and thread_3 is higher priority than thread_2, the number of context switches doubles.</span></span> <span data-ttu-id="4bf72-426">Isto porque ocorre um outro interruptor de contexto dentro do serviço *tx_queue_send* quando deteta que um fio de prioridade superior está agora pronto.</span><span class="sxs-lookup"><span data-stu-id="4bf72-426">This is because another context switch occurs inside of the *tx_queue_send* service when it detects that a higher priority thread is now ready.</span></span>

<span data-ttu-id="4bf72-427">O mecanismo de limiar de pré-edição ThreadX SMP pode evitar estes interruptores de contexto extra e ainda permitir as seleções prioritárias anteriormente mencionadas.</span><span class="sxs-lookup"><span data-stu-id="4bf72-427">The ThreadX SMP preemption-threshold mechanism can avoid these extra context switches and still allow the previously mentioned priority selections.</span></span> <span data-ttu-id="4bf72-428">Esta é uma característica importante porque permite várias prioridades de linha durante o agendamento, ao mesmo tempo que elimina parte do contexto indesejado que alterna entre eles durante a execução do fio.</span><span class="sxs-lookup"><span data-stu-id="4bf72-428">This is an important feature because it allows several thread priorities during scheduling, while at the same time eliminating some of the unwanted context switching between them during thread execution.</span></span>

### <a name="run-time-thread-performance-information"></a><span data-ttu-id="4bf72-429">Informações de desempenho do fio em tempo de execução</span><span class="sxs-lookup"><span data-stu-id="4bf72-429">Run-time Thread Performance Information</span></span> 
<span data-ttu-id="4bf72-430">A ThreadX SMP fornece informações opcionais de desempenho do fio de tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="4bf72-430">ThreadX SMP provides optional run-time thread performance information.</span></span> <span data-ttu-id="4bf72-431">Se a biblioteca e aplicação ThreadX SMP for construída com ***TX_THREAD_ENABLE_PERFORMANCE_INFO*** definida, a ThreadX SMP acumula as seguintes informações:</span><span class="sxs-lookup"><span data-stu-id="4bf72-431">If the ThreadX SMP library and application is built with ***TX_THREAD_ENABLE_PERFORMANCE_INFO*** defined, ThreadX SMP accumulates the following information:</span></span>

<span data-ttu-id="4bf72-432">Número total do sistema global:</span><span class="sxs-lookup"><span data-stu-id="4bf72-432">Total number for the overall system:</span></span>

- <span data-ttu-id="4bf72-433">resuflações de fio</span><span class="sxs-lookup"><span data-stu-id="4bf72-433">thread resumptions</span></span>
- <span data-ttu-id="4bf72-434">suspensões de fio</span><span class="sxs-lookup"><span data-stu-id="4bf72-434">thread suspensions</span></span>
- <span data-ttu-id="4bf72-435">pré-pedidos de chamada de serviço</span><span class="sxs-lookup"><span data-stu-id="4bf72-435">service call preemptions</span></span>
- <span data-ttu-id="4bf72-436">interromper as preventivas</span><span class="sxs-lookup"><span data-stu-id="4bf72-436">interrupt preemptions</span></span>
- <span data-ttu-id="4bf72-437">inversões prioritárias</span><span class="sxs-lookup"><span data-stu-id="4bf72-437">priority inversions</span></span>
- <span data-ttu-id="4bf72-438">fatias de tempo</span><span class="sxs-lookup"><span data-stu-id="4bf72-438">time-slices</span></span>
- <span data-ttu-id="4bf72-439">renuncia</span><span class="sxs-lookup"><span data-stu-id="4bf72-439">relinquishes</span></span>
- <span data-ttu-id="4bf72-440">intervalos de tempo de fio</span><span class="sxs-lookup"><span data-stu-id="4bf72-440">thread timeouts</span></span>
- <span data-ttu-id="4bf72-441">suspensão aborta</span><span class="sxs-lookup"><span data-stu-id="4bf72-441">suspension aborts</span></span>
- <span data-ttu-id="4bf72-442">retornos do sistema ocioso</span><span class="sxs-lookup"><span data-stu-id="4bf72-442">idle system returns</span></span>
- <span data-ttu-id="4bf72-443">devoluções de sistemas não ociosos</span><span class="sxs-lookup"><span data-stu-id="4bf72-443">non-idle system returns</span></span>

<span data-ttu-id="4bf72-444">Número total de cada fio:</span><span class="sxs-lookup"><span data-stu-id="4bf72-444">Total number for each thread:</span></span>

- <span data-ttu-id="4bf72-445">retomas</span><span class="sxs-lookup"><span data-stu-id="4bf72-445">resumptions</span></span>
- <span data-ttu-id="4bf72-446">suspensões</span><span class="sxs-lookup"><span data-stu-id="4bf72-446">suspensions</span></span>
- <span data-ttu-id="4bf72-447">pré-pedidos de chamada de serviço</span><span class="sxs-lookup"><span data-stu-id="4bf72-447">service call preemptions</span></span>
- <span data-ttu-id="4bf72-448">interromper as preventivas</span><span class="sxs-lookup"><span data-stu-id="4bf72-448">interrupt preemptions</span></span>
- <span data-ttu-id="4bf72-449">inversões prioritárias</span><span class="sxs-lookup"><span data-stu-id="4bf72-449">priority inversions</span></span>
- <span data-ttu-id="4bf72-450">fatias de tempo</span><span class="sxs-lookup"><span data-stu-id="4bf72-450">time-slices</span></span>
- <span data-ttu-id="4bf72-451">fio renuncia</span><span class="sxs-lookup"><span data-stu-id="4bf72-451">thread relinquishes</span></span>
- <span data-ttu-id="4bf72-452">intervalos de tempo de fio</span><span class="sxs-lookup"><span data-stu-id="4bf72-452">thread timeouts</span></span>
- <span data-ttu-id="4bf72-453">suspensão aborta</span><span class="sxs-lookup"><span data-stu-id="4bf72-453">suspension aborts</span></span>

<span data-ttu-id="4bf72-454">Esta informação está disponível em tempo de execução através dos serviços *tx_thread_performance_info_get* e *tx_thread_performance_system_info_get*.</span><span class="sxs-lookup"><span data-stu-id="4bf72-454">This information is available at run-time through the services *tx_thread_performance_info_get* and *tx_thread_performance_system_info_get*.</span></span> <span data-ttu-id="4bf72-455">As informações sobre o desempenho do fio são úteis para determinar se a aplicação está a comportar-se corretamente.</span><span class="sxs-lookup"><span data-stu-id="4bf72-455">Thread performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="4bf72-456">Também é útil para otimizar a aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-456">It is also useful in optimizing the application.</span></span> <span data-ttu-id="4bf72-457">Por exemplo, um número relativamente elevado de pré-medidas de chamada de serviço pode sugerir que a prioridade do fio e/ou limiar de pré-substituição é demasiado baixa.</span><span class="sxs-lookup"><span data-stu-id="4bf72-457">For example, a relatively high number of service call preemptions might suggest the thread’s priority and/or preemption-threshold is too low.</span></span> <span data-ttu-id="4bf72-458">Além disso, um número relativamente baixo de retornos do sistema inativos pode sugerir que os fios de prioridade mais baixos não estão a ser suspensos o suficiente.</span><span class="sxs-lookup"><span data-stu-id="4bf72-458">Furthermore, a relatively low number of idle system returns might suggest that lower priority threads are not suspending enough.</span></span>

### <a name="debugging-pitfalls"></a><span data-ttu-id="4bf72-459">Depurando armadilhas</span><span class="sxs-lookup"><span data-stu-id="4bf72-459">Debugging Pitfalls</span></span> 
<span data-ttu-id="4bf72-460">Depurar aplicações multi-leituras é um pouco mais difícil porque o mesmo código de programa pode ser executado a partir de vários fios.</span><span class="sxs-lookup"><span data-stu-id="4bf72-460">Debugging multithreaded applications is a little more difficult because the same program code can be executed from multiple threads.</span></span> <span data-ttu-id="4bf72-461">Nesses casos, um ponto de rutura por si só pode não ser suficiente.</span><span class="sxs-lookup"><span data-stu-id="4bf72-461">In such cases, a break-point alone may not be enough.</span></span> <span data-ttu-id="4bf72-462">O depurador também deve ver a matriz do ponteiro de fio atual ***_tx_thread_current_ptr[núcleo]*** usando um ponto de rutura condicional para ver se o fio de chamação é o único a depurar.</span><span class="sxs-lookup"><span data-stu-id="4bf72-462">The debugger must also view the current thread pointer array ***_tx_thread_current_ptr[core]*** using a conditional breakpoint to see if the calling thread is the one to debug.</span></span>

<span data-ttu-id="4bf72-463">Grande parte disto está a ser tratado em pacotes de suporte multi-leitura oferecidos através de vários fornecedores de ferramentas de desenvolvimento.</span><span class="sxs-lookup"><span data-stu-id="4bf72-463">Much of this is being handled in multithreading support packages offered through various development tool vendors.</span></span> <span data-ttu-id="4bf72-464">Devido ao seu design simples, integrar o ThreadX SMP com diferentes ferramentas de desenvolvimento é relativamente fácil.</span><span class="sxs-lookup"><span data-stu-id="4bf72-464">Because of its simple design, integrating ThreadX SMP with different development tools is relatively easy.</span></span>

<span data-ttu-id="4bf72-465">O tamanho da pilha é sempre um tópico importante de depurar em multi-leitura.</span><span class="sxs-lookup"><span data-stu-id="4bf72-465">Stack size is always an important debug topic in multithreading.</span></span> <span data-ttu-id="4bf72-466">Sempre que se observa um comportamento inexplicável, é geralmente um bom primeiro palpite para aumentar os tamanhos das pilhas para todos os fios - especialmente o tamanho da pilha do último fio a executar!</span><span class="sxs-lookup"><span data-stu-id="4bf72-466">Whenever unexplained behavior is observed, it is usually a good first guess to increase stack sizes for all threads—especially the stack size of the last thread to execute!</span></span>

> [!IMPORTANT]
> <span data-ttu-id="4bf72-467">É também uma boa ideia construir a biblioteca ThreadX SMP com TX_ENABLE_STACK_CHECKING definida.</span><span class="sxs-lookup"><span data-stu-id="4bf72-467">It is also a good idea to build the ThreadX SMP library with TX_ENABLE_STACK_CHECKING defined.</span></span> <span data-ttu-id="4bf72-468">Isto ajudará a isolar os problemas de corrupção da pilha o mais cedo possível no processamento!</span><span class="sxs-lookup"><span data-stu-id="4bf72-468">This will help isolate stack corruption problems as early in the processing as possible!</span></span>

## <a name="message-queues"></a><span data-ttu-id="4bf72-469">Filas de mensagens</span><span class="sxs-lookup"><span data-stu-id="4bf72-469">Message Queues</span></span>

<span data-ttu-id="4bf72-470">As filas de mensagens são o principal meio de comunicação interlásso em ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="4bf72-470">Message queues are the primary means of interthread communication in ThreadX SMP.</span></span> <span data-ttu-id="4bf72-471">Uma ou mais mensagens podem residir numa fila de mensagens.</span><span class="sxs-lookup"><span data-stu-id="4bf72-471">One or more messages can reside in a message queue.</span></span> <span data-ttu-id="4bf72-472">Uma fila de mensagens que contém uma única mensagem é geralmente chamada de *caixa de correio*.</span><span class="sxs-lookup"><span data-stu-id="4bf72-472">A message queue that holds a single message is commonly called a *mailbox*.</span></span>

<span data-ttu-id="4bf72-473">As mensagens são copiadas para uma fila *por tx_queue_send* e são copiadas de uma fila *por tx_queue_receive*.</span><span class="sxs-lookup"><span data-stu-id="4bf72-473">Messages are copied to a queue by *tx_queue_send* and are copied from a queue by *tx_queue_receive*.</span></span> <span data-ttu-id="4bf72-474">A única exceção a isso é quando um fio é suspenso enquanto se espera uma mensagem numa fila vazia.</span><span class="sxs-lookup"><span data-stu-id="4bf72-474">The only exception to this is when a thread is suspended while waiting for a message on an empty queue.</span></span> <span data-ttu-id="4bf72-475">Neste caso, a próxima mensagem enviada para a fila é colocada diretamente na área de destino do fio.</span><span class="sxs-lookup"><span data-stu-id="4bf72-475">In this case, the next message sent to the queue is placed directly into the thread’s destination area.</span></span>

<span data-ttu-id="4bf72-476">Cada fila de mensagens é um recurso público.</span><span class="sxs-lookup"><span data-stu-id="4bf72-476">Each message queue is a public resource.</span></span> <span data-ttu-id="4bf72-477">O ThreadX SMP não coloca constrangimentos na forma como as filas de mensagens são utilizadas.</span><span class="sxs-lookup"><span data-stu-id="4bf72-477">ThreadX SMP places no constraints on how message queues are used.</span></span>

### <a name="creating-message-queues"></a><span data-ttu-id="4bf72-478">Criando filas de mensagens</span><span class="sxs-lookup"><span data-stu-id="4bf72-478">Creating Message Queues</span></span> 
<span data-ttu-id="4bf72-479">As filas de mensagens são criadas durante a inicialização ou durante o tempo de funcionamento por fios de aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-479">Message queues are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="4bf72-480">Não há limite para o número de filas de mensagens numa aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-480">There is no limit on the number of message queues in an application.</span></span> 

### <a name="message-size"></a><span data-ttu-id="4bf72-481">Tamanho da mensagem</span><span class="sxs-lookup"><span data-stu-id="4bf72-481">Message Size</span></span> 
<span data-ttu-id="4bf72-482">Cada fila de mensagens suporta uma série de mensagens fixas.</span><span class="sxs-lookup"><span data-stu-id="4bf72-482">Each message queue supports a number of fixedsized messages.</span></span> <span data-ttu-id="4bf72-483">Os tamanhos de mensagem disponíveis são de 1 a 16 palavras de 32 bits inclusive.</span><span class="sxs-lookup"><span data-stu-id="4bf72-483">The available message sizes are 1 through 16 32-bit words inclusive.</span></span> <span data-ttu-id="4bf72-484">O tamanho da mensagem é especificado quando a fila é criada.</span><span class="sxs-lookup"><span data-stu-id="4bf72-484">The message size is specified when the queue is created.</span></span> 

<span data-ttu-id="4bf72-485">As mensagens de aplicação superiores a 16 palavras devem ser passadas por ponteiro.</span><span class="sxs-lookup"><span data-stu-id="4bf72-485">Application messages greater than 16 words must be passed by pointer.</span></span> <span data-ttu-id="4bf72-486">Isto é conseguido criando uma fila com um tamanho de mensagem de 1 palavra (o suficiente para segurar um ponteiro) e, em seguida, enviando e recebendo ponteiros de mensagens em vez de toda a mensagem.</span><span class="sxs-lookup"><span data-stu-id="4bf72-486">This is accomplished by creating a queue with a message size of 1 word (enough to hold a pointer) and then sending and receiving message pointers instead of the entire message.</span></span>

### <a name="message-queue-capacity"></a><span data-ttu-id="4bf72-487">Capacidade de fila de mensagens</span><span class="sxs-lookup"><span data-stu-id="4bf72-487">Message Queue Capacity</span></span> 
<span data-ttu-id="4bf72-488">O número de mensagens que uma fila pode conter é uma função do tamanho da sua mensagem e do tamanho da área de memória fornecida durante a criação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-488">The number of messages a queue can hold is a function of its message size and the size of the memory area supplied during creation.</span></span> <span data-ttu-id="4bf72-489">A capacidade total de mensagem da fila é calculada dividindo o número de bytes em cada mensagem no número total de bytes na área de memória fornecida.</span><span class="sxs-lookup"><span data-stu-id="4bf72-489">The total message capacity of the queue is calculated by dividing the number of bytes in each message into the total number of bytes in the supplied memory area.</span></span>

<span data-ttu-id="4bf72-490">Por exemplo, se uma fila de mensagens que suporta um tamanho de mensagem de 1 32 bits de palavra (4 bytes) for criada com uma área de memória de 100 bytes, a sua capacidade é de 25 mensagens.</span><span class="sxs-lookup"><span data-stu-id="4bf72-490">For example, if a message queue that supports a message size of 1 32-bit word (4 bytes) is created with a 100-byte memory area, its capacity is 25 messages.</span></span>

### <a name="queue-memory-area"></a><span data-ttu-id="4bf72-491">Área de memória de fila</span><span class="sxs-lookup"><span data-stu-id="4bf72-491">Queue Memory Area</span></span> 
<span data-ttu-id="4bf72-492">Como mencionado anteriormente, a área de memória para mensagens de tamponamento é especificada durante a criação da fila.</span><span class="sxs-lookup"><span data-stu-id="4bf72-492">As mentioned before, the memory area for buffering messages is specified during queue creation.</span></span> <span data-ttu-id="4bf72-493">Tal como outras áreas de memória no ThreadX SMP, pode ser localizado em qualquer lugar do espaço de endereço do alvo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-493">Like other memory areas in ThreadX SMP, it can be located anywhere in the target’s address space.</span></span>

<span data-ttu-id="4bf72-494">Esta é uma característica importante porque confere à aplicação uma flexibilidade considerável.</span><span class="sxs-lookup"><span data-stu-id="4bf72-494">This is an important feature because it gives the application considerable flexibility.</span></span> <span data-ttu-id="4bf72-495">Por exemplo, uma aplicação pode localizar a área de memória de uma fila importante em RAM de alta velocidade para melhorar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="4bf72-495">For example, an application might locate the memory area of an important queue in high-speed RAM to improve performance.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="4bf72-496">Suspensão do fio</span><span class="sxs-lookup"><span data-stu-id="4bf72-496">Thread Suspension</span></span>  
<span data-ttu-id="4bf72-497">Os fios de aplicação podem suspender enquanto tentam enviar ou receber uma mensagem de uma fila.</span><span class="sxs-lookup"><span data-stu-id="4bf72-497">Application threads can suspend while attempting to send or receive a message from a queue.</span></span> <span data-ttu-id="4bf72-498">Normalmente, a suspensão do fio envolve esperar por uma mensagem de uma fila vazia.</span><span class="sxs-lookup"><span data-stu-id="4bf72-498">Typically, thread suspension involves waiting for a message from an empty queue.</span></span> <span data-ttu-id="4bf72-499">No entanto, também é possível que um fio suspenda a tentativa de enviar uma mensagem para uma fila completa.</span><span class="sxs-lookup"><span data-stu-id="4bf72-499">However, it is also possible for a thread to suspend trying to send a message to a full queue.</span></span> 

<span data-ttu-id="4bf72-500">Após a suspensão ser resolvida, o serviço solicitado é concluído e o fio de espera é retomado.</span><span class="sxs-lookup"><span data-stu-id="4bf72-500">After the condition for suspension is resolved, the service requested is completed and the waiting thread is resumed.</span></span> <span data-ttu-id="4bf72-501">Se várias linhas forem suspensas na mesma fila, são retomadas na ordem em que foram suspensas (FIFO).</span><span class="sxs-lookup"><span data-stu-id="4bf72-501">If multiple threads are suspended on the same queue, they are resumed in the order they were suspended (FIFO).</span></span>

<span data-ttu-id="4bf72-502">No entanto, o reinício prioritário também é possível se a aplicação ligar ***tx_queue_prioritize*** antes do serviço de fila que levanta a suspensão do fio.</span><span class="sxs-lookup"><span data-stu-id="4bf72-502">However, priority resumption is also possible if the application calls ***tx_queue_prioritize*** prior to the queue service that lifts thread suspension.</span></span> <span data-ttu-id="4bf72-503">A fila prioriza o serviço coloca o fio de prioridade mais elevado na parte da frente da lista de suspensão, deixando todos os outros fios suspensos na mesma ordem FIFO.</span><span class="sxs-lookup"><span data-stu-id="4bf72-503">The queue prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

<span data-ttu-id="4bf72-504">Os intervalos também estão disponíveis para todas as suspensões de fila.</span><span class="sxs-lookup"><span data-stu-id="4bf72-504">Time-outs are also available for all queue suspensions.</span></span> <span data-ttu-id="4bf72-505">Basicamente, um tempo limite especifica o número máximo de marcações de temporizador que o fio permanecerá suspenso.</span><span class="sxs-lookup"><span data-stu-id="4bf72-505">Basically, a time-out specifies the maximum number of timer ticks the thread will stay suspended.</span></span> <span data-ttu-id="4bf72-506">Se ocorrer uma intemporádice, o fio é retomado e o serviço retorna com o código de erro apropriado.</span><span class="sxs-lookup"><span data-stu-id="4bf72-506">If a time-out occurs, the thread is resumed and the service returns with the appropriate error code.</span></span>

### <a name="queue-send-notification"></a><span data-ttu-id="4bf72-507">Notificação de envio de fila</span><span class="sxs-lookup"><span data-stu-id="4bf72-507">Queue Send Notification</span></span>  
<span data-ttu-id="4bf72-508">Algumas aplicações podem achar vantajoso ser notificado sempre que uma mensagem é colocada numa fila.</span><span class="sxs-lookup"><span data-stu-id="4bf72-508">Some applications may find it advantageous to be notified whenever a message is placed on a queue.</span></span> <span data-ttu-id="4bf72-509">A ThreadX SMP fornece esta capacidade através do serviço *tx_queue_send_notify.*</span><span class="sxs-lookup"><span data-stu-id="4bf72-509">ThreadX SMP provides this ability through the *tx_queue_send_notify* service.</span></span> <span data-ttu-id="4bf72-510">Este serviço regista a função de notificação de pedido fornecida com a fila especificada.</span><span class="sxs-lookup"><span data-stu-id="4bf72-510">This service registers the supplied application notification function with the specified queue.</span></span> <span data-ttu-id="4bf72-511">A ThreadX SMP irá posteriormente invocar esta função de notificação de aplicação sempre que uma mensagem for enviada para a fila.</span><span class="sxs-lookup"><span data-stu-id="4bf72-511">ThreadX SMP will subsequently invoke this application notification function whenever a message is sent to the queue.</span></span> <span data-ttu-id="4bf72-512">O processamento exato dentro da função de notificação de pedido é determinado pelo pedido; no entanto, consiste tipicamente em retomar o fio adequado para o processamento da nova mensagem.</span><span class="sxs-lookup"><span data-stu-id="4bf72-512">The exact processing within the application notification function is determined by the application; however, it typically consists of resuming the appropriate thread for processing the new message.</span></span>

### <a name="queue-event-chaining"></a><span data-ttu-id="4bf72-513">Acorrentamento de eventos de fila™</span><span class="sxs-lookup"><span data-stu-id="4bf72-513">Queue Event-chaining™</span></span>  
<span data-ttu-id="4bf72-514">As capacidades de notificação no ThreadX SMP podem ser usadas para acorrentar vários eventos de sincronização em conjunto.</span><span class="sxs-lookup"><span data-stu-id="4bf72-514">The notification capabilities in ThreadX SMP can be used to chain various synchronization events together.</span></span> <span data-ttu-id="4bf72-515">Isto é normalmente útil quando um único fio deve processar vários eventos de sincronização.</span><span class="sxs-lookup"><span data-stu-id="4bf72-515">This is typically useful when a single thread must process multiple synchronization events.</span></span>

<span data-ttu-id="4bf72-516">Por exemplo, suponha que um único fio é responsável pelo processamento de mensagens de cinco filas diferentes e também deve suspender quando não há mensagens disponíveis.</span><span class="sxs-lookup"><span data-stu-id="4bf72-516">For example, suppose a single thread is responsible for processing messages from five different queues and must also suspend when no messages are available.</span></span> <span data-ttu-id="4bf72-517">Isto é facilmente conseguido registando uma função de notificação de aplicação para cada fila e introduzindo um semáforo de contagem adicional.</span><span class="sxs-lookup"><span data-stu-id="4bf72-517">This is easily accomplished by registering an application notification function for each queue and introducing an additional counting semaphore.</span></span> <span data-ttu-id="4bf72-518">Especificamente, a função de notificação de aplicação executa uma *tx_semaphore_put* sempre que é chamada (a contagem de semáforos representa o número total de mensagens em todas as cinco filas).</span><span class="sxs-lookup"><span data-stu-id="4bf72-518">Specifically, the application notification function performs a *tx_semaphore_put* whenever it is called (the semaphore count represents the total number of messages in all five queues).</span></span> <span data-ttu-id="4bf72-519">O fio de processamento suspende este semáforo através do serviço *tx_semaphore_get.*</span><span class="sxs-lookup"><span data-stu-id="4bf72-519">The processing thread suspends on this semaphore via the *tx_semaphore_get* service.</span></span> <span data-ttu-id="4bf72-520">Quando o semáforo estiver disponível (neste caso, quando uma mensagem está disponível!), o fio de processamento é retomado.</span><span class="sxs-lookup"><span data-stu-id="4bf72-520">When the semaphore is available (in this case, when a message is available!), the processing thread is resumed.</span></span> <span data-ttu-id="4bf72-521">Em seguida, interroga cada fila para uma mensagem, processa a mensagem encontrada, e executa outra *tx_semaphore_get* esperar pela próxima mensagem.</span><span class="sxs-lookup"><span data-stu-id="4bf72-521">It then interrogates each queue for a message, processes the found message, and performs another *tx_semaphore_get* to wait for the next message.</span></span> <span data-ttu-id="4bf72-522">Conseguir isto sem acorrentar eventos é bastante difícil e provavelmente exigiria mais fios e/ou código de aplicação adicional.</span><span class="sxs-lookup"><span data-stu-id="4bf72-522">Accomplishing this without event-chaining is quite difficult and likely would require more threads and/or additional application code.</span></span>

<span data-ttu-id="4bf72-523">Em geral, *acorrentamento de eventos* resulta em menos fios, menos sobrecargas e menores requisitos de RAM.</span><span class="sxs-lookup"><span data-stu-id="4bf72-523">In general, *event-chaining* results in fewer threads, less overhead, and smaller RAM requirements.</span></span> <span data-ttu-id="4bf72-524">Também fornece um mecanismo altamente flexível para lidar com os requisitos de sincronização de sistemas mais complexos.</span><span class="sxs-lookup"><span data-stu-id="4bf72-524">It also provides a highly flexible mechanism to handle synchronization requirements of more complex systems.</span></span>

### <a name="run-time-queue-performance-information"></a><span data-ttu-id="4bf72-525">Informações de desempenho da fila de tempo de execução</span><span class="sxs-lookup"><span data-stu-id="4bf72-525">Run-time Queue Performance Information</span></span>  
<span data-ttu-id="4bf72-526">A ThreadX SMP fornece informações opcionais de desempenho da fila de tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="4bf72-526">ThreadX SMP provides optional run-time queue performance information.</span></span> <span data-ttu-id="4bf72-527">Se a biblioteca e aplicação ThreadX SMP for construída com ***TX_QUEUE_ENABLE_PERFORMANCE_INFO*** definida, a ThreadX SMP acumula as seguintes informações:</span><span class="sxs-lookup"><span data-stu-id="4bf72-527">If the ThreadX SMP library and application is built with ***TX_QUEUE_ENABLE_PERFORMANCE_INFO*** defined, ThreadX SMP accumulates the following information:</span></span>

<span data-ttu-id="4bf72-528">Número total do sistema global:</span><span class="sxs-lookup"><span data-stu-id="4bf72-528">Total number for the overall system:</span></span>

- <span data-ttu-id="4bf72-529">mensagens enviadas</span><span class="sxs-lookup"><span data-stu-id="4bf72-529">messages sent</span></span>
- <span data-ttu-id="4bf72-530">mensagens recebidas</span><span class="sxs-lookup"><span data-stu-id="4bf72-530">messages received</span></span>
- <span data-ttu-id="4bf72-531">suspensões vazias fila</span><span class="sxs-lookup"><span data-stu-id="4bf72-531">queue empty suspensions</span></span>
- <span data-ttu-id="4bf72-532">suspensões completas fila</span><span class="sxs-lookup"><span data-stu-id="4bf72-532">queue full suspensions</span></span>
- <span data-ttu-id="4bf72-533">retornas de erro completo da fila (suspensão não speci-fied)</span><span class="sxs-lookup"><span data-stu-id="4bf72-533">queue full error returns (suspension not speci-fied)</span></span>
- <span data-ttu-id="4bf72-534">intervalos de fila</span><span class="sxs-lookup"><span data-stu-id="4bf72-534">queue timeouts</span></span>

<span data-ttu-id="4bf72-535">Número total de cada fila:</span><span class="sxs-lookup"><span data-stu-id="4bf72-535">Total number for each queue:</span></span>

- <span data-ttu-id="4bf72-536">mensagens enviadas</span><span class="sxs-lookup"><span data-stu-id="4bf72-536">messages sent</span></span>
- <span data-ttu-id="4bf72-537">mensagens recebidas</span><span class="sxs-lookup"><span data-stu-id="4bf72-537">messages received</span></span>
- <span data-ttu-id="4bf72-538">suspensões vazias fila</span><span class="sxs-lookup"><span data-stu-id="4bf72-538">queue empty suspensions</span></span>
- <span data-ttu-id="4bf72-539">suspensões completas fila</span><span class="sxs-lookup"><span data-stu-id="4bf72-539">queue full suspensions</span></span>
- <span data-ttu-id="4bf72-540">retornas de erro completo da fila (suspensão não speci-fied)</span><span class="sxs-lookup"><span data-stu-id="4bf72-540">queue full error returns (suspension not speci-fied)</span></span>
- <span data-ttu-id="4bf72-541">intervalos de fila</span><span class="sxs-lookup"><span data-stu-id="4bf72-541">queue timeouts</span></span>

<span data-ttu-id="4bf72-542">Esta informação está disponível em tempo de execução através dos serviços *tx_queue_performance_info_get* e *tx_queue_performance_system_info_get*.</span><span class="sxs-lookup"><span data-stu-id="4bf72-542">This information is available at run-time through the services *tx_queue_performance_info_get* and *tx_queue_performance_system_info_get*.</span></span> <span data-ttu-id="4bf72-543">As informações sobre o desempenho da fila são úteis para determinar se a aplicação está a comportar-se corretamente.</span><span class="sxs-lookup"><span data-stu-id="4bf72-543">Queue performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="4bf72-544">Também é útil para otimizar a aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-544">It is also useful in optimizing the application.</span></span> <span data-ttu-id="4bf72-545">Por exemplo, um número relativamente elevado de "suspensões completas da fila" sugere que um aumento do tamanho da fila pode ser benéfico.</span><span class="sxs-lookup"><span data-stu-id="4bf72-545">For example, a relatively high number of “queue full suspensions” suggests an increase in the queue size might be beneficial.</span></span>

### <a name="queue-control-block-tx_queue"></a><span data-ttu-id="4bf72-546">TX_QUEUE do Bloco de Controlo de Fila</span><span class="sxs-lookup"><span data-stu-id="4bf72-546">Queue Control Block TX_QUEUE</span></span> 
<span data-ttu-id="4bf72-547">As características de cada fila de mensagens encontram-se no seu bloco de controlo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-547">The characteristics of each message queue are found in its control block.</span></span> <span data-ttu-id="4bf72-548">Contém informações interessantes, como o número de mensagens na fila.</span><span class="sxs-lookup"><span data-stu-id="4bf72-548">It contains interesting information such as the number of messages in the queue.</span></span> <span data-ttu-id="4bf72-549">Esta estrutura é definida no ficheiro ***tx_api.h.***</span><span class="sxs-lookup"><span data-stu-id="4bf72-549">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="4bf72-550">Os blocos de controlo da fila de mensagens também podem ser localizados em qualquer lugar da memória, mas é mais comum fazer do bloco de controlo uma estrutura global definindo-o fora do âmbito de qualquer função.</span><span class="sxs-lookup"><span data-stu-id="4bf72-550">Message queue control blocks can also be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="message-destination-pitfall"></a><span data-ttu-id="4bf72-551">Pitfall do destino da mensagem</span><span class="sxs-lookup"><span data-stu-id="4bf72-551">Message Destination Pitfall</span></span>  
<span data-ttu-id="4bf72-552">Como mencionado anteriormente, as mensagens são copiadas entre a área da fila e as áreas de dados de aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-552">As mentioned previously, messages are copied between the queue area and application data areas.</span></span> <span data-ttu-id="4bf72-553">É importante garantir que o destino de uma mensagem recebida é grande o suficiente para segurar toda a mensagem.</span><span class="sxs-lookup"><span data-stu-id="4bf72-553">It is important to ensure the destination for a received message is large enough to hold the entire message.</span></span> <span data-ttu-id="4bf72-554">Caso contrário, a memória que segue o destino da mensagem será provavelmente corrompida.</span><span class="sxs-lookup"><span data-stu-id="4bf72-554">If not, the memory following the message destination will likely be corrupted.</span></span> 

> [!WARNING]
> <span data-ttu-id="4bf72-555">Isto é especialmente letal quando um destino de mensagem muito pequeno está na pilha - nada como corromper o endereço de retorno de uma função!</span><span class="sxs-lookup"><span data-stu-id="4bf72-555">This is especially lethal when a too-small message destination is on the stack—nothing like corrupting the return address of a function!</span></span>

## <a name="counting-semaphores"></a><span data-ttu-id="4bf72-556">Contagem de Semáforos</span><span class="sxs-lookup"><span data-stu-id="4bf72-556">Counting Semaphores</span></span>

<span data-ttu-id="4bf72-557">A ThreadX SMP fornece semáforos de contagem de 32 bits que variam de valor entre 0 e 4.294.967.295.</span><span class="sxs-lookup"><span data-stu-id="4bf72-557">ThreadX SMP provides 32-bit counting semaphores that range in value between 0 and 4,294,967,295.</span></span> <span data-ttu-id="4bf72-558">Existem duas operações de contagem de semáforos: *tx_semaphore_get* e *tx_semaphore_put.*</span><span class="sxs-lookup"><span data-stu-id="4bf72-558">There are two operations for counting semaphores: *tx_semaphore_get* and *tx_semaphore_put*.</span></span> <span data-ttu-id="4bf72-559">A operação diminui o semáforo por um.</span><span class="sxs-lookup"><span data-stu-id="4bf72-559">The get operation decreases the semaphore by one.</span></span> <span data-ttu-id="4bf72-560">Se o semáforo for 0, a operação de get não é bem sucedida.</span><span class="sxs-lookup"><span data-stu-id="4bf72-560">If the semaphore is 0, the get operation is not successful.</span></span> <span data-ttu-id="4bf72-561">O inverso da operação get é a operação de colocação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-561">The inverse of the get operation is the put operation.</span></span> <span data-ttu-id="4bf72-562">Aumenta o semáforo por um.</span><span class="sxs-lookup"><span data-stu-id="4bf72-562">It increases the semaphore by one.</span></span>

<span data-ttu-id="4bf72-563">Cada semáforo de contagem é um recurso público.</span><span class="sxs-lookup"><span data-stu-id="4bf72-563">Each counting semaphore is a public resource.</span></span> <span data-ttu-id="4bf72-564">A ThreadX SMP não coloca constrangimentos na forma como são utilizados os semáforos de contagem.</span><span class="sxs-lookup"><span data-stu-id="4bf72-564">ThreadX SMP places no constraints on how counting semaphores are used.</span></span>

<span data-ttu-id="4bf72-565">Os semáforos de contagem são normalmente utilizados para *exclusão mútua.*</span><span class="sxs-lookup"><span data-stu-id="4bf72-565">Counting semaphores are typically used for *mutual exclusion*.</span></span> <span data-ttu-id="4bf72-566">No entanto, contar semáforos também pode ser usado como um método para a notificação de eventos.</span><span class="sxs-lookup"><span data-stu-id="4bf72-566">However, counting semaphores can also be used as a method for event notification.</span></span>

### <a name="mutual-exclusion"></a><span data-ttu-id="4bf72-567">Exclusão Mútua</span><span class="sxs-lookup"><span data-stu-id="4bf72-567">Mutual Exclusion</span></span> 
<span data-ttu-id="4bf72-568">A exclusão mútua diz respeito ao controlo do acesso dos fios a determinadas áreas de aplicação (também *designadas por secções críticas* ou *recursos de aplicação).*</span><span class="sxs-lookup"><span data-stu-id="4bf72-568">Mutual exclusion pertains to controlling the access of threads to certain application areas (also called *critical sections* or *application resources*).</span></span> <span data-ttu-id="4bf72-569">Quando utilizado para exclusão mútua, a "contagem atual" de um semáforo representa o número total de fios que são autorizados a aceder.</span><span class="sxs-lookup"><span data-stu-id="4bf72-569">When used for mutual exclusion, the “current count” of a semaphore represents the total number of threads that are allowed access.</span></span> <span data-ttu-id="4bf72-570">Na maioria dos casos, contar semáforos utilizados para exclusão mútua terá um valor inicial de 1, o que significa que apenas um fio pode aceder ao recurso associado de cada vez.</span><span class="sxs-lookup"><span data-stu-id="4bf72-570">In most cases, counting semaphores used for mutual exclusion will have an initial value of 1, meaning that only one thread can access the associated resource at a time.</span></span> <span data-ttu-id="4bf72-571">Contando semáforos que só têm valores de 0 ou 1 são vulgarmente *chamados de semáforos binários.*</span><span class="sxs-lookup"><span data-stu-id="4bf72-571">Counting semaphores that only have values of 0 or 1 are commonly called *binary semaphores*.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="4bf72-572">Se estiver a ser utilizado um semáforo binário, o utilizador deve evitar que o mesmo fio efetue uma operação de get num semáforo que já possui.</span><span class="sxs-lookup"><span data-stu-id="4bf72-572">If a binary semaphore is being used, the user must prevent the same thread from performing a get operation on a semaphore it already owns.</span></span> <span data-ttu-id="4bf72-573">Uma segunda sê-lo não seria bem sucedida e poderia causar a suspensão indefinida do fio de chamada e a indisponibilidade permanente do recurso.</span><span class="sxs-lookup"><span data-stu-id="4bf72-573">A second get would be unsuccessful and could cause indefinite suspension of the calling thread and permanent unavailability of the resource.</span></span>

### <a name="event-notification"></a><span data-ttu-id="4bf72-574">Notificação de eventos</span><span class="sxs-lookup"><span data-stu-id="4bf72-574">Event Notification</span></span> 
<span data-ttu-id="4bf72-575">É igualmente possível utilizar os semáforos de contagem como notificação de eventos, de forma produtora-consumidor.</span><span class="sxs-lookup"><span data-stu-id="4bf72-575">It is also possible to use counting semaphores as event notification, in a producer-consumer fashion.</span></span> <span data-ttu-id="4bf72-576">O consumidor tenta obter o semáforo de contagem enquanto o produtor aumenta o semáforo sempre que algo está disponível.</span><span class="sxs-lookup"><span data-stu-id="4bf72-576">The consumer attempts to get the counting semaphore while the producer increases the semaphore whenever something is available.</span></span> <span data-ttu-id="4bf72-577">Estes semáforos geralmente têm um valor inicial de 0 e não aumentarão até que o produtor tenha algo pronto para o consumidor.</span><span class="sxs-lookup"><span data-stu-id="4bf72-577">Such semaphores usually have an initial value of 0 and will not increase until the producer has something ready for the consumer.</span></span> <span data-ttu-id="4bf72-578">Os semáforos utilizados para notificação de eventos também podem beneficiar da utilização da chamada de serviço *tx_semaphore_ceiling_put.*</span><span class="sxs-lookup"><span data-stu-id="4bf72-578">Semaphores used for event notification may also benefit from use of the *tx_semaphore_ceiling_put* service call.</span></span> <span data-ttu-id="4bf72-579">Este serviço garante que a contagem de semáforos nunca exceda o valor fornecido na chamada.</span><span class="sxs-lookup"><span data-stu-id="4bf72-579">This service ensures that the semaphore count never exceeds the value supplied in the call.</span></span>

### <a name="creating-counting-semaphores"></a><span data-ttu-id="4bf72-580">Criação de Semáforos Contando</span><span class="sxs-lookup"><span data-stu-id="4bf72-580">Creating Counting Semaphores</span></span> 
<span data-ttu-id="4bf72-581">Os semáforos de contagem são criados durante a inicialização ou durante o tempo de funcionamento por fios de aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-581">Counting semaphores are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="4bf72-582">A contagem inicial do semáforo é especificada durante a criação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-582">The initial count of the semaphore is specified during creation.</span></span> <span data-ttu-id="4bf72-583">Não há limite para o número de semáforos de contagem num pedido.</span><span class="sxs-lookup"><span data-stu-id="4bf72-583">There is no limit on the number of counting semaphores in an application.</span></span> 

### <a name="thread-suspension"></a><span data-ttu-id="4bf72-584">Suspensão do fio</span><span class="sxs-lookup"><span data-stu-id="4bf72-584">Thread Suspension</span></span>  
<span data-ttu-id="4bf72-585">Os fios de aplicação podem suspender enquanto tentam executar uma operação de get num semáforo com uma contagem atual de 0.</span><span class="sxs-lookup"><span data-stu-id="4bf72-585">Application threads can suspend while attempting to perform a get operation on a semaphore with a current count of 0.</span></span> 

<span data-ttu-id="4bf72-586">Após a operação de colocação, a operação de get do fio suspenso é executada e o fio é retomado.</span><span class="sxs-lookup"><span data-stu-id="4bf72-586">After a put operation is performed, the suspended thread’s get operation is performed and the thread is resumed.</span></span> <span data-ttu-id="4bf72-587">Se várias linhas forem suspensas no mesmo semáforo de contagem, são retomadas na mesma ordem em que foram suspensas (FIFO).</span><span class="sxs-lookup"><span data-stu-id="4bf72-587">If multiple threads are suspended on the same counting semaphore, they are resumed in the same order they were suspended (FIFO).</span></span>

<span data-ttu-id="4bf72-588">No entanto, o reinício prioritário também é possível se a aplicação ligar ***tx_semaphore_prioritize*** antes da chamada de semáforo que levanta a suspensão do fio.</span><span class="sxs-lookup"><span data-stu-id="4bf72-588">However, priority resumption is also possible if the application calls ***tx_semaphore_prioritize*** prior to the semaphore put call that lifts thread suspension.</span></span> <span data-ttu-id="4bf72-589">O semáforo prioriza o serviço coloca o fio de prioridade mais elevado na parte da frente da lista de suspensão, deixando todos os outros fios suspensos na mesma ordem FIFO.</span><span class="sxs-lookup"><span data-stu-id="4bf72-589">The semaphore prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="semaphore-put-notification"></a><span data-ttu-id="4bf72-590">Aviso de colocação de semáforos</span><span class="sxs-lookup"><span data-stu-id="4bf72-590">Semaphore Put Notification</span></span> 
<span data-ttu-id="4bf72-591">Algumas aplicações podem achar vantajoso ser notificado sempre que um semáforo é colocado.</span><span class="sxs-lookup"><span data-stu-id="4bf72-591">Some applications may find it advantageous to be notified whenever a semaphore is put.</span></span> <span data-ttu-id="4bf72-592">A ThreadX SMP fornece esta capacidade através do serviço *tx_semaphore_put_notify.*</span><span class="sxs-lookup"><span data-stu-id="4bf72-592">ThreadX SMP provides this ability through the *tx_semaphore_put_notify* service.</span></span> <span data-ttu-id="4bf72-593">Este serviço regista a função de notificação de pedido fornecida com o semáforo especificado.</span><span class="sxs-lookup"><span data-stu-id="4bf72-593">This service registers the supplied application notification function with the specified semaphore.</span></span> <span data-ttu-id="4bf72-594">A ThreadX SMP irá posteriormente invocar esta função de notificação de aplicação sempre que o semáforo for colocado.</span><span class="sxs-lookup"><span data-stu-id="4bf72-594">ThreadX SMP will subsequently invoke this application notification function whenever the semaphore is put.</span></span> <span data-ttu-id="4bf72-595">O processamento exato dentro da função de notificação de pedido é determinado pelo pedido; no entanto, consiste tipicamente em retomar o fio adequado para o processamento do novo evento de semáforo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-595">The exact processing within the application notification function is determined by the application; however, it typically consists of resuming the appropriate thread for processing the new semaphore put event.</span></span>

### <a name="semaphore-eventchaining"></a><span data-ttu-id="4bf72-596">Semaphore Eventchaining™</span><span class="sxs-lookup"><span data-stu-id="4bf72-596">Semaphore Eventchaining™</span></span> 
<span data-ttu-id="4bf72-597">As capacidades de notificação no ThreadX SMP podem ser usadas para acorrentar vários eventos de sincronização em conjunto.</span><span class="sxs-lookup"><span data-stu-id="4bf72-597">The notification capabilities in ThreadX SMP can be used to chain various synchronization events together.</span></span> <span data-ttu-id="4bf72-598">Isto é normalmente útil quando um único fio deve processar vários eventos de sincronização.</span><span class="sxs-lookup"><span data-stu-id="4bf72-598">This is typically useful when a single thread must process multiple synchronization events.</span></span>

<span data-ttu-id="4bf72-599">Por exemplo, em vez de ter fios separados suspensos para uma mensagem de fila, bandeiras de eventos e um semáforo, a aplicação pode registar uma rotina de notificação para cada objeto.</span><span class="sxs-lookup"><span data-stu-id="4bf72-599">For example, instead of having separate threads suspend for a queue message, event flags, and a semaphore, the application can register a notification routine for each object.</span></span> <span data-ttu-id="4bf72-600">Quando invocado, a rotina de notificação de aplicação pode então retomar um único fio, que pode interrogar cada objeto para encontrar e processar o novo evento.</span><span class="sxs-lookup"><span data-stu-id="4bf72-600">When invoked, the application notification routine can then resume a single thread, which can interrogate each object to find and process the new event.</span></span>

<span data-ttu-id="4bf72-601">Em geral, *acorrentamento de eventos* resulta em menos fios, menos sobrecargas e menores requisitos de RAM.</span><span class="sxs-lookup"><span data-stu-id="4bf72-601">In general, *event-chaining* results in fewer threads, less overhead, and smaller RAM requirements.</span></span> <span data-ttu-id="4bf72-602">Também fornece um mecanismo altamente flexível para lidar com os requisitos de sincronização de sistemas mais complexos.</span><span class="sxs-lookup"><span data-stu-id="4bf72-602">It also provides a highly flexible mechanism to handle synchronization requirements of more complex systems.</span></span>

### <a name="run-time-semaphore-performance-information"></a><span data-ttu-id="4bf72-603">Informações de desempenho do semáforo em tempo de execução</span><span class="sxs-lookup"><span data-stu-id="4bf72-603">Run-time Semaphore Performance Information</span></span> 
<span data-ttu-id="4bf72-604">A ThreadX SMP fornece informações opcionais de desempenho de semáforos em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="4bf72-604">ThreadX SMP provides optional run-time semaphore performance information.</span></span> <span data-ttu-id="4bf72-605">Se a biblioteca e aplicação ThreadX SMP for construída com ***TX_SEMAPHORE_ENABLE_PERFORMANCE_INFO*** definida, a ThreadX SMP acumula as seguintes informações.</span><span class="sxs-lookup"><span data-stu-id="4bf72-605">If the ThreadX SMP library and application is built with ***TX_SEMAPHORE_ENABLE_PERFORMANCE_INFO*** defined, ThreadX SMP accumulates the following information.</span></span> 

<span data-ttu-id="4bf72-606">Número total do sistema global:</span><span class="sxs-lookup"><span data-stu-id="4bf72-606">Total number for the overall system:</span></span>

- <span data-ttu-id="4bf72-607">semáforo coloca</span><span class="sxs-lookup"><span data-stu-id="4bf72-607">semaphore puts</span></span>
- <span data-ttu-id="4bf72-608">semáforo fica</span><span class="sxs-lookup"><span data-stu-id="4bf72-608">semaphore gets</span></span>
- <span data-ttu-id="4bf72-609">semáforo obter suspensões</span><span class="sxs-lookup"><span data-stu-id="4bf72-609">semaphore get suspensions</span></span>
- <span data-ttu-id="4bf72-610">semáforo obter intervalos de tempo</span><span class="sxs-lookup"><span data-stu-id="4bf72-610">semaphore get timeouts</span></span>

<span data-ttu-id="4bf72-611">Número total de cada semáforo:</span><span class="sxs-lookup"><span data-stu-id="4bf72-611">Total number for each semaphore:</span></span>

- <span data-ttu-id="4bf72-612">semáforo coloca</span><span class="sxs-lookup"><span data-stu-id="4bf72-612">semaphore puts</span></span>
- <span data-ttu-id="4bf72-613">semáforo fica</span><span class="sxs-lookup"><span data-stu-id="4bf72-613">semaphore gets</span></span>
- <span data-ttu-id="4bf72-614">semáforo obter suspensões</span><span class="sxs-lookup"><span data-stu-id="4bf72-614">semaphore get suspensions</span></span>
- <span data-ttu-id="4bf72-615">semáforo obter intervalos de tempo</span><span class="sxs-lookup"><span data-stu-id="4bf72-615">semaphore get timeouts</span></span>

<span data-ttu-id="4bf72-616">Esta informação está disponível em tempo de execução através dos serviços *tx_semaphore_performance_info_get* e *tx_semaphore_performance_system_info_get*.</span><span class="sxs-lookup"><span data-stu-id="4bf72-616">This information is available at run-time through the services *tx_semaphore_performance_info_get* and *tx_semaphore_performance_system_info_get*.</span></span> <span data-ttu-id="4bf72-617">As informações sobre o desempenho do semáforo são úteis para determinar se a aplicação se está a comportar corretamente.</span><span class="sxs-lookup"><span data-stu-id="4bf72-617">Semaphore performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="4bf72-618">Também é útil para otimizar a aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-618">It is also useful in optimizing the application.</span></span> <span data-ttu-id="4bf72-619">Por exemplo, um número relativamente elevado de "intervalos de tempo semaphore get" pode sugerir que outros fios estão a reter recursos demasiado longos.</span><span class="sxs-lookup"><span data-stu-id="4bf72-619">For example, a relatively high number of “semaphore get timeouts” might suggest that other threads are holding resources too long.</span></span>

### <a name="semaphore-control-block-tx_semaphore"></a><span data-ttu-id="4bf72-620">TX_SEMAPHORE do Bloco de Controlo de Semáforos</span><span class="sxs-lookup"><span data-stu-id="4bf72-620">Semaphore Control Block TX_SEMAPHORE</span></span> 
<span data-ttu-id="4bf72-621">As características de cada semáforo de contagem encontram-se no seu bloco de controlo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-621">The characteristics of each counting semaphore are found in its control block.</span></span> <span data-ttu-id="4bf72-622">Contém informações como a contagem atual de semáforos.</span><span class="sxs-lookup"><span data-stu-id="4bf72-622">It contains information such as the current semaphore count.</span></span> <span data-ttu-id="4bf72-623">Esta estrutura é definida no ficheiro ***tx_api.h.***</span><span class="sxs-lookup"><span data-stu-id="4bf72-623">This structure is defined in the ***tx_api.h*** file.</span></span> 

<span data-ttu-id="4bf72-624">Os blocos de controlo de semáforos podem ser localizados em qualquer lugar da memória, mas é mais comum fazer do bloco de controlo uma estrutura global definindo-o fora do âmbito de qualquer função.</span><span class="sxs-lookup"><span data-stu-id="4bf72-624">Semaphore control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span> 

### <a name="deadly-embrace"></a><span data-ttu-id="4bf72-625">Abraço Mortal</span><span class="sxs-lookup"><span data-stu-id="4bf72-625">Deadly Embrace</span></span> 
<span data-ttu-id="4bf72-626">Uma das armadilhas mais interessantes e perigosas associadas aos semáforos usados para a exclusão mútua é o *abraço mortal.*</span><span class="sxs-lookup"><span data-stu-id="4bf72-626">One of the most interesting and dangerous pitfalls associated with semaphores used for mutual exclusion is the *deadly embrace*.</span></span> <span data-ttu-id="4bf72-627">Um abraço mortal, ou *impasse,* é uma condição em que dois ou mais fios são suspensos indefinidamente enquanto tentam obter semáforos já pertencentes uns aos outros.</span><span class="sxs-lookup"><span data-stu-id="4bf72-627">A deadly embrace, or *deadlock*, is a condition in which two or more threads are suspended indefinitely while attempting to get semaphores already owned by each other.</span></span>

<span data-ttu-id="4bf72-628">Esta condição é melhor ilustrada por um dois fios, dois exemplos de semáforo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-628">This condition is best illustrated by a two thread, two semaphore example.</span></span> <span data-ttu-id="4bf72-629">Suponha que o primeiro fio é dono do primeiro semáforo e o segundo fio é dono do segundo semáforo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-629">Suppose the first thread owns the first semaphore and the second thread owns the second semaphore.</span></span> <span data-ttu-id="4bf72-630">Se o primeiro fio tentar obter o segundo semáforo e, ao mesmo tempo, o segundo fio tentar obter o primeiro semáforo, ambos os fios entram numa condição de impasse.</span><span class="sxs-lookup"><span data-stu-id="4bf72-630">If the first thread attempts to get the second semaphore and at the same time the second thread attempts to get the first semaphore, both threads enter a deadlock condition.</span></span> <span data-ttu-id="4bf72-631">Além disso, se estes fios permanecerem suspensos para sempre, os seus recursos associados também estão bloqueados para sempre.</span><span class="sxs-lookup"><span data-stu-id="4bf72-631">In addition, if these threads stay suspended forever, their associated resources are locked-out forever as well.</span></span> <span data-ttu-id="4bf72-632">A figura 7 na página 78 ilustra este exemplo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-632">Figure 7 on page 78 illustrates this example.</span></span>

![Abraço Mortal](media/image10.png)

<span data-ttu-id="4bf72-634">**FIGURA 7. Exemplo de fios suspensos**</span><span class="sxs-lookup"><span data-stu-id="4bf72-634">**FIGURE 7. Example of Suspended Threads**</span></span>

<span data-ttu-id="4bf72-635">Para sistemas em tempo real, os abraços mortais podem ser evitados colocando certas restrições sobre como os fios obtêm semáforos.</span><span class="sxs-lookup"><span data-stu-id="4bf72-635">For real-time systems, deadly embraces can be prevented by placing certain restrictions on how threads obtain semaphores.</span></span> <span data-ttu-id="4bf72-636">Os fios só podem ter um semáforo de cada vez.</span><span class="sxs-lookup"><span data-stu-id="4bf72-636">Threads can only have one semaphore at a time.</span></span> <span data-ttu-id="4bf72-637">Alternativamente, os fios podem possuir vários semáforos se os recolherem na mesma ordem.</span><span class="sxs-lookup"><span data-stu-id="4bf72-637">Alternatively, threads can own multiple semaphores if they gather them in the same order.</span></span> <span data-ttu-id="4bf72-638">No exemplo anterior, se o primeiro e o segundo fio obtiverem o primeiro e o segundo semáforo em ordem, o abraço mortal é evitado.</span><span class="sxs-lookup"><span data-stu-id="4bf72-638">In the previous example, if the first and second thread obtain the first and second semaphore in order, the deadly embrace is prevented.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="4bf72-639">Também é possível utilizar o tempo de suspensão associado à operação get para recuperar de um abraço mortal.</span><span class="sxs-lookup"><span data-stu-id="4bf72-639">It is also possible to use the suspension time-out associated with the get operation to recover from a deadly embrace.</span></span>

### <a name="priority-inversion"></a><span data-ttu-id="4bf72-640">Inversão prioritária</span><span class="sxs-lookup"><span data-stu-id="4bf72-640">Priority Inversion</span></span> 
<span data-ttu-id="4bf72-641">Outra armadilha associada aos semáforos de exclusão mútua é a inversão prioritária.</span><span class="sxs-lookup"><span data-stu-id="4bf72-641">Another pitfall associated with mutual exclusion semaphores is priority inversion.</span></span> <span data-ttu-id="4bf72-642">Este tópico é discutido mais plenamente em "Thread Priority Pitfalls" na página 64.</span><span class="sxs-lookup"><span data-stu-id="4bf72-642">This topic is discussed more fully in “Thread Priority Pitfalls” on page 64.</span></span>

<span data-ttu-id="4bf72-643">O problema básico resulta de uma situação em que um fio de menor prioridade tem um semáforo de que um fio de prioridade mais elevado necessita.</span><span class="sxs-lookup"><span data-stu-id="4bf72-643">The basic problem results from a situation in which a lower-priority thread has a semaphore that a higher priority thread needs.</span></span> <span data-ttu-id="4bf72-644">Isto por si só é normal.</span><span class="sxs-lookup"><span data-stu-id="4bf72-644">This in itself is normal.</span></span> <span data-ttu-id="4bf72-645">No entanto, os fios com prioridades entre eles podem fazer com que a inversão prioritária dure um tempo não desdeterminístico.</span><span class="sxs-lookup"><span data-stu-id="4bf72-645">However, threads with priorities in between them may cause the priority inversion to last a nondeterministic amount of time.</span></span> <span data-ttu-id="4bf72-646">Isto pode ser tratado através de uma seleção cuidadosa das prioridades do fio, utilizando o limiar de pré-edição, e aumentando temporariamente a prioridade do fio que detém o recurso para o do fio de alta prioridade.</span><span class="sxs-lookup"><span data-stu-id="4bf72-646">This can be handled through careful selection of thread priorities, using preemption-threshold, and temporarily raising the priority of the thread that owns the resource to that of the high priority thread.</span></span>

## <a name="mutexes"></a><span data-ttu-id="4bf72-647">Mutaxos</span><span class="sxs-lookup"><span data-stu-id="4bf72-647">Mutexes</span></span>

<span data-ttu-id="4bf72-648">Além dos semáforos, a ThreadX SMP também fornece um objeto mutex.</span><span class="sxs-lookup"><span data-stu-id="4bf72-648">In addition to semaphores, ThreadX SMP also provides a mutex object.</span></span> <span data-ttu-id="4bf72-649">Um mutex é basicamente um semáforo binário, o que significa que só um fio pode possuir um mutex de cada vez.</span><span class="sxs-lookup"><span data-stu-id="4bf72-649">A mutex is basically a binary semaphore, which means that only one thread can own a mutex at a time.</span></span> <span data-ttu-id="4bf72-650">Além disso, o mesmo fio pode realizar uma operação mutex bem sucedida num mutex propriedade várias vezes, 4.294.967.295 para ser exato.</span><span class="sxs-lookup"><span data-stu-id="4bf72-650">In addition, the same thread may perform a successful mutex get operation on an owned mutex multiple times, 4,294,967,295 to be exact.</span></span> <span data-ttu-id="4bf72-651">Existem duas operações no objeto mutex: ***tx_mutex_get** _ e _*_tx_mutex_put_\*\*.</span><span class="sxs-lookup"><span data-stu-id="4bf72-651">There are two operations on the mutex object: ***tx_mutex_get** _ and _*_tx_mutex_put_\*\*.</span></span> <span data-ttu-id="4bf72-652">A operação get obtém um mutex não pertencente a outro fio, enquanto a operação de colocação liberta um mutex previamente obtido.</span><span class="sxs-lookup"><span data-stu-id="4bf72-652">The get operation obtains a mutex not owned by another thread, while the put operation releases a previously obtained mutex.</span></span> <span data-ttu-id="4bf72-653">Para que um fio liberte um mutex, o número de operações de colocação deve ser igual ao número de operações anteriores.</span><span class="sxs-lookup"><span data-stu-id="4bf72-653">For a thread to release a mutex, the number of put operations must equal the number of prior get operations.</span></span>

<span data-ttu-id="4bf72-654">Cada mutex é um recurso público.</span><span class="sxs-lookup"><span data-stu-id="4bf72-654">Each mutex is a public resource.</span></span> <span data-ttu-id="4bf72-655">A ThreadX SMP não coloca constrangimentos na forma como os mutaxos são utilizados.</span><span class="sxs-lookup"><span data-stu-id="4bf72-655">ThreadX SMP places no constraints on how mutexes are used.</span></span>

<span data-ttu-id="4bf72-656">Os mutantes ThreadX são utilizados exclusivamente para *exclusão mútua.*</span><span class="sxs-lookup"><span data-stu-id="4bf72-656">ThreadX mutexes are used solely for *mutual exclusion*.</span></span> <span data-ttu-id="4bf72-657">Ao contrário dos semáforos de contagem, os mutantes não têm uso como método para a notificação do evento.</span><span class="sxs-lookup"><span data-stu-id="4bf72-657">Unlike counting semaphores, mutexes have no use as a method for event notification.</span></span>

### <a name="mutex-mutual-exclusion"></a><span data-ttu-id="4bf72-658">Exclusão Mútua Mutex</span><span class="sxs-lookup"><span data-stu-id="4bf72-658">Mutex Mutual Exclusion</span></span> 
<span data-ttu-id="4bf72-659">À semelhança da discussão na secção de semáforos de contagem, a exclusão mútua diz respeito ao controlo do acesso dos fios a determinadas áreas de aplicação (também *designadas por secções críticas* ou *recursos de aplicação).*</span><span class="sxs-lookup"><span data-stu-id="4bf72-659">Similar to the discussion in the counting semaphore section, mutual exclusion pertains to controlling the access of threads to certain application areas (also called *critical sections* or *application resources*).</span></span> <span data-ttu-id="4bf72-660">Quando disponível, um mutex ThreadX SMP terá uma contagem de propriedade de 0.</span><span class="sxs-lookup"><span data-stu-id="4bf72-660">When available, a ThreadX SMP mutex will have an ownership count of 0.</span></span> <span data-ttu-id="4bf72-661">Após o mutex ser obtido por um fio, a contagem de propriedade é incrementada uma vez para cada operação de obtenção bem sucedida realizada no mutex e decrementeda para cada operação de colocação bem sucedida.</span><span class="sxs-lookup"><span data-stu-id="4bf72-661">After the mutex is obtained by a thread, the ownership count is incremented once for every successful get operation performed on the mutex and decremented for every successful put operation.</span></span>

### <a name="creating-mutexes"></a><span data-ttu-id="4bf72-662">Criar Mutaxos</span><span class="sxs-lookup"><span data-stu-id="4bf72-662">Creating Mutexes</span></span> 
<span data-ttu-id="4bf72-663">Os mutantes ThreadX SMP são criados durante a inicialização ou durante o tempo de funcionamento por fios de aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-663">ThreadX SMP mutexes are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="4bf72-664">A condição inicial de um mutex está sempre "disponível".</span><span class="sxs-lookup"><span data-stu-id="4bf72-664">The initial condition of a mutex is always “available.”</span></span> <span data-ttu-id="4bf72-665">Um mutex também pode ser criado com *herança prioritária* selecionada.</span><span class="sxs-lookup"><span data-stu-id="4bf72-665">A mutex may also be created with *priority inheritance* selected.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="4bf72-666">Suspensão do fio</span><span class="sxs-lookup"><span data-stu-id="4bf72-666">Thread Suspension</span></span> 
<span data-ttu-id="4bf72-667">Os fios de aplicação podem suspender enquanto tentam executar uma operação de get num mutex já propriedade de outro fio.</span><span class="sxs-lookup"><span data-stu-id="4bf72-667">Application threads can suspend while attempting to perform a get operation on a mutex already owned by another thread.</span></span>

<span data-ttu-id="4bf72-668">Após o mesmo número de operações de colocação serem realizadas pelo fio próprio, a operação de get do fio suspenso é realizada, dando-lhe a propriedade do mutex, e o fio é retomado.</span><span class="sxs-lookup"><span data-stu-id="4bf72-668">After the same number of put operations are performed by the owning thread, the suspended thread’s get operation is performed, giving it ownership of the mutex, and the thread is resumed.</span></span> <span data-ttu-id="4bf72-669">Se várias linhas forem suspensas no mesmo mutex, são retomadas na mesma ordem em que foram suspensas (FIFO).</span><span class="sxs-lookup"><span data-stu-id="4bf72-669">If multiple threads are suspended on the same mutex, they are resumed in the same order they were suspended (FIFO).</span></span>

<span data-ttu-id="4bf72-670">No entanto, o reinício prioritário é feito automaticamente se a herança de prioridade mutex foi selecionada durante a criação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-670">However, priority resumption is done automatically if the mutex priority inheritance was selected during creation.</span></span> <span data-ttu-id="4bf72-671">O reinício prioritário também é possível se a aplicação ligar ***tx_mutex_prioritize*** antes da chamada de colocação mutex que levanta a suspensão do fio.</span><span class="sxs-lookup"><span data-stu-id="4bf72-671">Priority resumption is also possible if the application calls ***tx_mutex_prioritize*** prior to the mutex put call that lifts thread suspension.</span></span> <span data-ttu-id="4bf72-672">O serviço de prioridades mutais coloca o fio de prioridade mais elevado na parte da frente da lista de suspensão, deixando todos os outros fios suspensos na mesma ordem FIFO.</span><span class="sxs-lookup"><span data-stu-id="4bf72-672">The mutex prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="run-time-mutex-performance-information"></a><span data-ttu-id="4bf72-673">Informações de desempenho de Mutex em tempo de execução</span><span class="sxs-lookup"><span data-stu-id="4bf72-673">Run-time Mutex Performance Information</span></span> 
<span data-ttu-id="4bf72-674">A ThreadX SMP fornece informações opcionais de desempenho de mutex em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="4bf72-674">ThreadX SMP provides optional run-time mutex performance information.</span></span> <span data-ttu-id="4bf72-675">Se a biblioteca e aplicação ThreadX SMP for construída com ***TX_MUTEX_ENABLE_PERFORMANCE_INFO*** definida, a ThreadX SMP acumula as seguintes informações.</span><span class="sxs-lookup"><span data-stu-id="4bf72-675">If the ThreadX SMP library and application is built with ***TX_MUTEX_ENABLE_PERFORMANCE_INFO*** defined, ThreadX SMP accumulates the following information.</span></span>

<span data-ttu-id="4bf72-676">Número total do sistema global:</span><span class="sxs-lookup"><span data-stu-id="4bf72-676">Total number for the overall system:</span></span>

- <span data-ttu-id="4bf72-677">mutex coloca</span><span class="sxs-lookup"><span data-stu-id="4bf72-677">mutex puts</span></span>
- <span data-ttu-id="4bf72-678">mutex recebe</span><span class="sxs-lookup"><span data-stu-id="4bf72-678">mutex gets</span></span>
- <span data-ttu-id="4bf72-679">mutex obter suspensões</span><span class="sxs-lookup"><span data-stu-id="4bf72-679">mutex get suspensions</span></span>
- <span data-ttu-id="4bf72-680">mutex obter intervalos de tempo</span><span class="sxs-lookup"><span data-stu-id="4bf72-680">mutex get timeouts</span></span>
- <span data-ttu-id="4bf72-681">inversões de prioridade mutex</span><span class="sxs-lookup"><span data-stu-id="4bf72-681">mutex priority inversions</span></span>
- <span data-ttu-id="4bf72-682">heranças de prioridade mutex</span><span class="sxs-lookup"><span data-stu-id="4bf72-682">mutex priority inheritances</span></span>

<span data-ttu-id="4bf72-683">Número total de cada mutex:</span><span class="sxs-lookup"><span data-stu-id="4bf72-683">Total number for each mutex:</span></span>

- <span data-ttu-id="4bf72-684">mutex coloca</span><span class="sxs-lookup"><span data-stu-id="4bf72-684">mutex puts</span></span>
- <span data-ttu-id="4bf72-685">mutex recebe</span><span class="sxs-lookup"><span data-stu-id="4bf72-685">mutex gets</span></span>
- <span data-ttu-id="4bf72-686">mutex obter suspensões</span><span class="sxs-lookup"><span data-stu-id="4bf72-686">mutex get suspensions</span></span>
- <span data-ttu-id="4bf72-687">mutex obter intervalos de tempo</span><span class="sxs-lookup"><span data-stu-id="4bf72-687">mutex get timeouts</span></span>
- <span data-ttu-id="4bf72-688">inversões de prioridade mutex</span><span class="sxs-lookup"><span data-stu-id="4bf72-688">mutex priority inversions</span></span>
- <span data-ttu-id="4bf72-689">heranças de prioridade mutex</span><span class="sxs-lookup"><span data-stu-id="4bf72-689">mutex priority inheritances</span></span>

<span data-ttu-id="4bf72-690">Esta informação está disponível em tempo de execução através dos serviços *tx_mutex_performance_info_get* e *tx_mutex_performance_system_info_get*.</span><span class="sxs-lookup"><span data-stu-id="4bf72-690">This information is available at run-time through the services *tx_mutex_performance_info_get* and *tx_mutex_performance_system_info_get*.</span></span> <span data-ttu-id="4bf72-691">As informações de desempenho da Mutex são úteis para determinar se a aplicação está a comportar-se corretamente.</span><span class="sxs-lookup"><span data-stu-id="4bf72-691">Mutex performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="4bf72-692">Também é útil para otimizar a aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-692">It is also useful in optimizing the application.</span></span> <span data-ttu-id="4bf72-693">Por exemplo, um número relativamente elevado de "intervalos de tempo" de "mutex get timeouts" pode sugerir que outros fios estão a reter recursos demasiado longos.</span><span class="sxs-lookup"><span data-stu-id="4bf72-693">For example, a relatively high number of “mutex get timeouts” might suggest that other threads are holding resources too long.</span></span>

### <a name="mutex-control-block-tx_mutex"></a><span data-ttu-id="4bf72-694">TX_MUTEX do Bloco de Controlo de Mutaxos</span><span class="sxs-lookup"><span data-stu-id="4bf72-694">Mutex Control Block TX_MUTEX</span></span> 
<span data-ttu-id="4bf72-695">As características de cada mutex encontram-se no seu bloco de controlo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-695">The characteristics of each mutex are found in its control block.</span></span> <span data-ttu-id="4bf72-696">Contém informações como a atual contagem de propriedade de mutantes, juntamente com o ponteiro do fio que detém o mutex.</span><span class="sxs-lookup"><span data-stu-id="4bf72-696">It contains information such as the current mutex ownership count along with the pointer of the thread that owns the mutex.</span></span> <span data-ttu-id="4bf72-697">Esta estrutura é definida no ficheiro ***tx_api.h.***</span><span class="sxs-lookup"><span data-stu-id="4bf72-697">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="4bf72-698">Os blocos de controlo mutex podem ser localizados em qualquer lugar da memória, mas é mais comum fazer do bloco de controlo uma estrutura global definindo-o fora do âmbito de qualquer função.</span><span class="sxs-lookup"><span data-stu-id="4bf72-698">Mutex control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="deadly-embrace"></a><span data-ttu-id="4bf72-699">Abraço Mortal</span><span class="sxs-lookup"><span data-stu-id="4bf72-699">Deadly Embrace</span></span>  
<span data-ttu-id="4bf72-700">Uma das armadilhas mais interessantes e perigosas associadas à propriedade de mutantes é o *abraço mortal.*</span><span class="sxs-lookup"><span data-stu-id="4bf72-700">One of the most interesting and dangerous pitfalls associated with mutex ownership is the *deadly embrace*.</span></span> <span data-ttu-id="4bf72-701">Um abraço mortal, ou *impasse,* é uma condição em que dois ou mais fios são suspensos indefinidamente enquanto tentam obter um mutex já pertencente aos outros fios.</span><span class="sxs-lookup"><span data-stu-id="4bf72-701">A deadly embrace, or *deadlock*, is a condition where two or more threads are suspended indefinitely while attempting to get a mutex already owned by the other threads.</span></span> <span data-ttu-id="4bf72-702">A discussão do *abraço mortal* e dos seus remédios encontrados na página 77 é completamente válida para o objeto mutex também.</span><span class="sxs-lookup"><span data-stu-id="4bf72-702">The discussion of *deadly embrace* and its remedies found on page 77 is completely valid for the mutex object as well.</span></span>

### <a name="priority-inversion"></a><span data-ttu-id="4bf72-703">Inversão prioritária</span><span class="sxs-lookup"><span data-stu-id="4bf72-703">Priority Inversion</span></span> 
<span data-ttu-id="4bf72-704">Como mencionado anteriormente, uma grande armadilha associada à exclusão mútua é a inversão prioritária.</span><span class="sxs-lookup"><span data-stu-id="4bf72-704">As mentioned previously, a major pitfall associated with mutual exclusion is priority inversion.</span></span> <span data-ttu-id="4bf72-705">Este tópico é discutido mais plenamente em "Thread Priority Pitfalls" na página 64.</span><span class="sxs-lookup"><span data-stu-id="4bf72-705">This topic is discussed more fully in “Thread Priority Pitfalls” on page 64.</span></span> 

<span data-ttu-id="4bf72-706">O problema básico resulta de uma situação em que um fio de prioridade inferior tem um semáforo de que um fio de prioridade mais elevado necessita.</span><span class="sxs-lookup"><span data-stu-id="4bf72-706">The basic problem results from a situation in which a lower priority thread has a semaphore that a higher priority thread needs.</span></span> <span data-ttu-id="4bf72-707">Isto por si só é normal.</span><span class="sxs-lookup"><span data-stu-id="4bf72-707">This in itself is normal.</span></span> <span data-ttu-id="4bf72-708">No entanto, os fios com prioridades entre eles podem fazer com que a inversão prioritária dure um tempo não desdeterminístico.</span><span class="sxs-lookup"><span data-stu-id="4bf72-708">However, threads with priorities in between them may cause the priority inversion to last a nondeterministic amount of time.</span></span> <span data-ttu-id="4bf72-709">Ao contrário dos semáforos discutidos anteriormente, o objeto mutex ThreadX SMP tem *uma herança prioritária* opcional.</span><span class="sxs-lookup"><span data-stu-id="4bf72-709">Unlike semaphores discussed previously, the ThreadX SMP mutex object has optional *priority inheritance*.</span></span> <span data-ttu-id="4bf72-710">A ideia básica por trás da herança prioritária é que um fio de prioridade inferior tem a sua prioridade levantada temporariamente para a prioridade de um fio de alta prioridade que quer o mesmo mutex propriedade do fio de menor prioridade.</span><span class="sxs-lookup"><span data-stu-id="4bf72-710">The basic idea behind priority inheritance is that a lower priority thread has its priority raised temporarily to the priority of a high priority thread that wants the same mutex owned by the lower priority thread.</span></span> <span data-ttu-id="4bf72-711">Quando o fio de menor prioridade liberta o mutex, a sua prioridade original é então restaurada e o fio de prioridade mais elevado é dado a propriedade do mutex.</span><span class="sxs-lookup"><span data-stu-id="4bf72-711">When the lower priority thread releases the mutex, its original priority is then restored and the higher priority thread is given ownership of the mutex.</span></span> <span data-ttu-id="4bf72-712">Esta característica elimina a inversão de prioridade não determinística, limitando a quantidade de inversão ao tempo que o fio de prioridade inferior detém o mutex.</span><span class="sxs-lookup"><span data-stu-id="4bf72-712">This feature eliminates nondeterministic priority inversion by bounding the amount of inversion to the time the lower priority thread holds the mutex.</span></span> <span data-ttu-id="4bf72-713">É claro que as técnicas discutidas no início deste capítulo para lidar com a inversão de prioridade não determinística também são válidas com mutantes.</span><span class="sxs-lookup"><span data-stu-id="4bf72-713">Of course, the techniques discussed earlier in this chapter to handle nondeterministic priority inversion are also valid with mutexes as well.</span></span>

## <a name="event-flags"></a><span data-ttu-id="4bf72-714">Bandeiras do evento</span><span class="sxs-lookup"><span data-stu-id="4bf72-714">Event Flags</span></span>

<span data-ttu-id="4bf72-715">As bandeiras do evento fornecem uma ferramenta poderosa para a sincronização dos fios.</span><span class="sxs-lookup"><span data-stu-id="4bf72-715">Event flags provide a powerful tool for thread synchronization.</span></span> <span data-ttu-id="4bf72-716">Cada bandeira do evento é representada por um único pedaço.</span><span class="sxs-lookup"><span data-stu-id="4bf72-716">Each event flag is represented by a single bit.</span></span> <span data-ttu-id="4bf72-717">As bandeiras do evento estão dispostas em grupos de 32.</span><span class="sxs-lookup"><span data-stu-id="4bf72-717">Event flags are arranged in groups of 32.</span></span>

<span data-ttu-id="4bf72-718">Os fios podem operar em todas as 32 bandeiras de eventos de um grupo ao mesmo tempo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-718">Threads can operate on all 32 event flags in a group at the same time.</span></span> <span data-ttu-id="4bf72-719">Os eventos são definidos por *tx_event_flags_set* e são recuperados por *tx_event_flags_get.*</span><span class="sxs-lookup"><span data-stu-id="4bf72-719">Events are set by *tx_event_flags_set* and are retrieved by *tx_event_flags_get*.</span></span>

<span data-ttu-id="4bf72-720">A colocação de bandeiras de eventos é feita com uma operação lógica E/OR entre as bandeiras do evento atual e as novas bandeiras do evento.</span><span class="sxs-lookup"><span data-stu-id="4bf72-720">Setting event flags is done with a logical AND/OR operation between the current event flags and the new event flags.</span></span> <span data-ttu-id="4bf72-721">O tipo de operação lógica (ou um E ou OR) é especificado na *chamada tx_event_flags_set.*</span><span class="sxs-lookup"><span data-stu-id="4bf72-721">The type of logical operation (either an AND or OR) is specified in the *tx_event_flags_set* call.</span></span>

<span data-ttu-id="4bf72-722">Existem opções lógicas semelhantes para a recuperação de bandeiras de eventos.</span><span class="sxs-lookup"><span data-stu-id="4bf72-722">There are similar logical options for retrieval of event flags.</span></span> <span data-ttu-id="4bf72-723">Um pedido de obter pode especificar que todas as bandeiras de eventos especificadas são necessárias (um E lógico).</span><span class="sxs-lookup"><span data-stu-id="4bf72-723">A get request can specify that all specified event flags are required (a logical AND).</span></span> <span data-ttu-id="4bf72-724">Em alternativa, um pedido de obter pode especificar que qualquer uma das bandeiras de eventos especificadas satisfará o pedido (um OR lógico).</span><span class="sxs-lookup"><span data-stu-id="4bf72-724">Alternatively, a get request can specify that any of the specified event flags will satisfy the request (a logical OR).</span></span> <span data-ttu-id="4bf72-725">O tipo de operação lógica associada à recuperação de bandeiras de eventos é especificado na *chamada tx_event_flags_get.*</span><span class="sxs-lookup"><span data-stu-id="4bf72-725">The type of logical operation associated with event flags retrieval is specified in the *tx_event_flags_get* call.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="4bf72-726">As bandeiras de eventos que satisfaçam um pedido de ovação são consumidas, ou seja, a zero, se **TX_OR_CLEAR** ou **TX_AND_CLEAR** forem especificados pelo pedido.</span><span class="sxs-lookup"><span data-stu-id="4bf72-726">Event flags that satisfy a get request are consumed, i.e., set to zero, if **TX_OR_CLEAR** or **TX_AND_CLEAR** are specified by the request.</span></span>

<span data-ttu-id="4bf72-727">Cada grupo de bandeiras de eventos é um recurso público.</span><span class="sxs-lookup"><span data-stu-id="4bf72-727">Each event flags group is a public resource.</span></span> <span data-ttu-id="4bf72-728">A ThreadX SMP não coloca constrangimentos na forma como são utilizados os grupos de bandeiras de eventos.</span><span class="sxs-lookup"><span data-stu-id="4bf72-728">ThreadX SMP places no constraints on how event flags groups are used.</span></span>

### <a name="creating-event-flags-groups"></a><span data-ttu-id="4bf72-729">Criação de grupos de bandeiras de eventos</span><span class="sxs-lookup"><span data-stu-id="4bf72-729">Creating Event Flags Groups</span></span>
<span data-ttu-id="4bf72-730">Os grupos de bandeiras de eventos são criados durante a inicialização ou durante o tempo de execução por fios de aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-730">Event flags groups are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="4bf72-731">No momento da sua criação, todas as bandeiras do grupo estão definidas para zero.</span><span class="sxs-lookup"><span data-stu-id="4bf72-731">At the time of their creation, all event flags in the group are set to zero.</span></span> <span data-ttu-id="4bf72-732">Não há limite para o número de grupos de bandeiras de eventos numa aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-732">There is no limit on the number of event flags groups in an application.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="4bf72-733">Suspensão do fio</span><span class="sxs-lookup"><span data-stu-id="4bf72-733">Thread Suspension</span></span> 
<span data-ttu-id="4bf72-734">Os fios de aplicação podem suspender enquanto tentam obter qualquer combinação lógica de bandeiras de eventos de um grupo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-734">Application threads can suspend while attempting to get any logical combination of event flags from a group.</span></span> <span data-ttu-id="4bf72-735">Depois de uma bandeira de evento ser definida, os pedidos de todos os fios suspensos são revistos.</span><span class="sxs-lookup"><span data-stu-id="4bf72-735">After an event flag is set, the get requests of all suspended threads are reviewed.</span></span> <span data-ttu-id="4bf72-736">Todos os fios que agora têm as bandeiras de eventos necessárias são retomados.</span><span class="sxs-lookup"><span data-stu-id="4bf72-736">All the threads that now have the required event flags are resumed.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="4bf72-737">Todos os fios suspensos de um grupo de bandeiras de eventos são revistos quando as bandeiras do evento são definidas.</span><span class="sxs-lookup"><span data-stu-id="4bf72-737">All suspended threads on an event flags group are reviewed when its event flags are set.</span></span> <span data-ttu-id="4bf72-738">Isto, naturalmente, introduz despesas adicionais.</span><span class="sxs-lookup"><span data-stu-id="4bf72-738">This, of course, introduces additional overhead.</span></span> <span data-ttu-id="4bf72-739">Por conseguinte, é uma boa prática limitar o número de fios que utilizam o mesmo grupo de bandeiras de eventos a um número razoável.</span><span class="sxs-lookup"><span data-stu-id="4bf72-739">Therefore, it is good practice to limit the number of threads using the same event flags group to a reasonable number.</span></span>

### <a name="event-flags-set-notification"></a><span data-ttu-id="4bf72-740">Notificação de conjunto de bandeiras de evento</span><span class="sxs-lookup"><span data-stu-id="4bf72-740">Event Flags Set Notification</span></span> 
<span data-ttu-id="4bf72-741">Algumas aplicações podem achar vantajoso ser notificado sempre que uma bandeira do evento é definida.</span><span class="sxs-lookup"><span data-stu-id="4bf72-741">Some applications may find it advantageous to be notified whenever an event flag is set.</span></span> <span data-ttu-id="4bf72-742">A ThreadX SMP fornece esta capacidade através do serviço *tx_event_flags_set_notify.*</span><span class="sxs-lookup"><span data-stu-id="4bf72-742">ThreadX SMP provides this ability through the *tx_event_flags_set_notify* service.</span></span> <span data-ttu-id="4bf72-743">Este serviço regista a função de notificação de aplicação fornecida com o grupo de bandeiras de eventos especificado.</span><span class="sxs-lookup"><span data-stu-id="4bf72-743">This service registers the supplied application notification function with the specified event flags group.</span></span> <span data-ttu-id="4bf72-744">A ThreadX SMP irá posteriormente invocar esta função de notificação de aplicação sempre que for definida uma bandeira de evento no grupo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-744">ThreadX SMP will subsequently invoke this application notification function whenever an event flag in the group is set.</span></span> <span data-ttu-id="4bf72-745">O processamento exato dentro da função de notificação de aplicação é determinado pela aplicação, mas normalmente consiste em retomar o fio adequado para o processamento da nova bandeira do evento.</span><span class="sxs-lookup"><span data-stu-id="4bf72-745">The exact processing within the application notification function is determined by the application, but it typically consists of resuming the appropriate thread for processing the new event flag.</span></span> 

### <a name="event-flags-event-chaining"></a><span data-ttu-id="4bf72-746">Acorrentamento de eventos bandeiras de eventos™</span><span class="sxs-lookup"><span data-stu-id="4bf72-746">Event Flags Event-chaining™</span></span> 
<span data-ttu-id="4bf72-747">As capacidades de notificação no ThreadX SMP podem ser usadas para "acorrentar" vários eventos de sincronização em conjunto.</span><span class="sxs-lookup"><span data-stu-id="4bf72-747">The notification capabilities in ThreadX SMP can be used to “chain” various synchronization events together.</span></span> <span data-ttu-id="4bf72-748">Isto é normalmente útil quando um único fio deve processar vários eventos de sincronização.</span><span class="sxs-lookup"><span data-stu-id="4bf72-748">This is typically useful when a single thread must process multiple synchronization events.</span></span> 

<span data-ttu-id="4bf72-749">Por exemplo, em vez de ter fios separados suspensos para uma mensagem de fila, bandeiras de eventos e um semáforo, a aplicação pode registar uma rotina de notificação para cada objeto.</span><span class="sxs-lookup"><span data-stu-id="4bf72-749">For example, instead of having separate threads suspend for a queue message, event flags, and a semaphore, the application can register a notification routine for each object.</span></span> <span data-ttu-id="4bf72-750">Quando invocado, a rotina de notificação de aplicação pode então retomar um único fio, que pode interrogar cada objeto para encontrar e processar o novo evento.</span><span class="sxs-lookup"><span data-stu-id="4bf72-750">When invoked, the application notification routine can then resume a single thread, which can interrogate each object to find and process the new event.</span></span> 

<span data-ttu-id="4bf72-751">Em geral, *acorrentamento de eventos* resulta em menos fios, menos sobrecargas e menores requisitos de RAM.</span><span class="sxs-lookup"><span data-stu-id="4bf72-751">In general, *event-chaining* results in fewer threads, less overhead, and smaller RAM requirements.</span></span> <span data-ttu-id="4bf72-752">Também fornece um mecanismo altamente flexível para lidar com os requisitos de sincronização de sistemas mais complexos.</span><span class="sxs-lookup"><span data-stu-id="4bf72-752">It also provides a highly flexible mechanism to handle synchronization requirements of more complex systems.</span></span> 

### <a name="run-time-event-flags-performance-information"></a><span data-ttu-id="4bf72-753">Informações de desempenho de bandeiras de eventos de tempo de execução</span><span class="sxs-lookup"><span data-stu-id="4bf72-753">Run-time Event Flags Performance Information</span></span> 
<span data-ttu-id="4bf72-754">A ThreadX SMP fornece informações opcionais de desempenho de bandeiras de eventos de execução.</span><span class="sxs-lookup"><span data-stu-id="4bf72-754">ThreadX SMP provides optional run-time event flags performance information.</span></span> <span data-ttu-id="4bf72-755">Se a biblioteca e aplicação ThreadX SMP for construída com ***TX_EVENT_FLAGS_ENABLE_PERFORMANCE_INFO*** definida, a ThreadX SMP acumula as seguintes informações.</span><span class="sxs-lookup"><span data-stu-id="4bf72-755">If the ThreadX SMP library and application is built with ***TX_EVENT_FLAGS_ENABLE_PERFORMANCE_INFO*** defined, ThreadX SMP accumulates the following information.</span></span>

<span data-ttu-id="4bf72-756">Número total do sistema global:</span><span class="sxs-lookup"><span data-stu-id="4bf72-756">Total number for the overall system:</span></span>

- <span data-ttu-id="4bf72-757">conjuntos de bandeiras de evento</span><span class="sxs-lookup"><span data-stu-id="4bf72-757">event flags sets</span></span>
- <span data-ttu-id="4bf72-758">bandeiras de evento recebe</span><span class="sxs-lookup"><span data-stu-id="4bf72-758">event flags gets</span></span>
- <span data-ttu-id="4bf72-759">bandeiras de evento obter suspensões</span><span class="sxs-lookup"><span data-stu-id="4bf72-759">event flags get suspensions</span></span>
- <span data-ttu-id="4bf72-760">bandeiras de evento obter intervalos</span><span class="sxs-lookup"><span data-stu-id="4bf72-760">event flags get timeouts</span></span>

<span data-ttu-id="4bf72-761">Número total de cada grupo de bandeiras de evento:</span><span class="sxs-lookup"><span data-stu-id="4bf72-761">Total number for each event flags group:</span></span>

- <span data-ttu-id="4bf72-762">conjuntos de bandeiras de evento</span><span class="sxs-lookup"><span data-stu-id="4bf72-762">event flags sets</span></span>
- <span data-ttu-id="4bf72-763">bandeiras de evento recebe</span><span class="sxs-lookup"><span data-stu-id="4bf72-763">event flags gets</span></span>
- <span data-ttu-id="4bf72-764">bandeiras de evento obter suspensões</span><span class="sxs-lookup"><span data-stu-id="4bf72-764">event flags get suspensions</span></span>
- <span data-ttu-id="4bf72-765">bandeiras de evento obter intervalos</span><span class="sxs-lookup"><span data-stu-id="4bf72-765">event flags get timeouts</span></span>

<span data-ttu-id="4bf72-766">Esta informação está disponível em tempo de execução através dos serviços *tx_event_flags_performance_info_get* e *tx_event_flags_performance_system_info_get*.</span><span class="sxs-lookup"><span data-stu-id="4bf72-766">This information is available at run-time through the services *tx_event_flags_performance_info_get* and *tx_event_flags_performance_system_info_get*.</span></span> <span data-ttu-id="4bf72-767">As informações sobre o desempenho das Bandeiras de Eventos são úteis para determinar se a aplicação se está a comportar corretamente.</span><span class="sxs-lookup"><span data-stu-id="4bf72-767">Event Flags performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="4bf72-768">Também é útil para otimizar a aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-768">It is also useful in optimizing the application.</span></span> <span data-ttu-id="4bf72-769">Por exemplo, um número relativamente elevado de intervalos no serviço *tx_event_flags_get* pode sugerir que o tempo de suspensão das bandeiras do evento é demasiado curto.</span><span class="sxs-lookup"><span data-stu-id="4bf72-769">For example, a relatively high number of timeouts on the *tx_event_flags_get* service might suggest that the event flags suspension timeout is too short.</span></span>

### <a name="event-flags-group-control-block-tx_event_flags_group"></a><span data-ttu-id="4bf72-770">Bloco de controlo de grupo de bandeiras de eventos TX_EVENT_FLAGS_GROUP</span><span class="sxs-lookup"><span data-stu-id="4bf72-770">Event Flags Group Control Block TX_EVENT_FLAGS_GROUP</span></span>
<span data-ttu-id="4bf72-771">As características de cada grupo de bandeiras de eventos encontram-se no seu bloco de controlo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-771">The characteristics of each event flags group are found in its control block.</span></span> <span data-ttu-id="4bf72-772">Contém informações como as definições atuais das bandeiras do evento e o número de fios suspensos para eventos.</span><span class="sxs-lookup"><span data-stu-id="4bf72-772">It contains information such as the current event flags settings and the number of threads suspended for events.</span></span> <span data-ttu-id="4bf72-773">Esta estrutura é definida no ficheiro ***tx_api.h.***</span><span class="sxs-lookup"><span data-stu-id="4bf72-773">This structure is defined in the ***tx_api.h*** file.</span></span> 

<span data-ttu-id="4bf72-774">Os blocos de controlo de grupo de eventos podem ser localizados em qualquer lugar da memória, mas é mais comum fazer do bloco de controlo uma estrutura global definindo-o fora do âmbito de qualquer função.</span><span class="sxs-lookup"><span data-stu-id="4bf72-774">Event group control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

## <a name="memory-block-pools"></a><span data-ttu-id="4bf72-775">Piscinas de Blocos de Memória</span><span class="sxs-lookup"><span data-stu-id="4bf72-775">Memory Block Pools</span></span>  

<span data-ttu-id="4bf72-776">Alocar a memória de forma rápida e determinística é sempre um desafio nas aplicações em tempo real.</span><span class="sxs-lookup"><span data-stu-id="4bf72-776">Allocating memory in a fast and deterministic manner is always a challenge in real-time applications.</span></span> <span data-ttu-id="4bf72-777">Com isto em mente, a ThreadX SMP fornece a capacidade de criar e gerir várias piscinas de blocos de memória de tamanho fixo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-777">With this in mind, ThreadX SMP provides the ability to create and manage multiple pools of fixed-size memory blocks.</span></span>

<span data-ttu-id="4bf72-778">Como as piscinas de blocos de memória consistem em blocos de tamanho fixo, nunca há problemas de fragmentação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-778">Because memory block pools consist of fixed-size blocks, there are never any fragmentation problems.</span></span> <span data-ttu-id="4bf72-779">Claro, a fragmentação causa comportamentos que não são inerentemente indeterminados.</span><span class="sxs-lookup"><span data-stu-id="4bf72-779">Of course, fragmentation causes behavior that is inherently nondeterministic.</span></span> <span data-ttu-id="4bf72-780">Além disso, o tempo necessário para alocar e libertar um bloco de memória de tamanho fixo é comparável ao da simples manipulação da lista ligada.</span><span class="sxs-lookup"><span data-stu-id="4bf72-780">In addition, the time required to allocate and free a fixed-size memory block is comparable to that of simple linked-list manipulation.</span></span> <span data-ttu-id="4bf72-781">Além disso, a atribuição de blocos de memória e a deslocação são feitas no cabeça da lista disponível.</span><span class="sxs-lookup"><span data-stu-id="4bf72-781">Furthermore, memory block allocation and de-allocation is done at the head of the available list.</span></span> <span data-ttu-id="4bf72-782">Isto fornece o processamento de listas mais rápido possível e pode ajudar a manter o bloco de memória real em cache.</span><span class="sxs-lookup"><span data-stu-id="4bf72-782">This provides the fastest possible linked list processing and might help keep the actual memory block in cache.</span></span>

<span data-ttu-id="4bf72-783">A falta de flexibilidade é a principal desvantagem dos pools de memória de tamanho fixo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-783">Lack of flexibility is the main drawback of fixed-size memory pools.</span></span> <span data-ttu-id="4bf72-784">O tamanho do bloco de uma piscina deve ser grande o suficiente para suportar os piores requisitos de memória dos seus utilizadores.</span><span class="sxs-lookup"><span data-stu-id="4bf72-784">The block size of a pool must be large enough to handle the worst case memory requirements of its users.</span></span> <span data-ttu-id="4bf72-785">Claro que a memória pode ser desperdiçada se muitos pedidos de memória de tamanhos diferentes forem feitos para a mesma piscina.</span><span class="sxs-lookup"><span data-stu-id="4bf72-785">Of course, memory may be wasted if many different size memory requests are made to the same pool.</span></span> <span data-ttu-id="4bf72-786">Uma solução possível é fazer vários conjuntos de blocos de memória diferentes que contêm diferentes blocos de memória de tamanho.</span><span class="sxs-lookup"><span data-stu-id="4bf72-786">A possible solution is to make several different memory block pools that contain different sized memory blocks.</span></span>

<span data-ttu-id="4bf72-787">Cada conjunto de blocos de memória é um recurso público.</span><span class="sxs-lookup"><span data-stu-id="4bf72-787">Each memory block pool is a public resource.</span></span> <span data-ttu-id="4bf72-788">A ThreadX SMP não coloca constrangimentos na forma como as piscinas são utilizadas.</span><span class="sxs-lookup"><span data-stu-id="4bf72-788">ThreadX SMP places no constraints on how pools are used.</span></span>

### <a name="creating-memory-block-pools"></a><span data-ttu-id="4bf72-789">Criação de piscinas de blocos de memória</span><span class="sxs-lookup"><span data-stu-id="4bf72-789">Creating Memory Block Pools</span></span>  
<span data-ttu-id="4bf72-790">Os pools de blocos de memória são criados durante a inicialização ou durante o tempo de funcionamento por fios de aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-790">Memory block pools are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="4bf72-791">Não há limite para o número de piscinas de blocos de memória numa aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-791">There is no limit on the number of memory block pools in an application.</span></span>

### <a name="memory-block-size"></a><span data-ttu-id="4bf72-792">Tamanho do bloco de memória</span><span class="sxs-lookup"><span data-stu-id="4bf72-792">Memory Block Size</span></span>  
<span data-ttu-id="4bf72-793">Como mencionado anteriormente, as piscinas de blocos de memória contêm uma série de blocos de tamanho fixo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-793">As mentioned earlier, memory block pools contain a number of fixed-size blocks.</span></span> <span data-ttu-id="4bf72-794">O tamanho do bloco, em bytes, é especificado durante a criação da piscina.</span><span class="sxs-lookup"><span data-stu-id="4bf72-794">The block size, in bytes, is specified during creation of the pool.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="4bf72-795">O ThreadX SMP adiciona uma pequena quantidade de sobrecarga, do tamanho de um ponteiro C, a cada bloco de memória na piscina.</span><span class="sxs-lookup"><span data-stu-id="4bf72-795">ThreadX SMP adds a small amount of overhead— the size of a C pointer—to each memory block in the pool.</span></span> <span data-ttu-id="4bf72-796">Além disso, o ThreadX SMP poderá ter de remar o tamanho do bloco para manter o início de cada bloco de memória no alinhamento adequado.</span><span class="sxs-lookup"><span data-stu-id="4bf72-796">In addition, ThreadX SMP might have to pad the block size to keep the beginning of each memory block on proper alignment.</span></span>

### <a name="pool-capacity"></a><span data-ttu-id="4bf72-797">Capacidade da Piscina</span><span class="sxs-lookup"><span data-stu-id="4bf72-797">Pool Capacity</span></span> 
<span data-ttu-id="4bf72-798">O número de blocos de memória numa piscina é uma função do tamanho do bloco e do número total de bytes na área de memória fornecida durante a criação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-798">The number of memory blocks in a pool is a function of the block size and the total number of bytes in the memory area supplied during creation.</span></span> <span data-ttu-id="4bf72-799">A capacidade de uma piscina é calculada dividindo o tamanho do bloco (incluindo o acolchoado e os bytes de ponteiro) no número total de bytes na área de memória fornecida.</span><span class="sxs-lookup"><span data-stu-id="4bf72-799">The capacity of a pool is calculated by dividing the block size (including padding and the pointer overhead bytes) into the total number of bytes in the supplied memory area.</span></span>

### <a name="pools-memory-area"></a><span data-ttu-id="4bf72-800">Área de Memória da Piscina</span><span class="sxs-lookup"><span data-stu-id="4bf72-800">Pool’s Memory Area</span></span> 
<span data-ttu-id="4bf72-801">Como mencionado anteriormente, a área de memória para o bloco pool é especificada durante a criação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-801">As mentioned before, the memory area for the block pool is specified during creation.</span></span> <span data-ttu-id="4bf72-802">Tal como outras áreas de memória no ThreadX SMP, pode ser localizado em qualquer lugar do espaço de endereço do alvo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-802">Like other memory areas in ThreadX SMP, it can be located anywhere in the target’s address space.</span></span>

<span data-ttu-id="4bf72-803">Esta é uma característica importante devido à flexibilidade considerável que proporciona.</span><span class="sxs-lookup"><span data-stu-id="4bf72-803">This is an important feature because of the considerable flexibility it provides.</span></span> <span data-ttu-id="4bf72-804">Por exemplo, suponha que um produto de comunicação tem uma área de memória de alta velocidade para e/S.</span><span class="sxs-lookup"><span data-stu-id="4bf72-804">For example, suppose that a communication product has a highspeed memory area for I/O.</span></span> <span data-ttu-id="4bf72-805">Esta área de memória é facilmente gerida transformando-a num bloco de memória ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="4bf72-805">This memory area is easily managed by making it into a ThreadX SMP memory block pool.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="4bf72-806">Suspensão do fio</span><span class="sxs-lookup"><span data-stu-id="4bf72-806">Thread Suspension</span></span> 
<span data-ttu-id="4bf72-807">Os fios de aplicação podem suspender enquanto esperam por um bloco de memória de uma piscina vazia.</span><span class="sxs-lookup"><span data-stu-id="4bf72-807">Application threads can suspend while waiting for a memory block from an empty pool.</span></span> <span data-ttu-id="4bf72-808">Quando um bloco é devolvido à piscina, o fio suspenso é dado este bloco e o fio é retomado.</span><span class="sxs-lookup"><span data-stu-id="4bf72-808">When a block is returned to the pool, the suspended thread is given this block and the thread is resumed.</span></span>

<span data-ttu-id="4bf72-809">Se várias linhas forem suspensas na mesma piscina de blocos de memória, são retomadas na ordem em que foram suspensas (FIFO).</span><span class="sxs-lookup"><span data-stu-id="4bf72-809">If multiple threads are suspended on the same memory block pool, they are resumed in the order they were suspended (FIFO).</span></span>

<span data-ttu-id="4bf72-810">No entanto, o reinício de prioridade também é possível se a aplicação ligar ***tx_block_pool_prioritize*** antes da chamada de desbloqueio do bloco que levanta a suspensão do fio.</span><span class="sxs-lookup"><span data-stu-id="4bf72-810">However, priority resumption is also possible if the application calls ***tx_block_pool_prioritize*** prior to the block release call that lifts thread suspension.</span></span> <span data-ttu-id="4bf72-811">O bloco de prioridades de serviço coloca o fio de prioridade mais alto na parte da frente da lista de suspensão, deixando todos os outros fios suspensos na mesma ordem FIFO.</span><span class="sxs-lookup"><span data-stu-id="4bf72-811">The block pool prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="run-time-block-pool-performance-information"></a><span data-ttu-id="4bf72-812">Informações de desempenho do bloco de tempo de execução</span><span class="sxs-lookup"><span data-stu-id="4bf72-812">Run-time Block Pool Performance Information</span></span>  
<span data-ttu-id="4bf72-813">A ThreadX SMP fornece informações opcionais de desempenho do bloco de tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="4bf72-813">ThreadX SMP provides optional run-time block pool performance information.</span></span> <span data-ttu-id="4bf72-814">Se a biblioteca e aplicação ThreadX SMP for construída com ***TX_BLOCK_POOL_ENABLE_PERFORMANCE_INFO*** definida, a ThreadX SMP acumula as seguintes informações.</span><span class="sxs-lookup"><span data-stu-id="4bf72-814">If the ThreadX SMP library and application is built with ***TX_BLOCK_POOL_ENABLE_PERFORMANCE_INFO*** defined, ThreadX SMP accumulates the following information.</span></span>

<span data-ttu-id="4bf72-815">Número total do sistema global:</span><span class="sxs-lookup"><span data-stu-id="4bf72-815">Total number for the overall system:</span></span>

- <span data-ttu-id="4bf72-816">blocos atribuídos</span><span class="sxs-lookup"><span data-stu-id="4bf72-816">blocks allocated</span></span>
- <span data-ttu-id="4bf72-817">blocos libertados</span><span class="sxs-lookup"><span data-stu-id="4bf72-817">blocks released</span></span>
- <span data-ttu-id="4bf72-818">suspensões de atribuição</span><span class="sxs-lookup"><span data-stu-id="4bf72-818">allocation suspensions</span></span>
- <span data-ttu-id="4bf72-819">intervalos de atribuição</span><span class="sxs-lookup"><span data-stu-id="4bf72-819">allocation timeouts</span></span>

<span data-ttu-id="4bf72-820">Número total para cada bloco:</span><span class="sxs-lookup"><span data-stu-id="4bf72-820">Total number for each block pool:</span></span>

- <span data-ttu-id="4bf72-821">blocos atribuídos</span><span class="sxs-lookup"><span data-stu-id="4bf72-821">blocks allocated</span></span>
- <span data-ttu-id="4bf72-822">blocos libertados</span><span class="sxs-lookup"><span data-stu-id="4bf72-822">blocks released</span></span>
- <span data-ttu-id="4bf72-823">suspensões de atribuição</span><span class="sxs-lookup"><span data-stu-id="4bf72-823">allocation suspensions</span></span>
- <span data-ttu-id="4bf72-824">intervalos de atribuição</span><span class="sxs-lookup"><span data-stu-id="4bf72-824">allocation timeouts</span></span>

<span data-ttu-id="4bf72-825">Esta informação está disponível em tempo de execução através dos serviços *tx_block_pool_performance_info_get* e *tx_block_pool_performance_system_info_get*.</span><span class="sxs-lookup"><span data-stu-id="4bf72-825">This information is available at run-time through the services *tx_block_pool_performance_info_get* and *tx_block_pool_performance_system_info_get*.</span></span> <span data-ttu-id="4bf72-826">As informações de desempenho do pool de blocos são úteis para determinar se a aplicação está a comportar-se corretamente.</span><span class="sxs-lookup"><span data-stu-id="4bf72-826">Block pool performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="4bf72-827">Também é útil para otimizar a aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-827">It is also useful in optimizing the application.</span></span> <span data-ttu-id="4bf72-828">Por exemplo, um número relativamente elevado de "suspensões de atribuição" pode sugerir que o bloco de piscina é demasiado pequeno.</span><span class="sxs-lookup"><span data-stu-id="4bf72-828">For example, a relatively high number of “allocation suspensions” might suggest that the block pool is too small.</span></span>

### <a name="memory-block-pool-control-block-tx_block_pool"></a><span data-ttu-id="4bf72-829">Bloco de controlo de piscina de bloco de memória TX_BLOCK_POOL</span><span class="sxs-lookup"><span data-stu-id="4bf72-829">Memory Block Pool Control Block TX_BLOCK_POOL</span></span>  
<span data-ttu-id="4bf72-830">As características de cada conjunto de blocos de memória encontram-se no seu bloco de controlo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-830">The characteristics of each memory block pool are found in its control block.</span></span> <span data-ttu-id="4bf72-831">Contém informações como o número de blocos de memória disponíveis e o tamanho do bloco de memória.</span><span class="sxs-lookup"><span data-stu-id="4bf72-831">It contains information such as the number of memory blocks available and the memory pool block size.</span></span> <span data-ttu-id="4bf72-832">Esta estrutura é definida no ficheiro ***tx_api.h.***</span><span class="sxs-lookup"><span data-stu-id="4bf72-832">This structure is defined in the ***tx_api.h*** file.</span></span> 

<span data-ttu-id="4bf72-833">Os blocos de controlo da piscina também podem ser localizados em qualquer lugar da memória, mas é mais comum fazer do bloco de controlo uma estrutura global definindo-o fora do âmbito de qualquer função.</span><span class="sxs-lookup"><span data-stu-id="4bf72-833">Pool control blocks can also be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span> 

### <a name="overwriting-memory-blocks"></a><span data-ttu-id="4bf72-834">Sobreescrita de blocos de memória</span><span class="sxs-lookup"><span data-stu-id="4bf72-834">Overwriting Memory Blocks</span></span>  
<span data-ttu-id="4bf72-835">É importante garantir que o utilizador de um bloco de memória atribuído não escreva fora dos seus limites.</span><span class="sxs-lookup"><span data-stu-id="4bf72-835">It is important to ensure that the user of an allocated memory block does not write outside its boundaries.</span></span> <span data-ttu-id="4bf72-836">Se isso acontecer, a corrupção ocorre numa área de memória adjacente (geralmente subsequente).</span><span class="sxs-lookup"><span data-stu-id="4bf72-836">If this happens, corruption occurs in an adjacent (usually subsequent) memory area.</span></span> <span data-ttu-id="4bf72-837">Os resultados são imprevisíveis e muitas vezes fatais!</span><span class="sxs-lookup"><span data-stu-id="4bf72-837">The results are unpredictable and often fatal!</span></span> 

## <a name="memory-byte-pools"></a><span data-ttu-id="4bf72-838">Piscinas De Memória Byte</span><span class="sxs-lookup"><span data-stu-id="4bf72-838">Memory Byte Pools</span></span>

<span data-ttu-id="4bf72-839">As piscinas de byte de memória ThreadX SMP são semelhantes a uma pilha C padrão.</span><span class="sxs-lookup"><span data-stu-id="4bf72-839">ThreadX SMP memory byte pools are similar to a standard C heap.</span></span> <span data-ttu-id="4bf72-840">Ao contrário da pilha C padrão, é possível ter várias piscinas byte de memória.</span><span class="sxs-lookup"><span data-stu-id="4bf72-840">Unlike the standard C heap, it is possible to have multiple memory byte pools.</span></span> <span data-ttu-id="4bf72-841">Além disso, os fios podem suspender-se numa piscina até que a memória solicitada esteja disponível.</span><span class="sxs-lookup"><span data-stu-id="4bf72-841">In addition, threads can suspend on a pool until the requested memory is available.</span></span>

<span data-ttu-id="4bf72-842">As alocações das piscinas de bytes de memória são semelhantes às chamadas tradicionais *de malloc,* que incluem a quantidade de memória desejada (em bytes).</span><span class="sxs-lookup"><span data-stu-id="4bf72-842">Allocations from memory byte pools are similar to traditional *malloc* calls, which include the amount of memory desired (in bytes).</span></span> <span data-ttu-id="4bf72-843">A memória é alocada da piscina de forma *em primeiro lugar;* ou seja, é utilizado o primeiro bloco de memória livre que satisfaz o pedido.</span><span class="sxs-lookup"><span data-stu-id="4bf72-843">Memory is allocated from the pool in a *first-fit* manner; i.e., the first free memory block that satisfies the request is used.</span></span> <span data-ttu-id="4bf72-844">A memória em excesso deste bloco é convertida num novo bloco e colocada de volta na lista de memórias gratuitas.</span><span class="sxs-lookup"><span data-stu-id="4bf72-844">Excess memory from this block is converted into a new block and placed back in the free memory list.</span></span> <span data-ttu-id="4bf72-845">Este processo chama-se *fragmentação.*</span><span class="sxs-lookup"><span data-stu-id="4bf72-845">This process is called *fragmentation*.</span></span>

<span data-ttu-id="4bf72-846">Os blocos de memória livre adjacentes são *fundidos* durante uma pesquisa subsequente de atribuição de um bloco de memória livre suficientemente grande.</span><span class="sxs-lookup"><span data-stu-id="4bf72-846">Adjacent free memory blocks are *merged* together during a subsequent allocation search for a large enough free memory block.</span></span> <span data-ttu-id="4bf72-847">Este processo *chama-se des-fragmentação.*</span><span class="sxs-lookup"><span data-stu-id="4bf72-847">This process is called *de-fragmentation*.</span></span>

<span data-ttu-id="4bf72-848">Cada piscina de byte de memória é um recurso público.</span><span class="sxs-lookup"><span data-stu-id="4bf72-848">Each memory byte pool is a public resource.</span></span> <span data-ttu-id="4bf72-849">A ThreadX SMP não coloca quais as restrições na forma como as piscinas são utilizadas, exceto que os serviços de byte de memória não podem ser chamados de ISRs.</span><span class="sxs-lookup"><span data-stu-id="4bf72-849">ThreadX SMP places no constraints on how pools are used, except that memory byte services cannot be called from ISRs.</span></span>

### <a name="creating-memory-byte-pools"></a><span data-ttu-id="4bf72-850">Criação de piscinas de byte de memória</span><span class="sxs-lookup"><span data-stu-id="4bf72-850">Creating Memory Byte Pools</span></span> 
<span data-ttu-id="4bf72-851">As piscinas de byte de memória são criadas durante a inicialização ou durante o tempo de funcionamento por fios de aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-851">Memory byte pools are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="4bf72-852">Não há limite para o número de piscinas de byte de memória numa aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-852">There is no limit on the number of memory byte pools in an application.</span></span>  

### <a name="pool-capacity"></a><span data-ttu-id="4bf72-853">Capacidade da Piscina</span><span class="sxs-lookup"><span data-stu-id="4bf72-853">Pool Capacity</span></span> 
<span data-ttu-id="4bf72-854">O número de bytes alocáveis numa piscina de bytes de memória é ligeiramente inferior ao especificado durante a criação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-854">The number of allocatable bytes in a memory byte pool is slightly less than what was specified during creation.</span></span> <span data-ttu-id="4bf72-855">Isto porque a gestão da área da memória livre introduz algumas despesas gerais.</span><span class="sxs-lookup"><span data-stu-id="4bf72-855">This is because management of the free memory area introduces some overhead.</span></span> <span data-ttu-id="4bf72-856">Cada bloco de memória livre na piscina requer o equivalente a dois ponteiros C de sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="4bf72-856">Each free memory block in the pool requires the equivalent of two C pointers of overhead.</span></span> <span data-ttu-id="4bf72-857">Além disso, a piscina é criada com dois blocos, um grande bloco livre e um pequeno bloco permanentemente alocado no final da área de memória.</span><span class="sxs-lookup"><span data-stu-id="4bf72-857">In addition, the pool is created with two blocks, a large free block and a small permanently allocated block at the end of the memory area.</span></span> <span data-ttu-id="4bf72-858">Este bloco atribuído é usado para melhorar o desempenho do algoritmo de atribuição.</span><span class="sxs-lookup"><span data-stu-id="4bf72-858">This allocated block is used to improve performance of the allocation algorithm.</span></span> <span data-ttu-id="4bf72-859">Elimina a necessidade de verificar continuamente o fim da área da piscina durante a fusão.</span><span class="sxs-lookup"><span data-stu-id="4bf72-859">It eliminates the need to continuously check for the end of the pool area during merging.</span></span>  

<span data-ttu-id="4bf72-860">Durante o tempo de funcionação, a quantidade de sobrecarga na piscina normalmente aumenta.</span><span class="sxs-lookup"><span data-stu-id="4bf72-860">During run-time, the amount of overhead in the pool typically increases.</span></span> <span data-ttu-id="4bf72-861">As alocações de um número ímpar de bytes são acolchoadas para garantir o alinhamento adequado do próximo bloco de memória.</span><span class="sxs-lookup"><span data-stu-id="4bf72-861">Allocations of an odd number of bytes are padded to ensure proper alignment of the next memory block.</span></span> <span data-ttu-id="4bf72-862">Além disso, a sobrecarga aumenta à medida que a piscina se torna mais fragmentada.</span><span class="sxs-lookup"><span data-stu-id="4bf72-862">In addition, overhead increases as the pool becomes more fragmented.</span></span>

### <a name="pools-memory-area"></a><span data-ttu-id="4bf72-863">Área de Memória da Piscina</span><span class="sxs-lookup"><span data-stu-id="4bf72-863">Pool’s Memory Area</span></span>  
<span data-ttu-id="4bf72-864">A área de memória para uma piscina de byte de memória é especificada durante a criação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-864">The memory area for a memory byte pool is specified during creation.</span></span> <span data-ttu-id="4bf72-865">Tal como outras áreas de memória no ThreadX SMP, pode ser localizado em qualquer lugar do espaço de endereço do alvo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-865">Like other memory areas in ThreadX SMP, it can be located anywhere in the target’s address space.</span></span> 

<span data-ttu-id="4bf72-866">Esta é uma característica importante devido à flexibilidade considerável que proporciona.</span><span class="sxs-lookup"><span data-stu-id="4bf72-866">This is an important feature because of the considerable flexibility it provides.</span></span> <span data-ttu-id="4bf72-867">Por exemplo, se o hardware-alvo tiver uma área de memória de alta velocidade e uma área de memória de baixa velocidade, o utilizador pode gerir a alocação de memória para ambas as áreas criando uma piscina em cada uma delas.</span><span class="sxs-lookup"><span data-stu-id="4bf72-867">For example, if the target hardware has a high-speed memory area and a low-speed memory area, the user can manage memory allocation for both areas by creating a pool in each of them.</span></span> 

### <a name="thread-suspension"></a><span data-ttu-id="4bf72-868">Suspensão do fio</span><span class="sxs-lookup"><span data-stu-id="4bf72-868">Thread Suspension</span></span>  
<span data-ttu-id="4bf72-869">Os fios de aplicação podem suspender enquanto aguardam bytes de memória de uma piscina.</span><span class="sxs-lookup"><span data-stu-id="4bf72-869">Application threads can suspend while waiting for memory bytes from a pool.</span></span> <span data-ttu-id="4bf72-870">Quando a memória contígua suficiente fica disponível, os fios suspensos recebem a sua memória solicitada e os fios são retomados.</span><span class="sxs-lookup"><span data-stu-id="4bf72-870">When sufficient contiguous memory becomes available, the suspended threads are given their requested memory and the threads are resumed.</span></span> 

<span data-ttu-id="4bf72-871">Se várias linhas forem suspensas na mesma piscina de byte de memória, são-lhes dadas memória (retomada) na ordem em que foram suspensas (FIFO).</span><span class="sxs-lookup"><span data-stu-id="4bf72-871">If multiple threads are suspended on the same memory byte pool, they are given memory (resumed) in the order they were suspended (FIFO).</span></span> 

<span data-ttu-id="4bf72-872">No entanto, o reinício prioritário também é possível se a aplicação ligar ***tx_byte_pool_prioritize*** antes da chamada de lançamento byte que levanta a suspensão do fio.</span><span class="sxs-lookup"><span data-stu-id="4bf72-872">However, priority resumption is also possible if the application calls ***tx_byte_pool_prioritize*** prior to the byte release call that lifts thread suspension.</span></span> <span data-ttu-id="4bf72-873">A piscina byte prioriza o serviço coloca o fio de prioridade mais alto na parte da frente da lista de suspensão, deixando todos os outros fios suspensos na mesma ordem FIFO.</span><span class="sxs-lookup"><span data-stu-id="4bf72-873">The byte pool prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="run-time-byte-pool-performance-information"></a><span data-ttu-id="4bf72-874">Informações de desempenho do byte pool em tempo de execução</span><span class="sxs-lookup"><span data-stu-id="4bf72-874">Run-time Byte Pool Performance Information</span></span>  
<span data-ttu-id="4bf72-875">A ThreadX SMP fornece informações opcionais de desempenho do byte pool.</span><span class="sxs-lookup"><span data-stu-id="4bf72-875">ThreadX SMP provides optional run-time byte pool performance information.</span></span> <span data-ttu-id="4bf72-876">Se a biblioteca e aplicação ThreadX SMP for construída com ***TX_BYTE_POOL_ENABLE_PERFORMANCE_INFO*** definida, a ThreadX SMP acumula as seguintes informações.</span><span class="sxs-lookup"><span data-stu-id="4bf72-876">If the ThreadX SMP library and application is built with ***TX_BYTE_POOL_ENABLE_PERFORMANCE_INFO*** defined, ThreadX SMP accumulates the following information.</span></span>

<span data-ttu-id="4bf72-877">Número total do sistema global:</span><span class="sxs-lookup"><span data-stu-id="4bf72-877">Total number for the overall system:</span></span>

- <span data-ttu-id="4bf72-878">dotações</span><span class="sxs-lookup"><span data-stu-id="4bf72-878">allocations</span></span>
- <span data-ttu-id="4bf72-879">versões</span><span class="sxs-lookup"><span data-stu-id="4bf72-879">releases</span></span>
- <span data-ttu-id="4bf72-880">fragmentos pesquisados</span><span class="sxs-lookup"><span data-stu-id="4bf72-880">fragments searched</span></span>
- <span data-ttu-id="4bf72-881">fragmentos fundidos</span><span class="sxs-lookup"><span data-stu-id="4bf72-881">fragments merged</span></span>
- <span data-ttu-id="4bf72-882">fragmentos criados</span><span class="sxs-lookup"><span data-stu-id="4bf72-882">fragments created</span></span>
- <span data-ttu-id="4bf72-883">suspensões de atribuição</span><span class="sxs-lookup"><span data-stu-id="4bf72-883">allocation suspensions</span></span>
- <span data-ttu-id="4bf72-884">intervalos de atribuição</span><span class="sxs-lookup"><span data-stu-id="4bf72-884">allocation timeouts</span></span>

<span data-ttu-id="4bf72-885">Número total para cada piscina byte:</span><span class="sxs-lookup"><span data-stu-id="4bf72-885">Total number for each byte pool:</span></span>

- <span data-ttu-id="4bf72-886">dotações</span><span class="sxs-lookup"><span data-stu-id="4bf72-886">allocations</span></span>
- <span data-ttu-id="4bf72-887">versões</span><span class="sxs-lookup"><span data-stu-id="4bf72-887">releases</span></span>
- <span data-ttu-id="4bf72-888">fragmentos pesquisados</span><span class="sxs-lookup"><span data-stu-id="4bf72-888">fragments searched</span></span>
- <span data-ttu-id="4bf72-889">fragmentos fundidos</span><span class="sxs-lookup"><span data-stu-id="4bf72-889">fragments merged</span></span>
- <span data-ttu-id="4bf72-890">fragmentos criados</span><span class="sxs-lookup"><span data-stu-id="4bf72-890">fragments created</span></span>
- <span data-ttu-id="4bf72-891">suspensões de atribuição</span><span class="sxs-lookup"><span data-stu-id="4bf72-891">allocation suspensions</span></span>
- <span data-ttu-id="4bf72-892">intervalos de atribuição</span><span class="sxs-lookup"><span data-stu-id="4bf72-892">allocation timeouts</span></span>

<span data-ttu-id="4bf72-893">Esta informação está disponível em tempo de execução através dos serviços *tx_byte_pool_performance_info_get* e *tx_byte_pool_performance_system_info_get*.</span><span class="sxs-lookup"><span data-stu-id="4bf72-893">This information is available at run-time through the services *tx_byte_pool_performance_info_get* and *tx_byte_pool_performance_system_info_get*.</span></span> <span data-ttu-id="4bf72-894">As informações sobre o desempenho da piscina byte são úteis para determinar se a aplicação está a comportar-se corretamente.</span><span class="sxs-lookup"><span data-stu-id="4bf72-894">Byte pool performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="4bf72-895">Também é útil para otimizar a aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-895">It is also useful in optimizing the application.</span></span> <span data-ttu-id="4bf72-896">Por exemplo, um número relativamente elevado de "suspensões de atribuição" pode sugerir que o byte pool é demasiado pequeno.</span><span class="sxs-lookup"><span data-stu-id="4bf72-896">For example, a relatively high number of “allocation suspensions” might suggest that the byte pool is too small.</span></span>

### <a name="memory-byte-pool-control-block-tx_byte_pool"></a><span data-ttu-id="4bf72-897">TX_BYTE_POOL do bloco de controlo de piscinas Byte de memória</span><span class="sxs-lookup"><span data-stu-id="4bf72-897">Memory Byte Pool Control Block TX_BYTE_POOL</span></span>  
<span data-ttu-id="4bf72-898">As características de cada piscina de byte de memória encontram-se no seu bloco de controlo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-898">The characteristics of each memory byte pool are found in its control block.</span></span> <span data-ttu-id="4bf72-899">Contém informações úteis, como o número de bytes disponíveis na piscina.</span><span class="sxs-lookup"><span data-stu-id="4bf72-899">It contains useful information such as the number of available bytes in the pool.</span></span> <span data-ttu-id="4bf72-900">Esta estrutura é definida no ficheiro ***tx_api.h.***</span><span class="sxs-lookup"><span data-stu-id="4bf72-900">This structure is defined in the ***tx_api.h*** file.</span></span> 

<span data-ttu-id="4bf72-901">Os blocos de controlo da piscina também podem ser localizados em qualquer lugar da memória, mas é mais comum fazer do bloco de controlo uma estrutura global definindo-o fora do âmbito de qualquer função.</span><span class="sxs-lookup"><span data-stu-id="4bf72-901">Pool control blocks can also be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span> 

### <a name="nondeterministic-behavior"></a><span data-ttu-id="4bf72-902">Comportamento não determinista</span><span class="sxs-lookup"><span data-stu-id="4bf72-902">Nondeterministic Behavior</span></span> 
<span data-ttu-id="4bf72-903">Embora as piscinas de byte de memória forneçam a alocação de memória mais flexível, também sofrem de um comportamento algo não determinista.</span><span class="sxs-lookup"><span data-stu-id="4bf72-903">Although memory byte pools provide the most flexible memory allocation, they also suffer from somewhat nondeterministic behavior.</span></span> <span data-ttu-id="4bf72-904">Por exemplo, um byte de memória pode ter 2.000 bytes de memória disponíveis, mas pode não ser capaz de satisfazer um pedido de atribuição de 1.000 bytes.</span><span class="sxs-lookup"><span data-stu-id="4bf72-904">For example, a memory byte pool may have 2,000 bytes of memory available but may not be able to satisfy an allocation request of 1,000 bytes.</span></span> <span data-ttu-id="4bf72-905">Isto porque não há garantias sobre quantos bytes gratuitos são contíguos.</span><span class="sxs-lookup"><span data-stu-id="4bf72-905">This is because there are no guarantees on how many of the free bytes are contiguous.</span></span> <span data-ttu-id="4bf72-906">Mesmo que exista um bloco livre de 1.000 bytes, não há garantias sobre quanto tempo pode demorar a encontrar o bloco.</span><span class="sxs-lookup"><span data-stu-id="4bf72-906">Even if a 1,000 byte free block exists, there are no guarantees on how long it might take to find the block.</span></span> <span data-ttu-id="4bf72-907">É completamente possível que todo o pool de memórias tenha de ser pesquisado para encontrar o bloco de 1.000 bytes.</span><span class="sxs-lookup"><span data-stu-id="4bf72-907">It is completely possible that the entire memory pool would need to be searched to find the 1,000 byte block.</span></span> 

> [!IMPORTANT]
> <span data-ttu-id="4bf72-908">Por isso, é geralmente uma boa prática evitar a utilização de serviços de byte de memória em áreas onde é necessário um comportamento determinístico e em tempo real.</span><span class="sxs-lookup"><span data-stu-id="4bf72-908">Because of this, it is generally good practice to avoid using memory byte services in areas where deterministic, real-time behavior is required.</span></span> <span data-ttu-id="4bf72-909">Muitas aplicações pré-alocam a memória necessária durante a inicialização ou configuração do tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="4bf72-909">Many applications pre-allocate their required memory during initialization or run-time configuration.</span></span>

### <a name="overwriting-memory-blocks"></a><span data-ttu-id="4bf72-910">Sobreescrita de blocos de memória</span><span class="sxs-lookup"><span data-stu-id="4bf72-910">Overwriting Memory Blocks</span></span> 
<span data-ttu-id="4bf72-911">É importante garantir que o utilizador da memória atribuída não escreva fora dos seus limites.</span><span class="sxs-lookup"><span data-stu-id="4bf72-911">It is important to ensure that the user of allocated memory does not write outside its boundaries.</span></span> <span data-ttu-id="4bf72-912">Se isso acontecer, a corrupção ocorre numa área de memória adjacente (geralmente subsequente).</span><span class="sxs-lookup"><span data-stu-id="4bf72-912">If this happens, corruption occurs in an adjacent (usually subsequent) memory area.</span></span> <span data-ttu-id="4bf72-913">Os resultados são imprevisíveis e muitas vezes fatais!</span><span class="sxs-lookup"><span data-stu-id="4bf72-913">The results are unpredictable and often fatal!</span></span> 

## <a name="application-timers"></a><span data-ttu-id="4bf72-914">Temporizadores de aplicação</span><span class="sxs-lookup"><span data-stu-id="4bf72-914">Application Timers</span></span>

<span data-ttu-id="4bf72-915">A resposta rápida a eventos externos assíncronos é a função mais importante das aplicações em tempo real e incorporadas.</span><span class="sxs-lookup"><span data-stu-id="4bf72-915">Fast response to asynchronous external events is the most important function of real-time, embedded applications.</span></span> <span data-ttu-id="4bf72-916">No entanto, muitas destas aplicações devem também realizar determinadas atividades em intervalos de tempo pré-determinados.</span><span class="sxs-lookup"><span data-stu-id="4bf72-916">However, many of these applications must also perform certain activities at pre-determined intervals of time.</span></span>

<span data-ttu-id="4bf72-917">Os temporizadores de aplicação ThreadX SMP fornecem aplicações com a capacidade de executar funções de aplicação C em intervalos de tempo específicos.</span><span class="sxs-lookup"><span data-stu-id="4bf72-917">ThreadX SMP application timers provide applications with the ability to execute application C functions at specific intervals of time.</span></span> <span data-ttu-id="4bf72-918">Também é possível que um temporizador de aplicação expire apenas uma vez.</span><span class="sxs-lookup"><span data-stu-id="4bf72-918">It is also possible for an application timer to expire only once.</span></span> <span data-ttu-id="4bf72-919">Este tipo de temporizador é chamado de *temporizador de um só tiro,* enquanto os temporizadores de intervalo repetidos são *chamados temporizadores periódicos*.</span><span class="sxs-lookup"><span data-stu-id="4bf72-919">This type of timer is called a *one-shot timer*, while repeating interval timers are called *periodic timers*.</span></span>

<span data-ttu-id="4bf72-920">Cada temporizador de aplicação é um recurso público.</span><span class="sxs-lookup"><span data-stu-id="4bf72-920">Each application timer is a public resource.</span></span> <span data-ttu-id="4bf72-921">A ThreadX SMP não coloca quais as restrições na forma como os temporizadores de aplicação são utilizados.</span><span class="sxs-lookup"><span data-stu-id="4bf72-921">ThreadX SMP places no constraints on how application timers are used.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="4bf72-922">Os temporizadores de aplicação podem ser excluídos da execução em qualquer núcleo através da API tx_timer_smp_core_exclude.</span><span class="sxs-lookup"><span data-stu-id="4bf72-922">Application timers can be excluded from execution on any core via the tx_timer_smp_core_exclude API.</span></span>

### <a name="timer-intervals"></a><span data-ttu-id="4bf72-923">Intervalos de temporizador</span><span class="sxs-lookup"><span data-stu-id="4bf72-923">Timer Intervals</span></span> 
<span data-ttu-id="4bf72-924">Nos intervalos de tempo ThreadX SMP são medidos por interrupções periódicas do temporizador.</span><span class="sxs-lookup"><span data-stu-id="4bf72-924">In ThreadX SMP time intervals are measured by periodic timer interrupts.</span></span> <span data-ttu-id="4bf72-925">Cada interrupção do temporizador é chamada de *tique-taque do temporizador*.</span><span class="sxs-lookup"><span data-stu-id="4bf72-925">Each timer interrupt is called a timer *tick*.</span></span> <span data-ttu-id="4bf72-926">O tempo real entre os tiques temporizadores é especificado pela aplicação, mas 10ms é a norma para a maioria das implementações.</span><span class="sxs-lookup"><span data-stu-id="4bf72-926">The actual time between timer ticks is specified by the application, but 10ms is the norm for most implementations.</span></span> <span data-ttu-id="4bf72-927">A configuração do temporizador periódico é tipicamente encontrada no ficheiro de montagem ***tx_initialize_low_level.***</span><span class="sxs-lookup"><span data-stu-id="4bf72-927">The periodic timer setup is typically found in the ***tx_initialize_low_level*** assembly file.</span></span>

<span data-ttu-id="4bf72-928">Vale a pena referir que o hardware subjacente deve ter a capacidade de gerar interrupções periódicas para que os temporizadores de aplicação funcionem.</span><span class="sxs-lookup"><span data-stu-id="4bf72-928">It is worth mentioning that the underlying hardware must have the ability to generate periodic interrupts for application timers to function.</span></span> <span data-ttu-id="4bf72-929">Em alguns casos, o processador tem uma capacidade de interrupção periódica incorporada.</span><span class="sxs-lookup"><span data-stu-id="4bf72-929">In some cases, the processor has a built-in periodic interrupt capability.</span></span> <span data-ttu-id="4bf72-930">Se o processador não tiver esta capacidade, a placa do utilizador deve ter um dispositivo periférico que possa gerar interrupções periódicas.</span><span class="sxs-lookup"><span data-stu-id="4bf72-930">If the processor doesn’t have this ability, the user’s board must have a peripheral device that can generate periodic interrupts.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="4bf72-931">ThreadX SMP ainda pode funcionar mesmo sem uma fonte de interrupção periódica.</span><span class="sxs-lookup"><span data-stu-id="4bf72-931">ThreadX SMP can still function even without a periodic interrupt source.</span></span> <span data-ttu-id="4bf72-932">No entanto, todo o processamento relacionado com o temporizador é então desativado.</span><span class="sxs-lookup"><span data-stu-id="4bf72-932">However, all timer-related processing is then disabled.</span></span> <span data-ttu-id="4bf72-933">Isto inclui a suspensão, os tempos de suspensão e os serviços de temporizador.</span><span class="sxs-lookup"><span data-stu-id="4bf72-933">This includes timeslicing, suspension time-outs, and timer services.</span></span>

### <a name="timer-accuracy"></a><span data-ttu-id="4bf72-934">Precisão do temporizador</span><span class="sxs-lookup"><span data-stu-id="4bf72-934">Timer Accuracy</span></span> 
<span data-ttu-id="4bf72-935">As expirações do temporizador são especificadas em termos de carraças.</span><span class="sxs-lookup"><span data-stu-id="4bf72-935">Timer expirations are specified in terms of ticks.</span></span> <span data-ttu-id="4bf72-936">O valor de expiração especificado é diminuído por um em cada tique-taque do temporizador.</span><span class="sxs-lookup"><span data-stu-id="4bf72-936">The specified expiration value is decreased by one on each timer tick.</span></span> <span data-ttu-id="4bf72-937">Como um temporizador de aplicação pode ser ativado pouco antes de uma interrupção do temporizador (ou marcação do temporizador), o tempo de validade real pode ser até um tique mais cedo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-937">Because an application timer could be enabled just prior to a timer interrupt (or timer tick), the actual expiration time could be up to one tick early.</span></span>

<span data-ttu-id="4bf72-938">Se a taxa de marcação do temporizador for de 10ms, os temporizadores de aplicação podem expirar até 10ms mais cedo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-938">If the timer tick rate is 10ms, application timers may expire up to 10ms early.</span></span> <span data-ttu-id="4bf72-939">Isto é mais significativo para temporizadores de 10ms do que 1 segundo temporizadores.</span><span class="sxs-lookup"><span data-stu-id="4bf72-939">This is more significant for 10ms timers than 1 second timers.</span></span> <span data-ttu-id="4bf72-940">É claro que o aumento da frequência de interrupção do temporizador diminui esta margem de erro.</span><span class="sxs-lookup"><span data-stu-id="4bf72-940">Of course, increasing the timer interrupt frequency decreases this margin of error.</span></span>

### <a name="timer-execution"></a><span data-ttu-id="4bf72-941">Execução do Temporizador</span><span class="sxs-lookup"><span data-stu-id="4bf72-941">Timer Execution</span></span> 
<span data-ttu-id="4bf72-942">Os temporizadores de aplicação executam na ordem em que se tornam ativos.</span><span class="sxs-lookup"><span data-stu-id="4bf72-942">Application timers execute in the order they become active.</span></span> <span data-ttu-id="4bf72-943">Por exemplo, se três temporizadores forem criados com o mesmo valor de expiração e ativados, as respetivas funções de expiração são garantidas para executar na ordem em que foram ativados.</span><span class="sxs-lookup"><span data-stu-id="4bf72-943">For example, if three timers are created with the same expiration value and activated, their corresponding expiration functions are guaranteed to execute in the order they were activated.</span></span> 

### <a name="creating-application-timers"></a><span data-ttu-id="4bf72-944">Criação de Temporizadores de Aplicações</span><span class="sxs-lookup"><span data-stu-id="4bf72-944">Creating Application Timers</span></span> 
<span data-ttu-id="4bf72-945">Os temporizadores de aplicação são criados durante a inicialização ou durante o tempo de funcionamento por fios de aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-945">Application timers are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="4bf72-946">Não existe limite para o número de temporizadores de aplicação num pedido.</span><span class="sxs-lookup"><span data-stu-id="4bf72-946">There is no limit on the number of application timers in an application.</span></span> 

### <a name="run-time-application-timer-performance-information"></a><span data-ttu-id="4bf72-947">Informações de desempenho do tempo de execução do tempo de aplicação</span><span class="sxs-lookup"><span data-stu-id="4bf72-947">Run-time Application Timer Performance Information</span></span>  
<span data-ttu-id="4bf72-948">A ThreadX SMP fornece informações opcionais de desempenho do tempo de execução da aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-948">ThreadX SMP provides optional run-time application timer performance information.</span></span> <span data-ttu-id="4bf72-949">Se a biblioteca e aplicação ThreadX SMP forem construídas com ***TX_TIMER_ENABLE_PERFORMANCE_INFO*** definidas, a ThreadX SMP acumula as seguintes informações.</span><span class="sxs-lookup"><span data-stu-id="4bf72-949">If the ThreadX SMP library and application are built with ***TX_TIMER_ENABLE_PERFORMANCE_INFO*** defined, ThreadX SMP accumulates the following information.</span></span> 

<span data-ttu-id="4bf72-950">Número total do sistema global:</span><span class="sxs-lookup"><span data-stu-id="4bf72-950">Total number for the overall system:</span></span>

- <span data-ttu-id="4bf72-951">ativações</span><span class="sxs-lookup"><span data-stu-id="4bf72-951">activations</span></span>
- <span data-ttu-id="4bf72-952">desativações</span><span class="sxs-lookup"><span data-stu-id="4bf72-952">deactivations</span></span>
- <span data-ttu-id="4bf72-953">reativações (temporizadores periódicos)</span><span class="sxs-lookup"><span data-stu-id="4bf72-953">reactivations (periodic timers)</span></span>
- <span data-ttu-id="4bf72-954">expirações</span><span class="sxs-lookup"><span data-stu-id="4bf72-954">expirations</span></span>
- <span data-ttu-id="4bf72-955">ajustamentos de caducidade</span><span class="sxs-lookup"><span data-stu-id="4bf72-955">expiration adjustments</span></span>

<span data-ttu-id="4bf72-956">Número total de cada temporizador de aplicação:</span><span class="sxs-lookup"><span data-stu-id="4bf72-956">Total number for each application timer:</span></span>

- <span data-ttu-id="4bf72-957">ativações</span><span class="sxs-lookup"><span data-stu-id="4bf72-957">activations</span></span>
- <span data-ttu-id="4bf72-958">desativações</span><span class="sxs-lookup"><span data-stu-id="4bf72-958">deactivations</span></span>
- <span data-ttu-id="4bf72-959">reativações (temporizadores periódicos)</span><span class="sxs-lookup"><span data-stu-id="4bf72-959">reactivations (periodic timers)</span></span>
- <span data-ttu-id="4bf72-960">expirações</span><span class="sxs-lookup"><span data-stu-id="4bf72-960">expirations</span></span>
- <span data-ttu-id="4bf72-961">ajustamentos de caducidade</span><span class="sxs-lookup"><span data-stu-id="4bf72-961">expiration adjustments</span></span>

<span data-ttu-id="4bf72-962">Esta informação está disponível em tempo de execução através dos serviços *tx_timer_performance_info_get* e *tx_timer_performance_system_info_get*.</span><span class="sxs-lookup"><span data-stu-id="4bf72-962">This information is available at run-time through the services *tx_timer_performance_info_get* and *tx_timer_performance_system_info_get*.</span></span> <span data-ttu-id="4bf72-963">As informações de desempenho do Tempo de Aplicação são úteis para determinar se a aplicação está a comportar-se corretamente.</span><span class="sxs-lookup"><span data-stu-id="4bf72-963">Application Timer performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="4bf72-964">Também é útil para otimizar a aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-964">It is also useful in optimizing the application.</span></span>

### <a name="application-timer-control-block-tx_timer"></a><span data-ttu-id="4bf72-965">TX_TIMER do bloco de controlo do temporizador de aplicação</span><span class="sxs-lookup"><span data-stu-id="4bf72-965">Application Timer Control Block TX_TIMER</span></span> 
<span data-ttu-id="4bf72-966">As características de cada temporizador de aplicação encontram-se no seu bloco de controlo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-966">The characteristics of each application timer are found in its control block.</span></span> <span data-ttu-id="4bf72-967">Contém informações úteis, como o valor de identificação de 32 bits de validade.</span><span class="sxs-lookup"><span data-stu-id="4bf72-967">It contains useful information such as the 32-bit expiration identification value.</span></span> <span data-ttu-id="4bf72-968">Esta estrutura é definida no ficheiro ***tx_api.h.***</span><span class="sxs-lookup"><span data-stu-id="4bf72-968">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="4bf72-969">Os blocos de controlo do temporizador de aplicação podem ser localizados em qualquer lugar da memória, mas é mais comum fazer do bloco de controlo uma estrutura global definindo-o fora do âmbito de qualquer função.</span><span class="sxs-lookup"><span data-stu-id="4bf72-969">Application timer control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span> 

### <a name="excessive-timers"></a><span data-ttu-id="4bf72-970">Temporizadores excessivos</span><span class="sxs-lookup"><span data-stu-id="4bf72-970">Excessive Timers</span></span> 
<span data-ttu-id="4bf72-971">Por predefinição, os temporizadores de aplicação executam a partir de um fio de sistema oculto que funciona na prioridade zero, que é tipicamente maior do que qualquer fio de aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-971">By default, application timers execute from within a hidden system thread that runs at priority zero, which is typically higher than any application thread.</span></span> <span data-ttu-id="4bf72-972">Por isso, o processamento dos temporizadores de aplicação internos deve ser mantido ao mínimo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-972">Because of this, processing inside application timers should be kept to a minimum.</span></span> 

<span data-ttu-id="4bf72-973">Também é importante evitar, sempre que possível, temporizadores que expiram a cada tique-taque do temporizador.</span><span class="sxs-lookup"><span data-stu-id="4bf72-973">It is also important to avoid, whenever possible, timers that expire every timer tick.</span></span> <span data-ttu-id="4bf72-974">Tal situação pode induzir sobrecargas excessivas no pedido.</span><span class="sxs-lookup"><span data-stu-id="4bf72-974">Such a situation might induce excessive overhead in the application.</span></span>

> [!WARNING]
> <span data-ttu-id="4bf72-975">Como mencionado anteriormente, os temporizadores de aplicação são executados a partir de um fio de sistema oculto.</span><span class="sxs-lookup"><span data-stu-id="4bf72-975">As mentioned previously, application timers are executed from a hidden system thread.</span></span> <span data-ttu-id="4bf72-976">Por isso, é importante não selecionar a suspensão em quaisquer chamadas de serviço ThreadX SMP efetuadas dentro da função de expiração do temporizador da aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-976">It is, therefore, important not to select suspension on any ThreadX SMP service calls made from within the application timer’s expiration function.</span></span>

## <a name="relative-time"></a><span data-ttu-id="4bf72-977">Tempo Relativo</span><span class="sxs-lookup"><span data-stu-id="4bf72-977">Relative Time</span></span>

<span data-ttu-id="4bf72-978">Além dos temporizadores de aplicação mencionados anteriormente, o ThreadX SMP fornece um único contador de tique-taque de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="4bf72-978">In addition to the application timers mentioned previously, ThreadX SMP provides a single continuously incrementing 32-bit tick counter.</span></span> <span data-ttu-id="4bf72-979">O contador de tique-taque ou *o tempo* é aumentado por um em cada interrupção do temporizador.</span><span class="sxs-lookup"><span data-stu-id="4bf72-979">The tick counter or *time* is increased by one on each timer interrupt.</span></span>

<span data-ttu-id="4bf72-980">A aplicação pode ler ou definir este contador de 32 bits através de chamadas para *tx_time_get* e *tx_time_set,* respectivamente.</span><span class="sxs-lookup"><span data-stu-id="4bf72-980">The application can read or set this 32-bit counter through calls to *tx_time_get* and *tx_time_set*, respectively.</span></span> <span data-ttu-id="4bf72-981">A utilização deste contador de carraças é determinada completamente pela aplicação.</span><span class="sxs-lookup"><span data-stu-id="4bf72-981">The use of this tick counter is determined completely by the application.</span></span> <span data-ttu-id="4bf72-982">Não é utilizado internamente pela ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="4bf72-982">It is not used internally by ThreadX SMP.</span></span>

### <a name="interrupts"></a><span data-ttu-id="4bf72-983">Interrupções</span><span class="sxs-lookup"><span data-stu-id="4bf72-983">Interrupts</span></span> 
<span data-ttu-id="4bf72-984">A resposta rápida a eventos assíncronos é a função principal das aplicações incorporadas em tempo real.</span><span class="sxs-lookup"><span data-stu-id="4bf72-984">Fast response to asynchronous events is the principal function of real-time, embedded applications.</span></span> <span data-ttu-id="4bf72-985">A aplicação sabe que tal evento está presente através de interrupções de hardware.</span><span class="sxs-lookup"><span data-stu-id="4bf72-985">The application knows such an event is present through hardware interrupts.</span></span> 

<span data-ttu-id="4bf72-986">Uma interrupção é uma mudança assíncronea na execução do processador.</span><span class="sxs-lookup"><span data-stu-id="4bf72-986">An interrupt is an asynchronous change in processor execution.</span></span> <span data-ttu-id="4bf72-987">Normalmente, quando ocorre uma interrupção, o processador guarda uma pequena parte da execução atual na pilha e transfere o controlo para o vetor de interrupção apropriado.</span><span class="sxs-lookup"><span data-stu-id="4bf72-987">Typically, when an interrupt occurs, the processor saves a small portion of the current execution on the stack and transfers control to the appropriate interrupt vector.</span></span> <span data-ttu-id="4bf72-988">O vetor de interrupção é basicamente apenas o endereço da rotina responsável pelo manuseamento do tipo específico de interrupção.</span><span class="sxs-lookup"><span data-stu-id="4bf72-988">The interrupt vector is basically just the address of the routine responsible for handling the specific type interrupt.</span></span> <span data-ttu-id="4bf72-989">O procedimento exato de manuseamento da interrupção é específico do processador.</span><span class="sxs-lookup"><span data-stu-id="4bf72-989">The exact interrupt handling procedure is processor specific.</span></span> 

### <a name="interrupt-control"></a><span data-ttu-id="4bf72-990">Controlo de Interrupção</span><span class="sxs-lookup"><span data-stu-id="4bf72-990">Interrupt Control</span></span> 
<span data-ttu-id="4bf72-991">O *serviço tx_interrupt_control* permite que as aplicações ativem e desativem as interrupções.</span><span class="sxs-lookup"><span data-stu-id="4bf72-991">The *tx_interrupt_control* service allows applications to enable and disable interrupts.</span></span> <span data-ttu-id="4bf72-992">A postura de ativação/desativação anterior é devolvida por este serviço.</span><span class="sxs-lookup"><span data-stu-id="4bf72-992">The previous interrupt enable/disable posture is returned by this service.</span></span> <span data-ttu-id="4bf72-993">É importante mencionar que o controlo de interrupção só afeta o segmento do programa atualmente executado.</span><span class="sxs-lookup"><span data-stu-id="4bf72-993">It is important to mention that interrupt control only affects the currently executing program segment.</span></span> <span data-ttu-id="4bf72-994">Por exemplo, se um fio desativar interrompe, eles só permanecem desativadas durante a execução desse fio.</span><span class="sxs-lookup"><span data-stu-id="4bf72-994">For example, if a thread disables interrupts, they only remain disabled during execution of that thread.</span></span> 

> [!WARNING]
> <span data-ttu-id="4bf72-995">Uma Interrupção Não Mascarada (NMI) é uma interrupção que não pode ser desativada pelo hardware.</span><span class="sxs-lookup"><span data-stu-id="4bf72-995">A Non-Maskable Interrupt (NMI) is an interrupt that cannot be disabled by the hardware.</span></span> <span data-ttu-id="4bf72-996">Tal interrupção pode ser utilizada por aplicações SMP ThreadX.</span><span class="sxs-lookup"><span data-stu-id="4bf72-996">Such an interrupt may be used by ThreadX SMP applications.</span></span> <span data-ttu-id="4bf72-997">No entanto, a rotina de manuseamento do NMI da aplicação não está autorizada a utilizar a gestão de contexto SMP da ThreadX ou quaisquer serviços API.</span><span class="sxs-lookup"><span data-stu-id="4bf72-997">However, the application’s NMI handling routine is not allowed to use ThreadX SMP context management or any API services.</span></span> <span data-ttu-id="4bf72-998">Interrupções geridas pela ThreadX SMP</span><span class="sxs-lookup"><span data-stu-id="4bf72-998">ThreadX SMP Managed Interrupts</span></span>

<span data-ttu-id="4bf72-999">A ThreadX SMP fornece aplicações com uma gestão completa da interrupção.</span><span class="sxs-lookup"><span data-stu-id="4bf72-999">ThreadX SMP provides applications with complete interrupt management.</span></span> <span data-ttu-id="4bf72-1000">Esta gestão inclui a poupança e restauro do contexto da execução interrompida.</span><span class="sxs-lookup"><span data-stu-id="4bf72-1000">This management includes saving and restoring the context of the interrupted execution.</span></span> <span data-ttu-id="4bf72-1001">Além disso, a ThreadX SMP permite que certos serviços sejam chamados a partir de rotinas de serviço de interrupção (ISRs).</span><span class="sxs-lookup"><span data-stu-id="4bf72-1001">In addition, ThreadX SMP allows certain services to be called from within Interrupt Service Routines (ISRs).</span></span> <span data-ttu-id="4bf72-1002">Segue-se uma lista de serviços SMP da ThreadX permitidos a partir de ISRs de aplicação:</span><span class="sxs-lookup"><span data-stu-id="4bf72-1002">The following is a list of ThreadX SMPservices allowed from application ISRs:</span></span>

- <span data-ttu-id="4bf72-1003">tx_block_allocate</span><span class="sxs-lookup"><span data-stu-id="4bf72-1003">tx_block_allocate</span></span> 
- <span data-ttu-id="4bf72-1004">tx_block_pool_info_get</span><span class="sxs-lookup"><span data-stu-id="4bf72-1004">tx_block_pool_info_get</span></span> 
- <span data-ttu-id="4bf72-1005">tx_block_pool_prioritize</span><span class="sxs-lookup"><span data-stu-id="4bf72-1005">tx_block_pool_prioritize</span></span> 
- <span data-ttu-id="4bf72-1006">tx_block_pool_performance_info_get</span><span class="sxs-lookup"><span data-stu-id="4bf72-1006">tx_block_pool_performance_info_get</span></span> 
- <span data-ttu-id="4bf72-1007">tx_block_pool_performance_system_info_get</span><span class="sxs-lookup"><span data-stu-id="4bf72-1007">tx_block_pool_performance_system_info_get</span></span> 
- <span data-ttu-id="4bf72-1008">tx_block_release</span><span class="sxs-lookup"><span data-stu-id="4bf72-1008">tx_block_release</span></span> 
- <span data-ttu-id="4bf72-1009">tx_byte_pool_info_get</span><span class="sxs-lookup"><span data-stu-id="4bf72-1009">tx_byte_pool_info_get</span></span> 
- <span data-ttu-id="4bf72-1010">tx_byte_pool_performance_info_get</span><span class="sxs-lookup"><span data-stu-id="4bf72-1010">tx_byte_pool_performance_info_get</span></span> 
- <span data-ttu-id="4bf72-1011">tx_byte_pool_performance_system_info_get</span><span class="sxs-lookup"><span data-stu-id="4bf72-1011">tx_byte_pool_performance_system_info_get</span></span> 
- <span data-ttu-id="4bf72-1012">tx_byte_pool_prioritize</span><span class="sxs-lookup"><span data-stu-id="4bf72-1012">tx_byte_pool_prioritize</span></span> 
- <span data-ttu-id="4bf72-1013">tx_event_flags_info_get</span><span class="sxs-lookup"><span data-stu-id="4bf72-1013">tx_event_flags_info_get</span></span> 
- <span data-ttu-id="4bf72-1014">tx_event_flags_get</span><span class="sxs-lookup"><span data-stu-id="4bf72-1014">tx_event_flags_get</span></span> 
- <span data-ttu-id="4bf72-1015">tx_event_flags_set</span><span class="sxs-lookup"><span data-stu-id="4bf72-1015">tx_event_flags_set</span></span> 
- <span data-ttu-id="4bf72-1016">tx_event_flags_performance_info_get</span><span class="sxs-lookup"><span data-stu-id="4bf72-1016">tx_event_flags_performance_info_get</span></span> 
- <span data-ttu-id="4bf72-1017">tx_event_flags_performance_system_info_get</span><span class="sxs-lookup"><span data-stu-id="4bf72-1017">tx_event_flags_performance_system_info_get</span></span> 
- <span data-ttu-id="4bf72-1018">tx_event_flags_set_notify</span><span class="sxs-lookup"><span data-stu-id="4bf72-1018">tx_event_flags_set_notify</span></span> 
- <span data-ttu-id="4bf72-1019">tx_interrupt_control</span><span class="sxs-lookup"><span data-stu-id="4bf72-1019">tx_interrupt_control</span></span> 
- <span data-ttu-id="4bf72-1020">tx_mutex_performance_info_get</span><span class="sxs-lookup"><span data-stu-id="4bf72-1020">tx_mutex_performance_info_get</span></span> 
- <span data-ttu-id="4bf72-1021">tx_mutex_performance_system_info_get</span><span class="sxs-lookup"><span data-stu-id="4bf72-1021">tx_mutex_performance_system_info_get</span></span> 
- <span data-ttu-id="4bf72-1022">tx_queue_front_send</span><span class="sxs-lookup"><span data-stu-id="4bf72-1022">tx_queue_front_send</span></span> 
- <span data-ttu-id="4bf72-1023">tx_queue_info_get</span><span class="sxs-lookup"><span data-stu-id="4bf72-1023">tx_queue_info_get</span></span> 
- <span data-ttu-id="4bf72-1024">tx_queue_performance_info_get</span><span class="sxs-lookup"><span data-stu-id="4bf72-1024">tx_queue_performance_info_get</span></span> 
- <span data-ttu-id="4bf72-1025">tx_queue_performance_system_info_get</span><span class="sxs-lookup"><span data-stu-id="4bf72-1025">tx_queue_performance_system_info_get</span></span> 
- <span data-ttu-id="4bf72-1026">tx_queue_prioritize</span><span class="sxs-lookup"><span data-stu-id="4bf72-1026">tx_queue_prioritize</span></span> 
- <span data-ttu-id="4bf72-1027">tx_queue_receive</span><span class="sxs-lookup"><span data-stu-id="4bf72-1027">tx_queue_receive</span></span> 
- <span data-ttu-id="4bf72-1028">tx_queue_send</span><span class="sxs-lookup"><span data-stu-id="4bf72-1028">tx_queue_send</span></span> 
- <span data-ttu-id="4bf72-1029">tx_semaphore_get</span><span class="sxs-lookup"><span data-stu-id="4bf72-1029">tx_semaphore_get</span></span> 
- <span data-ttu-id="4bf72-1030">tx_queue_send_notify</span><span class="sxs-lookup"><span data-stu-id="4bf72-1030">tx_queue_send_notify</span></span> 
- <span data-ttu-id="4bf72-1031">tx_semaphore_ceiling_put</span><span class="sxs-lookup"><span data-stu-id="4bf72-1031">tx_semaphore_ceiling_put</span></span> 
- <span data-ttu-id="4bf72-1032">tx_semaphore_info_get</span><span class="sxs-lookup"><span data-stu-id="4bf72-1032">tx_semaphore_info_get</span></span> 
- <span data-ttu-id="4bf72-1033">tx_semaphore_performance_info_get</span><span class="sxs-lookup"><span data-stu-id="4bf72-1033">tx_semaphore_performance_info_get</span></span> 
- <span data-ttu-id="4bf72-1034">tx_semaphore_performance_system_info_get</span><span class="sxs-lookup"><span data-stu-id="4bf72-1034">tx_semaphore_performance_system_info_get</span></span> 
- <span data-ttu-id="4bf72-1035">tx_semaphore_prioritize</span><span class="sxs-lookup"><span data-stu-id="4bf72-1035">tx_semaphore_prioritize</span></span> 
- <span data-ttu-id="4bf72-1036">tx_semaphore_put</span><span class="sxs-lookup"><span data-stu-id="4bf72-1036">tx_semaphore_put</span></span> 
- <span data-ttu-id="4bf72-1037">tx_thread_identify</span><span class="sxs-lookup"><span data-stu-id="4bf72-1037">tx_thread_identify</span></span> 
- <span data-ttu-id="4bf72-1038">tx_semaphore_put_notify</span><span class="sxs-lookup"><span data-stu-id="4bf72-1038">tx_semaphore_put_notify</span></span> 
- <span data-ttu-id="4bf72-1039">tx_thread_entry_exit_notify</span><span class="sxs-lookup"><span data-stu-id="4bf72-1039">tx_thread_entry_exit_notify</span></span> 
- <span data-ttu-id="4bf72-1040">tx_thread_info_get</span><span class="sxs-lookup"><span data-stu-id="4bf72-1040">tx_thread_info_get</span></span> 
- <span data-ttu-id="4bf72-1041">tx_thread_resume</span><span class="sxs-lookup"><span data-stu-id="4bf72-1041">tx_thread_resume</span></span> 
- <span data-ttu-id="4bf72-1042">tx_thread_performance_info_get</span><span class="sxs-lookup"><span data-stu-id="4bf72-1042">tx_thread_performance_info_get</span></span> 
- <span data-ttu-id="4bf72-1043">tx_thread_performance_system_info_get</span><span class="sxs-lookup"><span data-stu-id="4bf72-1043">tx_thread_performance_system_info_get</span></span> 
- <span data-ttu-id="4bf72-1044">tx_thread_stack_error_notify</span><span class="sxs-lookup"><span data-stu-id="4bf72-1044">tx_thread_stack_error_notify</span></span> 
- <span data-ttu-id="4bf72-1045">tx_thread_wait_abort</span><span class="sxs-lookup"><span data-stu-id="4bf72-1045">tx_thread_wait_abort</span></span> 
- <span data-ttu-id="4bf72-1046">tx_time_get</span><span class="sxs-lookup"><span data-stu-id="4bf72-1046">tx_time_get</span></span> 
- <span data-ttu-id="4bf72-1047">tx_time_set</span><span class="sxs-lookup"><span data-stu-id="4bf72-1047">tx_time_set</span></span> 
- <span data-ttu-id="4bf72-1048">tx_timer_activate</span><span class="sxs-lookup"><span data-stu-id="4bf72-1048">tx_timer_activate</span></span> 
- <span data-ttu-id="4bf72-1049">tx_timer_change</span><span class="sxs-lookup"><span data-stu-id="4bf72-1049">tx_timer_change</span></span> 
- <span data-ttu-id="4bf72-1050">tx_timer_deactivate</span><span class="sxs-lookup"><span data-stu-id="4bf72-1050">tx_timer_deactivate</span></span> 
- <span data-ttu-id="4bf72-1051">tx_timer_info_get</span><span class="sxs-lookup"><span data-stu-id="4bf72-1051">tx_timer_info_get</span></span> 
- <span data-ttu-id="4bf72-1052">tx_timer_performance_info_get</span><span class="sxs-lookup"><span data-stu-id="4bf72-1052">tx_timer_performance_info_get</span></span> 
- <span data-ttu-id="4bf72-1053">tx_timer_performance_system_info_get</span><span class="sxs-lookup"><span data-stu-id="4bf72-1053">tx_timer_performance_system_info_get</span></span>

> [!WARNING]
> <span data-ttu-id="4bf72-1054">A suspensão não é permitida a partir de ISRs.</span><span class="sxs-lookup"><span data-stu-id="4bf72-1054">Suspension is not allowed from ISRs.</span></span> <span data-ttu-id="4bf72-1055">Por isso, o parâmetro **wait_option** para todas as chamadas de serviço ThreadX SMP efetuadas a partir de um ISR deve ser definido para **TX_NO_WAIT**.</span><span class="sxs-lookup"><span data-stu-id="4bf72-1055">Therefore, the **wait_option** parameter for all ThreadX SMP service calls made from an ISR must be set to **TX_NO_WAIT**.</span></span>

### <a name="isr-template"></a><span data-ttu-id="4bf72-1056">Modelo ISR</span><span class="sxs-lookup"><span data-stu-id="4bf72-1056">ISR Template</span></span> 
<span data-ttu-id="4bf72-1057">Para gerir as interrupções de aplicação, vários utilitários ThreadX SMP devem ser chamados no início e no fim da aplicação ISRs.</span><span class="sxs-lookup"><span data-stu-id="4bf72-1057">To manage application interrupts, several ThreadX SMP utilities must be called in the beginning and end of application ISRs.</span></span> <span data-ttu-id="4bf72-1058">O formato exato para interromper o manuseamento varia entre as portas.</span><span class="sxs-lookup"><span data-stu-id="4bf72-1058">The exact format for interrupt handling varies between ports.</span></span> <span data-ttu-id="4bf72-1059">Reveja o ficheiro ***readme_threadx.txt*** no disco de distribuição para obter instruções específicas sobre a gestão dos ISRs.</span><span class="sxs-lookup"><span data-stu-id="4bf72-1059">Review the ***readme_threadx.txt*** file on the distribution disk for specific instructions on managing ISRs.</span></span>

<span data-ttu-id="4bf72-1060">O seguinte pequeno segmento de código é típico da maioria dos ISRs geridos pela ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="4bf72-1060">The following small code segment is typical of most ThreadX SMP managed ISRs.</span></span> <span data-ttu-id="4bf72-1061">Na maioria dos casos, este processamento está em linguagem de montagem.</span><span class="sxs-lookup"><span data-stu-id="4bf72-1061">In most cases, this processing is in assembly language.</span></span>

<span data-ttu-id="4bf72-1062">**_application_ISR_vetor_entry:**</span><span class="sxs-lookup"><span data-stu-id="4bf72-1062">**_application_ISR_vector_entry**:</span></span>  
<span data-ttu-id="4bf72-1063">; Guardar o contexto e preparar-se para</span><span class="sxs-lookup"><span data-stu-id="4bf72-1063">; Save context and prepare for</span></span>  
<span data-ttu-id="4bf72-1064">; Utilização de SMP ThreadX chamando o ISR</span><span class="sxs-lookup"><span data-stu-id="4bf72-1064">; ThreadX SMP use by calling the ISR</span></span>  
<span data-ttu-id="4bf72-1065">; função de entrada.</span><span class="sxs-lookup"><span data-stu-id="4bf72-1065">; entry function.</span></span>  
<span data-ttu-id="4bf72-1066">LIGUE **_tx_thread_context_save**</span><span class="sxs-lookup"><span data-stu-id="4bf72-1066">CALL **_tx_thread_context_save**</span></span>  

<span data-ttu-id="4bf72-1067">; O ISR já pode chamar ThreadX SMP</span><span class="sxs-lookup"><span data-stu-id="4bf72-1067">; The ISR can now call ThreadX SMP</span></span>  
<span data-ttu-id="4bf72-1068">; serviços e as suas próprias funções C</span><span class="sxs-lookup"><span data-stu-id="4bf72-1068">; services and its own C functions</span></span>  

<span data-ttu-id="4bf72-1069">; Quando o ISR estiver terminado, contexto</span><span class="sxs-lookup"><span data-stu-id="4bf72-1069">; When the ISR is finished, context</span></span>  
<span data-ttu-id="4bf72-1070">; é restaurado (ou preempção do fio)</span><span class="sxs-lookup"><span data-stu-id="4bf72-1070">; is restored (or thread preemption)</span></span>  
<span data-ttu-id="4bf72-1071">; chamando o contexto restaurar</span><span class="sxs-lookup"><span data-stu-id="4bf72-1071">; by calling the context restore</span></span>  
<span data-ttu-id="4bf72-1072">; função.</span><span class="sxs-lookup"><span data-stu-id="4bf72-1072">; function.</span></span> <span data-ttu-id="4bf72-1073">O controlo não volta!</span><span class="sxs-lookup"><span data-stu-id="4bf72-1073">Control does not return!</span></span>  
<span data-ttu-id="4bf72-1074">**_TX_THREAD_CONTEXT_RESTORE** DE SALTO</span><span class="sxs-lookup"><span data-stu-id="4bf72-1074">JUMP **_tx_thread_context_restore**</span></span>

### <a name="high-frequency-interrupts"></a><span data-ttu-id="4bf72-1075">Interrupções de alta frequência</span><span class="sxs-lookup"><span data-stu-id="4bf72-1075">High-frequency Interrupts</span></span>  
<span data-ttu-id="4bf72-1076">Algumas interrupções ocorrem numa frequência tão alta que poupar e restaurar todo o contexto em cada interrupção consumiria uma largura de banda de processamento excessiva.</span><span class="sxs-lookup"><span data-stu-id="4bf72-1076">Some interrupts occur at such a high frequency that saving and restoring full context upon each interrupt would consume excessive processing bandwidth.</span></span> <span data-ttu-id="4bf72-1077">Nestes casos, é comum que a aplicação tenha uma pequena lingueta de montagem ISR que faz uma quantidade limitada de processamento para a maioria destas interrupções de altafrequência.</span><span class="sxs-lookup"><span data-stu-id="4bf72-1077">In such cases, it is common for the application to have a small assembly language ISR that does a limited amount of processing for a majority of these highfrequency interrupts.</span></span> 

<span data-ttu-id="4bf72-1078">Após um certo ponto no tempo, o pequeno ISR pode ter de interagir com o ThreadX SMP.</span><span class="sxs-lookup"><span data-stu-id="4bf72-1078">After a certain point in time, the small ISR may need to interact with ThreadX SMP.</span></span> <span data-ttu-id="4bf72-1079">Isto é conseguido através da chamada das funções de entrada e saída descritas no modelo acima.</span><span class="sxs-lookup"><span data-stu-id="4bf72-1079">This is accomplished by calling the entry and exit functions described in the above template.</span></span> 

### <a name="interrupt-latency"></a><span data-ttu-id="4bf72-1080">Interromper a latência</span><span class="sxs-lookup"><span data-stu-id="4bf72-1080">Interrupt Latency</span></span>  
<span data-ttu-id="4bf72-1081">ThreadX SMP bloqueia interrupções durante breves períodos de tempo.</span><span class="sxs-lookup"><span data-stu-id="4bf72-1081">ThreadX SMP locks out interrupts over brief periods of time.</span></span> <span data-ttu-id="4bf72-1082">A quantidade máxima de tempo desativada está na ordem do tempo necessária para guardar ou restaurar o contexto de um fio.</span><span class="sxs-lookup"><span data-stu-id="4bf72-1082">The maximum amount of time interrupts are disabled is on the order of the time required to save or restore a thread’s context.</span></span> 