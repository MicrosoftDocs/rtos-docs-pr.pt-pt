---
title: Capítulo 3 - Descrição funcional do Azure RTOS NetX Secure DTLS
description: Este capítulo contém uma descrição funcional do Azure RTOS NetX Secure DTLS.
author: philmea
ms.author: philmea
ms.date: 06/04/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 468f1dc8a8334dc89064594b29dc8cfabd7d8fae
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: MT
ms.contentlocale: pt-PT
ms.lasthandoff: 03/22/2021
ms.locfileid: "104826978"
---
# <a name="chapter-3-functional-description-of-azure-rtos-netx-secure-dtls"></a><span data-ttu-id="467ae-103">Capítulo 3: Descrição funcional do Azure RTOS NetX Secure DTLS</span><span class="sxs-lookup"><span data-stu-id="467ae-103">Chapter 3: Functional description of Azure RTOS NetX Secure DTLS</span></span>

## <a name="execution-overview"></a><span data-ttu-id="467ae-104">Visão geral da execução</span><span class="sxs-lookup"><span data-stu-id="467ae-104">Execution Overview</span></span>

<span data-ttu-id="467ae-105">Este capítulo contém uma descrição funcional do Azure RTOS NetX Secure DTLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-105">This chapter contains a functional description of Azure RTOS NetX Secure DTLS.</span></span> <span data-ttu-id="467ae-106">Existem dois tipos primários de execução de programas numa aplicação DTLS NetX Secure: inicialização e interface de aplicação.</span><span class="sxs-lookup"><span data-stu-id="467ae-106">There are two primary types of program execution in a NetX Secure DTLS application: initialization and application interface calls.</span></span> 

<span data-ttu-id="467ae-107">NetX Secure assume a existência de ThreadX e NetX/NetXDuo.</span><span class="sxs-lookup"><span data-stu-id="467ae-107">NetX Secure assumes the existence of ThreadX and NetX/NetXDuo.</span></span> <span data-ttu-id="467ae-108">Da ThreadX, requer execução de fios, suspensão, temporizadores periódicos e instalações de exclusão mútua.</span><span class="sxs-lookup"><span data-stu-id="467ae-108">From ThreadX, it requires thread execution, suspension, periodic timers, and mutual exclusion facilities.</span></span> <span data-ttu-id="467ae-109">A partir da NetX/NetXDuo requer as instalações de rede UDP e IP e os controladores.</span><span class="sxs-lookup"><span data-stu-id="467ae-109">From NetX/NetXDuo it requires the UDP and IP networking facilities and drivers.</span></span>

## <a name="datagram-transport-layer-security-dtls-and-transport-layer-security-tls"></a><span data-ttu-id="467ae-110">Segurança da camada de transporte de datagram (DTLS) e segurança da camada de transporte (TLS)</span><span class="sxs-lookup"><span data-stu-id="467ae-110">Datagram Transport Layer Security (DTLS) and Transport Layer Security (TLS)</span></span>

<span data-ttu-id="467ae-111">O NetX Secure DTLS implementa a versão 1.2 do protocolo de segurança da camada de transporte de dados 1.2 definida no RFC 6347.</span><span class="sxs-lookup"><span data-stu-id="467ae-111">NetX Secure DTLS implements the Datagram Transport Layer Security protocol version 1.2 defined in RFC 6347.</span></span> <span data-ttu-id="467ae-112">A versão 1.0 do DTLS foi definida no RFC 4347 e correspondeu à versão 1.1 da TLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-112">DTLS version 1.0 was defined in RFC 4347 and corresponded to TLS version 1.1.</span></span> <span data-ttu-id="467ae-113">Devido ao DTLS ser essencialmente uma extensão ao TLS, foi decidido que a versão seguinte utilizaria o mesmo número de versão que a versão TLS correspondente.</span><span class="sxs-lookup"><span data-stu-id="467ae-113">Due to DTLS being essentially an extension to TLS, it was decided that the next version would use the same version number as the corresponding TLS version.</span></span> <span data-ttu-id="467ae-114">Assim, não existe a versão DTLS 1.1, uma vez que a versão 1.2 do DTLS corresponde à versão 1.2 do TLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-114">Thus, there is no DTLS version 1.1 as DTLS version 1.2 corresponds to TLS version 1.2.</span></span>

> [!NOTE]
> <span data-ttu-id="467ae-115">NetX Secure suporta a versão DTLS 1.2.</span><span class="sxs-lookup"><span data-stu-id="467ae-115">NetX Secure supports DTLS version 1.2.</span></span> <span data-ttu-id="467ae-116">O DTLS 1.0 (RFC 4347) **não** está atualmente suportado.</span><span class="sxs-lookup"><span data-stu-id="467ae-116">DTLS 1.0 (RFC 4347) is **not** currently supported.</span></span>

<span data-ttu-id="467ae-117">*Secure Sockets Layer* (SSL) foi o nome original de TLS antes de se tornar um padrão em RFC 2246 e "SSL" é frequentemente usado como um nome genérico para os protocolos TLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-117">*Secure Sockets Layer* (SSL) was the original name of TLS before it became a standard in RFC 2246 and “SSL” is often used as a generic name for the TLS protocols.</span></span> <span data-ttu-id="467ae-118">A última versão do SSL foi 3.0, e tLS 1.0 é por vezes referida como versão SSL 3.1.</span><span class="sxs-lookup"><span data-stu-id="467ae-118">The last version of SSL was 3.0, and TLS 1.0 is sometimes referred to as SSL version 3.1.</span></span> <span data-ttu-id="467ae-119">Todas as versões do protocolo oficial "SSL" são consideradas obsoletas e inseguras e atualmente o NetX Secure não fornece uma implementação SSL.</span><span class="sxs-lookup"><span data-stu-id="467ae-119">All versions of the official “SSL” protocol are considered obsolete and insecure and currently NetX Secure does not provide an SSL implementation.</span></span>

<span data-ttu-id="467ae-120">O TLS especifica um protocolo para gerar *teclas* de sessão que são criadas durante o *aperto de mão* TLS entre um cliente TLS e servidor e essas teclas são usadas para encriptar dados enviados pela aplicação durante a sessão TLS. </span><span class="sxs-lookup"><span data-stu-id="467ae-120">TLS specifies a protocol to generate *session keys* which are created during the TLS *handshake* between a TLS client and server and those keys are used to encrypt data sent by the application during the TLS *session.*</span></span>

<span data-ttu-id="467ae-121">O DTLS é intimamente associado ao TLS, uma vez que os mecansos de segurança subjacentes são partilhados entre os protocolos.</span><span class="sxs-lookup"><span data-stu-id="467ae-121">DTLS is closely coupled with TLS, as the underlying security mechansims are shared between the protocols.</span></span> <span data-ttu-id="467ae-122">No entanto, o TLS foi concebido para trabalhar ao longo de um protocolo de camada de transporte que fornece garantias sobre a entrega e encomenda de pacotes (quase sempre TCP na prática) e não funcionará sobre um protocolo pouco fiável como a UDP.</span><span class="sxs-lookup"><span data-stu-id="467ae-122">However, TLS is designed to work over a transport layer protocol that provides guarantees about packet delivery and order (almost always TCP in practice) and will not function over an unreliable protocol like UDP.</span></span> <span data-ttu-id="467ae-123">Foi precisamente por causa da UDP que o DTLS foi introduzido: o DTLS foi concebido para lidar com a natureza pouco fiável da UDP e protocolos semelhantes.</span><span class="sxs-lookup"><span data-stu-id="467ae-123">It is precisely because of UDP that DTLS was introduced: DTLS was designed handle the unreliable nature of UDP and similar protocols.</span></span> <span data-ttu-id="467ae-124">Fá-lo incluindo a lógica de encomenda e fiabilidade (por exemplo, retransmissão de dados abandonados) semelhante a protocolos fiáveis como o TCP.</span><span class="sxs-lookup"><span data-stu-id="467ae-124">It does this by including ordering and reliability logic (e.g. retransmission of dropped data) similar to reliable protocols like TCP.</span></span>

<span data-ttu-id="467ae-125">Uma discussão completa sobre OTS está incluída no Capítulo 3 do Guia do Utilizador NetX Secure TLS, pelo que este documento irá focar-se nas diferenças entre TLS e DTLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-125">A complete discussion of TLS is included in Chapter 3 of the NetX Secure TLS User’s Guide, so this document will focus on the differences between TLS and DTLS.</span></span>

### <a name="dtls-record-header"></a><span data-ttu-id="467ae-126">Cabeçalho de registo DTLS</span><span class="sxs-lookup"><span data-stu-id="467ae-126">DTLS Record header</span></span>

<span data-ttu-id="467ae-127">Qualquer registo DTLS válido deve ter um cabeçalho DTLS, como mostra a Figura 1.</span><span class="sxs-lookup"><span data-stu-id="467ae-127">Any valid DTLS record must have a DTLS header, as shown in Figure 1.</span></span> <span data-ttu-id="467ae-128">O cabeçalho é o mesmo que o TLS com a adição de dois novos campos: a época de 16 *bits* e o número de *sequência* de 48 bits, descrito abaixo.</span><span class="sxs-lookup"><span data-stu-id="467ae-128">The header is the same as TLS with the addition of two new fields: the 16-bit *epoch* and the 48-bit *sequence number*, described below.</span></span>

![Diagrama de um cabeçalho de disco DTLS.](media/image2.png)

<span data-ttu-id="467ae-130">**Figura 1 - Cabeçalho de registo DTLS**</span><span class="sxs-lookup"><span data-stu-id="467ae-130">**Figure 1 - DTLS record header**</span></span>

<span data-ttu-id="467ae-131">Os campos do cabeçalho de registo TLS são definidos da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="467ae-131">The fields of the TLS record header are defined as follows:</span></span>

| <span data-ttu-id="467ae-132">Campo de cabeçalho TLS</span><span class="sxs-lookup"><span data-stu-id="467ae-132">TLS Header Field</span></span> | <span data-ttu-id="467ae-133">Objetivo</span><span class="sxs-lookup"><span data-stu-id="467ae-133">Purpose</span></span>  |
| ---------------- | --------- |
| <span data-ttu-id="467ae-134">**Tipo de mensagem de 8 bits**</span><span class="sxs-lookup"><span data-stu-id="467ae-134">**8-bit Message Type**</span></span> | <span data-ttu-id="467ae-135">Este campo contém o tipo de registo DTLS enviado.</span><span class="sxs-lookup"><span data-stu-id="467ae-135">This field contains the type of DTLS record being sent.</span></span> <span data-ttu-id="467ae-136">Os tipos válidos são os seguintes:</span><span class="sxs-lookup"><span data-stu-id="467ae-136">Valid types are as follows:</span></span><br /><span data-ttu-id="467ae-137">- ChangeCipherSpec: 0x14</span><span class="sxs-lookup"><span data-stu-id="467ae-137">- ChangeCipherSpec: 0x14</span></span><br /><span data-ttu-id="467ae-138">- Alerta: 0x15</span><span class="sxs-lookup"><span data-stu-id="467ae-138">- Alert: 0x15</span></span><br /><span data-ttu-id="467ae-139">- Aperto de mão: 0x16</span><span class="sxs-lookup"><span data-stu-id="467ae-139">- Handshake: 0x16</span></span><br /><span data-ttu-id="467ae-140">- Dados da aplicação: 0x17</span><span class="sxs-lookup"><span data-stu-id="467ae-140">- Application Data: 0x17</span></span><br /> |
| <span data-ttu-id="467ae-141">**Versão do protocolo de 16 bits**</span><span class="sxs-lookup"><span data-stu-id="467ae-141">**16-bit Protocol Version**</span></span> | <span data-ttu-id="467ae-142">Este campo contém a versão do protocolo DTLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-142">This field contains the DTLS protocol version.</span></span> <span data-ttu-id="467ae-143">Os valores válidos são os seguintes:</span><span class="sxs-lookup"><span data-stu-id="467ae-143">Valid values are as follows:</span></span><br /><span data-ttu-id="467ae-144">- DTLS 1.1: 0xFEFD</span><span class="sxs-lookup"><span data-stu-id="467ae-144">- DTLS 1.1: 0xFEFD</span></span> |
|  <span data-ttu-id="467ae-145">**Época de 16 bits**</span><span class="sxs-lookup"><span data-stu-id="467ae-145">**16-bit Epoch**</span></span> |  <span data-ttu-id="467ae-146">Este campo contém a "época" DTLS, que é um contador que é incrementado cada vez que o estado de encriptação é alterado (por exemplo, ao gerar novas teclas de sessão).</span><span class="sxs-lookup"><span data-stu-id="467ae-146">This field contains the DTLS “epoch” which is a counter that is incremented each time the encryption state is changed (e.g. when generating new session keys).</span></span>  |
|  <span data-ttu-id="467ae-147">**Número de sequência de 48 bits**</span><span class="sxs-lookup"><span data-stu-id="467ae-147">**48-bit Sequence Number**</span></span> |  <span data-ttu-id="467ae-148">Este campo contém um número de sequência que identifica este registo em particular.</span><span class="sxs-lookup"><span data-stu-id="467ae-148">This field contains a sequence number which identifies this particular record.</span></span> <span data-ttu-id="467ae-149">É utilizado pela DTLS para manter a ordem de registo e verificar a necessidade de retransmissão.</span><span class="sxs-lookup"><span data-stu-id="467ae-149">It is used by DTLS to maintain record ordering and check for retransmission need.</span></span> |
|  <span data-ttu-id="467ae-150">**Comprimento de 16 bits**</span><span class="sxs-lookup"><span data-stu-id="467ae-150">**16-bit Length**</span></span> |  <span data-ttu-id="467ae-151">Este campo contém o comprimento dos dados encapsulados no registo DTLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-151">This field contains the length of the data encapsulated in the DTLS record.</span></span>  |

### <a name="dtls-handshake-record-header"></a><span data-ttu-id="467ae-152">Cabeçalho do recorde de aperto de mão DTLS</span><span class="sxs-lookup"><span data-stu-id="467ae-152">DTLS Handshake Record header</span></span>

<span data-ttu-id="467ae-153">Qualquer registo de aperto de mão DTLS válido deve ter um cabeçalho de aperto de mão DTLS, como mostra a Figura 2.</span><span class="sxs-lookup"><span data-stu-id="467ae-153">Any valid DTLS handshake record must have a DTLS Handshake header, as shown in Figure 2.</span></span>

![Diagrama de um cabeçalho do Disco de Aperto de Aperto de Mão DTLS.](media/image3.png)

<span data-ttu-id="467ae-155">**Figura 2 - Cabeçalho de recorde de aperto de mão DTLS**</span><span class="sxs-lookup"><span data-stu-id="467ae-155">**Figure 2 - DTLS Handshake record header**</span></span>

<span data-ttu-id="467ae-156">Os campos do cabeçalho de registo do aperto de mão DTLS são definidos da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="467ae-156">The fields of the DTLS Handshake record header are defined as follows:</span></span>

| <span data-ttu-id="467ae-157">Campo de cabeçalho TLS</span><span class="sxs-lookup"><span data-stu-id="467ae-157">TLS Header Field</span></span> | <span data-ttu-id="467ae-158">Objetivo</span><span class="sxs-lookup"><span data-stu-id="467ae-158">Purpose</span></span> |
| ---------------- | ------------------------------------------------ |
| <span data-ttu-id="467ae-159">**Tipo de mensagem de 8 bits**</span><span class="sxs-lookup"><span data-stu-id="467ae-159">**8-bit Message Type**</span></span> | <span data-ttu-id="467ae-160">Este campo contém o tipo de registo DTLS enviado.</span><span class="sxs-lookup"><span data-stu-id="467ae-160">This field contains the type of DTLS record being sent.</span></span> <span data-ttu-id="467ae-161">Os tipos válidos são os seguintes:</span><span class="sxs-lookup"><span data-stu-id="467ae-161">Valid types are as follows:</span></span><br /><span data-ttu-id="467ae-162">- ChangeCipherSpec: 0x14</span><span class="sxs-lookup"><span data-stu-id="467ae-162">- ChangeCipherSpec: 0x14</span></span><br /><span data-ttu-id="467ae-163">- Alerta: 0x15</span><span class="sxs-lookup"><span data-stu-id="467ae-163">- Alert: 0x15</span></span><br /><span data-ttu-id="467ae-164">- Aperto de mão: 0x16</span><span class="sxs-lookup"><span data-stu-id="467ae-164">- Handshake: 0x16</span></span><br /><span data-ttu-id="467ae-165">- Dados da aplicação: 0x17</span><span class="sxs-lookup"><span data-stu-id="467ae-165">- Application Data: 0x17</span></span> |
|  <span data-ttu-id="467ae-166">**Época de 16 bits**</span><span class="sxs-lookup"><span data-stu-id="467ae-166">**16-bit Epoch**</span></span> | <span data-ttu-id="467ae-167">Este campo contém a "época" DTLS, que é um contador que é incrementado cada vez que o estado de encriptação é alterado (por exemplo, ao gerar novas teclas de sessão).</span><span class="sxs-lookup"><span data-stu-id="467ae-167">This field contains the DTLS “epoch” which is a counter that is incremented each time the encryption state is changed (e.g. when generating new session keys).</span></span> |
|  <span data-ttu-id="467ae-168">**Número de sequência de 48 bits**</span><span class="sxs-lookup"><span data-stu-id="467ae-168">**48-bit Sequence Number**</span></span> | <span data-ttu-id="467ae-169">Este campo contém um número de sequência que identifica este registo em particular.</span><span class="sxs-lookup"><span data-stu-id="467ae-169">This field contains a sequence number which identifies this particular record.</span></span> <span data-ttu-id="467ae-170">É utilizado pela DTLS para manter a ordem de registo e verificar a necessidade de retransmissão.</span><span class="sxs-lookup"><span data-stu-id="467ae-170">It is used by DTLS to maintain record ordering and check for retransmission need.</span></span> |
|  <span data-ttu-id="467ae-171">**Versão do protocolo de 16 bits**</span><span class="sxs-lookup"><span data-stu-id="467ae-171">**16-bit Protocol Version**</span></span> | <span data-ttu-id="467ae-172">Este campo contém a versão do protocolo DTLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-172">This field contains the DTLS protocol version.</span></span> <span data-ttu-id="467ae-173">Os valores válidos são os seguintes:</span><span class="sxs-lookup"><span data-stu-id="467ae-173">Valid values are as follows:</span></span><br /><span data-ttu-id="467ae-174">- DTLS 1.1: 0xFEFD</span><span class="sxs-lookup"><span data-stu-id="467ae-174">- DTLS 1.1: 0xFEFD</span></span> |
| <span data-ttu-id="467ae-175">**Comprimento de 16 bits**</span><span class="sxs-lookup"><span data-stu-id="467ae-175">**16-bit Length**</span></span> | <span data-ttu-id="467ae-176">Este campo contém o comprimento dos dados encapsulados no registo DTLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-176">This field contains the length of the data encapsulated in the DTLS record.</span></span> |
| <span data-ttu-id="467ae-177">**Tipo de aperto de mão de 8 bits**</span><span class="sxs-lookup"><span data-stu-id="467ae-177">**8-bit Handshake Type**</span></span> | <span data-ttu-id="467ae-178">Este campo contém o tipo de mensagem de aperto de mão.</span><span class="sxs-lookup"><span data-stu-id="467ae-178">This field contains the handshake message type.</span></span> <span data-ttu-id="467ae-179">Os valores válidos são os seguintes:</span><span class="sxs-lookup"><span data-stu-id="467ae-179">Valid values are as follows:</span></span><br /><span data-ttu-id="467ae-180">- HelloRequest: 0x00</span><span class="sxs-lookup"><span data-stu-id="467ae-180">- HelloRequest: 0x00</span></span><br /><span data-ttu-id="467ae-181">- ClientHello: 0x01</span><span class="sxs-lookup"><span data-stu-id="467ae-181">- ClientHello: 0x01</span></span><br /><span data-ttu-id="467ae-182">- ServerHello: 0x02</span><span class="sxs-lookup"><span data-stu-id="467ae-182">- ServerHello: 0x02</span></span><br /><span data-ttu-id="467ae-183">- Certificado: 0x0B</span><span class="sxs-lookup"><span data-stu-id="467ae-183">- Certificate: 0x0B</span></span><br /><span data-ttu-id="467ae-184">- ServerKeyExchange: 0x0C</span><span class="sxs-lookup"><span data-stu-id="467ae-184">- ServerKeyExchange: 0x0C</span></span><br /><span data-ttu-id="467ae-185">- CertificadoRequest: 0x0D</span><span class="sxs-lookup"><span data-stu-id="467ae-185">- CertificateRequest: 0x0D</span></span><br /><span data-ttu-id="467ae-186">- ServerHelloDone: 0x0E</span><span class="sxs-lookup"><span data-stu-id="467ae-186">- ServerHelloDone: 0x0E</span></span><br /><span data-ttu-id="467ae-187">- CertificaçãoVerifical: 0x0F</span><span class="sxs-lookup"><span data-stu-id="467ae-187">- CertificateVerify: 0x0F</span></span><br /><span data-ttu-id="467ae-188">- ClientKeyExchange: 0x10</span><span class="sxs-lookup"><span data-stu-id="467ae-188">- ClientKeyExchange: 0x10</span></span><br /><span data-ttu-id="467ae-189">- Concluída</span><span class="sxs-lookup"><span data-stu-id="467ae-189">- Finished</span></span> | <span data-ttu-id="467ae-190">0x14</span><span class="sxs-lookup"><span data-stu-id="467ae-190">0x14</span></span> |
| <span data-ttu-id="467ae-191">**Comprimento de 24 bits**</span><span class="sxs-lookup"><span data-stu-id="467ae-191">**24-bit Length**</span></span> | <span data-ttu-id="467ae-192">Este campo contém o comprimento dos dados da mensagem de aperto de mão.</span><span class="sxs-lookup"><span data-stu-id="467ae-192">This field contains the length of the handshake message data.</span></span> |
| <span data-ttu-id="467ae-193">**Número de sequência de 16 bits**</span><span class="sxs-lookup"><span data-stu-id="467ae-193">**16-bit Sequence Number**</span></span> | <span data-ttu-id="467ae-194">Este campo contém um número de sequência.</span><span class="sxs-lookup"><span data-stu-id="467ae-194">This field contains a sequence number.</span></span> |

### <a name="the-dtls-handshake-and-dtls-session"></a><span data-ttu-id="467ae-195">O aperto de mão dTLS e a Sessão DTLS</span><span class="sxs-lookup"><span data-stu-id="467ae-195">The DTLS Handshake and DTLS Session</span></span>

<span data-ttu-id="467ae-196">Um aperto de mão típico do DTLS é mostrado na Figura 3.</span><span class="sxs-lookup"><span data-stu-id="467ae-196">A typical DTLS handshake is shown in Figure 3.</span></span> <span data-ttu-id="467ae-197">É quase idêntico ao típico aperto de mão TLS com uma diferença importante – quando a mensagem ClientHello é enviada pela primeira vez, o servidor responde com uma nova mensagem específica do DTLS, *HelloVerifyRequest* que contém um "cookie".</span><span class="sxs-lookup"><span data-stu-id="467ae-197">It is nearly identical to the typical TLS handshake with an important difference – when the ClientHello message is first sent, the server responds with a new DTLS-specific message, *HelloVerifyRequest* which contains a “cookie”.</span></span> <span data-ttu-id="467ae-198">O Cliente DTLS deve responder com uma segunda mensagem ClientHello contendo esse cookie antes que o aperto de mão possa prosseguir.</span><span class="sxs-lookup"><span data-stu-id="467ae-198">The DTLS Client must respond with a second ClientHello message containing that cookie before the handshake can proceed.</span></span> <span data-ttu-id="467ae-199">Este mecanismo foi adicionado ao DTLS para evitar certos ataques de Negação de Serviço (DoS), uma vez que a UDP é um protocolo sem ligação (a TCP requer uma ligação/porta dedicada para que o TLS não sofra do mesmo problema).</span><span class="sxs-lookup"><span data-stu-id="467ae-199">This mechanism was added to DTLS to prevent certain Denial of Service (DoS) attacks since UDP is a connectionless protocol (TCP requires a dedicated connection/port so TLS does not suffer from the same issue).</span></span>

<span data-ttu-id="467ae-200">Um aperto de mão DTLS começa quando o Cliente envia uma mensagem *ClientHello* para um servidor DTLS, indicando o seu desejo de iniciar uma sessão de DTLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-200">A DTLS handshake begins when the Client sends a *ClientHello* message to a DTLS server, indicating its desire to start a DTLS session.</span></span> <span data-ttu-id="467ae-201">A mensagem contém informações sobre a encriptação que o cliente gostaria de usar para a sessão, juntamente com as informações usadas para gerar as teclas de sessão mais tarde no aperto de mão.</span><span class="sxs-lookup"><span data-stu-id="467ae-201">The message contains information about the encryption the client would like to use for the session, along with information used to generate the session keys later in the handshake.</span></span> <span data-ttu-id="467ae-202">Até que as teclas de sessão sejam geradas, todas as mensagens no aperto de mão DTLS não são encriptadas.</span><span class="sxs-lookup"><span data-stu-id="467ae-202">Until the session keys are generated, all messages in the DTLS handshake are not encrypted.</span></span> <span data-ttu-id="467ae-203">Como mencionado acima, o DTLS Server pode enviar um HelloVerifyRequest em resposta ao ClientHello, forçando o cliente a responder com um segundo ClientHello atualizado.</span><span class="sxs-lookup"><span data-stu-id="467ae-203">As mentioned above, the DTLS Server may send a HelloVerifyRequest in response to the ClientHello, forcing the client to respond with a second updated ClientHello.</span></span>

<span data-ttu-id="467ae-204">Ao receber a segunda mensagem ClientHello, o DTLS Server verificará o cookie e, se estiver correto, responderá com uma mensagem ServerHello indicando uma seleção das opções de encriptação fornecidas pelo cliente.</span><span class="sxs-lookup"><span data-stu-id="467ae-204">Upon receiving the second ClientHello message, the DTLS Server will verify the cookie and if correct will respond with a ServerHello message indicating a selection from the encryption options provided by the client.</span></span> <span data-ttu-id="467ae-205">O ServerHello é seguido por uma mensagem de Certificado, na qual o servidor fornece um certificado digital para autenticar a sua identidade ao cliente (se for utilizada a verificação X.509).</span><span class="sxs-lookup"><span data-stu-id="467ae-205">The ServerHello is followed by a Certificate message, in which the server provides a digital certificate to authenticate its identity to the client (if X.509 verification is used).</span></span> <span data-ttu-id="467ae-206">Finalmente, o servidor envia uma mensagem ServerHelloDone para indicar que não tem mais mensagens para enviar.</span><span class="sxs-lookup"><span data-stu-id="467ae-206">Finally, the server sends a ServerHelloDone message to indicate it has no more messages to send.</span></span> <span data-ttu-id="467ae-207">O servidor pode enviar opcionalmente outras mensagens seguindo o ServerHello e, em alguns casos, pode não enviar uma mensagem de Certificado (como quando são utilizadas chaves pré-partilhadas), daí a necessidade da mensagem ServerHelloDone.</span><span class="sxs-lookup"><span data-stu-id="467ae-207">The server may optionally send other messages following the ServerHello and in some cases it may not send a Certificate message (such as when Pre-Shared Keys are used), hence the need for the ServerHelloDone message.</span></span>

<span data-ttu-id="467ae-208">Uma vez que o cliente tenha recebido todas as mensagens do servidor, tem informações suficientes para gerar as teclas de sessão.</span><span class="sxs-lookup"><span data-stu-id="467ae-208">Once the client has received all the server’s messages, it has enough information to generate the session keys.</span></span> <span data-ttu-id="467ae-209">O TLS/DTLS faz isso criando uma parte partilhada de dados aleatórios *chamados Pre-Master Secret*, que é um tamanho fixo e é usado como uma semente para gerar todas as chaves necessárias uma vez que a encriptação é ativada.</span><span class="sxs-lookup"><span data-stu-id="467ae-209">TLS/DTLS does this by creating a shared bit of random data called the *Pre-Master Secret*, which is a fixed-size and is used as a seed to generate all the keys needed once encryption is enabled.</span></span> <span data-ttu-id="467ae-210">O Segredo Pré-Mestre é encriptado utilizando o algoritmo de chave pública (por exemplo, RSA) especificado nas mensagens Hello (ver abaixo para obter informações sobre algoritmos de chaves públicas) e a chave pública fornecida pelo servidor no seu certificado.</span><span class="sxs-lookup"><span data-stu-id="467ae-210">The Pre-Master Secret is encrypted using the public key algorithm (e.g. RSA) specified in the Hello messages (see below for information on public key algorithms) and the public key provided by the server in its certificate.</span></span> <span data-ttu-id="467ae-211">Uma funcionalidade opcional TLS/DTLS chamada Chaves Pré-Partilhadas (PSK) permite cifrasuites que não usam um certificado, mas em vez disso usam um valor secreto partilhado entre os anfitriões (geralmente através de transferência física ou outro método seguro).</span><span class="sxs-lookup"><span data-stu-id="467ae-211">An optional TLS/DTLS feature called Pre-Shared Keys (PSK) enables ciphersuites that do not use a certificate but instead use a secret value shared between the hosts (usually through physical transfer or other secured method).</span></span> <span data-ttu-id="467ae-212">Quando o PSK está ativado, a chave secreta pré-partilhada é usada para gerar o Segredo Pré-Mestre.</span><span class="sxs-lookup"><span data-stu-id="467ae-212">When PSK is enabled, the pre-shared secret key is used to generate the Pre-Master Secret.</span></span> <span data-ttu-id="467ae-213">Consulte a secção em Chaves Pré-Partilhadas em "Métodos de Autenticação" abaixo.</span><span class="sxs-lookup"><span data-stu-id="467ae-213">See the section on Pre-Shared Keys in “Authentication Methods” below.</span></span>

<span data-ttu-id="467ae-214">Num habitual aperto de mão TLS/DTLS, o Pre-Master Secret encriptado é enviado para o servidor na mensagem ClientKeyExchange.</span><span class="sxs-lookup"><span data-stu-id="467ae-214">In a usual TLS/DTLS handshake, the encrypted Pre-Master Secret is sent to the server in the ClientKeyExchange message.</span></span> <span data-ttu-id="467ae-215">O servidor, ao receber a mensagem ClientKeyExchange, desencripta o Segredo Pré-Mestre usando a sua chave privada e procede à geração das teclas de sessão em paralelo com o cliente TLS/DTLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-215">The server, upon receiving the ClientKeyExchange message, decrypts the Pre-Master Secret using its private key and proceeds to generate the session keys in parallel with the TLS/DTLS client.</span></span>

<span data-ttu-id="467ae-216">Uma vez geradas as teclas de sessão, todas as mensagens adicionais podem ser encriptadas utilizando o algoritmo de tecla privada (por exemplo, AES) selecionado nas mensagens Hello.</span><span class="sxs-lookup"><span data-stu-id="467ae-216">Once the session keys are generated, all further messages can be encrypted using the private-key algorithm (e.g. AES) selected in the Hello messages.</span></span> <span data-ttu-id="467ae-217">Uma última mensagem não encriptada chamada ChangeCipherSpec é enviada pelo cliente e pelo servidor para indicar que todas as mensagens adicionais serão encriptadas.</span><span class="sxs-lookup"><span data-stu-id="467ae-217">One final un-encrypted message called ChangeCipherSpec is sent by both the client and server to indicate that all further messages will be encrypted.</span></span>

<span data-ttu-id="467ae-218">A primeira mensagem encriptada enviada pelo cliente e pelo servidor é também a mensagem final de aperto de mão TLS, chamada Finished.</span><span class="sxs-lookup"><span data-stu-id="467ae-218">The first encrypted message sent by both the client and server is also the final TLS handshake message, called Finished.</span></span> <span data-ttu-id="467ae-219">Esta mensagem contém um haxixe de todas as mensagens de aperto de mão recebidas e enviadas.</span><span class="sxs-lookup"><span data-stu-id="467ae-219">This message contains a hash of all the handshake messages received and sent.</span></span> <span data-ttu-id="467ae-220">Este haxixe é utilizado para verificar se nenhuma das mensagens no aperto de mão foi adulterada ou corrompida (indicando uma possível violação da segurança).</span><span class="sxs-lookup"><span data-stu-id="467ae-220">This hash is used to verify that none of the messages in the handshake have been tampered with or corrupted (indicating a possible breach of security).</span></span>

<span data-ttu-id="467ae-221">Uma vez recebidas as mensagens Acabadas e verificadas as hashes de aperto de mão, inicia-se a sessão TLS/DTLS e a aplicação começa a enviar e receber dados.</span><span class="sxs-lookup"><span data-stu-id="467ae-221">Once the Finished messages are received and the handshake hashes are verified, the TLS/DTLS session begins, and the application begins sending and receiving data.</span></span> <span data-ttu-id="467ae-222">Todos os dados enviados por ambos os lados durante a sessão TLS/DTLS são primeiro haxixe usando o algoritmo de haxixe escolhido nas mensagens Hello (para fornecer integridade da mensagem) e encriptado usando o algoritmo de chave privada escolhido com as teclas de sessão geradas.</span><span class="sxs-lookup"><span data-stu-id="467ae-222">All data sent by either side during the TLS/DTLS session is first hashed using the hash algorithm chosen in the Hello messages (to provide message integrity) and encrypted using the chosen private-key algorithm with the generated session keys.</span></span>

<span data-ttu-id="467ae-223">Finalmente, uma sessão TLS/DTLS só pode ser terminada com sucesso se o Cliente ou o Servidor optarem por fazê-lo.</span><span class="sxs-lookup"><span data-stu-id="467ae-223">Finally, a TLS/DTLS session can only be successfully ended if either the Client or Server chooses to do so.</span></span> <span data-ttu-id="467ae-224">Uma sessão truncada é considerada uma falha de segurança (uma vez que um intruso pode estar a tentar evitar que todos os dados sejam enviados) pelo que é enviada uma notificação especial quando ambos os lados querem terminar a sessão, chamado alerta CloseNotify.</span><span class="sxs-lookup"><span data-stu-id="467ae-224">A truncated session is considered a security breach (since an attacker may be attempting to prevent all the data being sent from being received) so a special notification is sent when either side wants to end the session, called a CloseNotify alert.</span></span> <span data-ttu-id="467ae-225">Tanto o cliente como o servidor devem enviar e processar um alerta CloseNotify para uma paragem de sessão bem sucedida.</span><span class="sxs-lookup"><span data-stu-id="467ae-225">Both the client and server must send and process a CloseNotify alert for a successful session shutdown.</span></span>

![Diagrama de uma sessão típica de aperto de mão DTLS.](media/image4.png)

<span data-ttu-id="467ae-227">**Figura 3- Aperto de mão típico do DTLS**</span><span class="sxs-lookup"><span data-stu-id="467ae-227">**Figure 3- Typical DTLS handshake**</span></span>

### <a name="initialization"></a><span data-ttu-id="467ae-228">Inicialização</span><span class="sxs-lookup"><span data-stu-id="467ae-228">Initialization</span></span>

<span data-ttu-id="467ae-229">A pilha NetX ou NetXDuo deve ser inicializada antes da utilização do DTLS NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="467ae-229">The NetX or NetXDuo stack must be initialized prior to using NetX Secure DTLS.</span></span> <span data-ttu-id="467ae-230">Consulte o Guia de Utilizador NetX ou NetXDuo para obter informações sobre como inicializar corretamente a pilha TCP/IP para a operação UDP.</span><span class="sxs-lookup"><span data-stu-id="467ae-230">Refer to the NetX or NetXDuo User Guide for information on how to properly initialize the TCP/IP stack for UDP operation.</span></span>

<span data-ttu-id="467ae-231">Uma vez inicializado o NetX UDP, o DTLS pode ser ativado.</span><span class="sxs-lookup"><span data-stu-id="467ae-231">Once NetX UDP has been initialized, DTLS can be enabled.</span></span> <span data-ttu-id="467ae-232">Internamente, todo o tráfego e processamento da rede DTLS é tratado pela stack NetX/NetXDuo sem necessidade de intervenção do utilizador.</span><span class="sxs-lookup"><span data-stu-id="467ae-232">Internally, all DTLS network traffic and processing is handled by the NetX/NetXDuo stack without requiring user intervention.</span></span> <span data-ttu-id="467ae-233">No entanto, o DTLS tem alguns requisitos específicos que devem ser tratados separadamente da pilha de rede subjacente.</span><span class="sxs-lookup"><span data-stu-id="467ae-233">However, DTLS has some specific requirements that must be handled separately from the underlying network stack.</span></span> <span data-ttu-id="467ae-234">A operação do Cliente DTLS estes parâmetros são atribuídos ao bloco de controlo DTLS chamado \***NX_SECURE_DTLS_SESSION** _.</span><span class="sxs-lookup"><span data-stu-id="467ae-234">DTLS Client operation these parameters are assigned to the DTLS control block called \***NX_SECURE_DTLS_SESSION** _.</span></span> <span data-ttu-id="467ae-235">Para a operação do DTLS Server, o bloco de controlo chama-se _ *_NX_SECURE_DTLS_SERVER_*\* e contém a infraestrutura necessária para lidar com várias sessões de DTLS numa única porta UDP – note que esta é diferente da TLS onde cada sessão de TLS está ligada a uma única porta TCP.</span><span class="sxs-lookup"><span data-stu-id="467ae-235">For DTLS Server operation, control block is called _ *_NX_SECURE_DTLS_SERVER_*\* and it contains the infrastructure needed to handle multiple DTLS sessions on a single UDP port – note that this is different from TLS where a each TLS session is bound to a single TCP port.</span></span>

<span data-ttu-id="467ae-236">Os dois modos DTLS, Server e Cliente, podem ser ativados numa aplicação (mas apenas um modo por tomada NetX), e cada um tem os seus próprios requisitos específicos, detalhados abaixo.</span><span class="sxs-lookup"><span data-stu-id="467ae-236">The two DTLS modes, Server and Client, may be enabled in an application (but only one mode per NetX socket), and each have their own specific requirements, detailed below.</span></span>

### <a name="initialization--dtls-server"></a><span data-ttu-id="467ae-237">Inicialização – DTLS Server</span><span class="sxs-lookup"><span data-stu-id="467ae-237">Initialization – DTLS Server</span></span>

<span data-ttu-id="467ae-238">O modo NetX Secure DTLS Server difere do modo TLS Server devido à utilização do UDP para o protocolo de transporte de rede subjacente.</span><span class="sxs-lookup"><span data-stu-id="467ae-238">NetX Secure DTLS Server mode differs from TLS Server mode due to the use of UDP for the underlying network transport protocol.</span></span> <span data-ttu-id="467ae-239">Com o TCP, a porta está ligada a um único hospedeiro remoto durante a sessão TLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-239">With TCP, the port is bound to a single remote host for the duration of the TLS session.</span></span> <span data-ttu-id="467ae-240">A UDP não tem noção de estado no que diz respeito ao hospedeiro remoto, pelo que os pedidos de DTLS de diferentes anfitriões serão todos recebidos na mesma interface UDP.</span><span class="sxs-lookup"><span data-stu-id="467ae-240">UDP has no notion of state with regard to the remote host so DTLS requests from different hosts will all be received on the same UDP interface.</span></span> <span data-ttu-id="467ae-241">Por conseguinte, o DTLS deve manter o estado da sessão em vez de depender da tomada como com tls e TCP.</span><span class="sxs-lookup"><span data-stu-id="467ae-241">Therefore, DTLS must maintain session state rather than relying on the socket as with TLS and TCP.</span></span> <span data-ttu-id="467ae-242">Por esta razão, o bloco de controlo do Servidor DTLS (NX_SECURE_DTLS_SERVER) mantém um mapeamento de informações remotas do anfitrião (endereço IP e porta) para sessões de DTLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-242">For this reason, the DTLS Server control block (NX_SECURE_DTLS_SERVER) maintains a mapping of remote host information (IP address and port) to DTLS sessions.</span></span> <span data-ttu-id="467ae-243">Todos os dados de entrada na tomada UDP atribuídos a um Servidor DTLS serão mapeados para uma sessão DTLS existente ou nova com base no anfitrião remoto.</span><span class="sxs-lookup"><span data-stu-id="467ae-243">All incoming data on the UDP socket assigned to a DTLS Server will be mapped to an existing or new DTLS session based on the remote host.</span></span> <span data-ttu-id="467ae-244">Por esta razão, a criação do servidor DTLS requer vários parâmetros adicionais para além do que o Cliente TLS e DTLS precisa.</span><span class="sxs-lookup"><span data-stu-id="467ae-244">For this reason, the DTLS server creation requires several additional parameters beyond what TLS and DTLS Client need.</span></span>

<span data-ttu-id="467ae-245">Além do bloco de controlo do Servidor DTLS, cifrasuites TLS e tampão de scratchspace/metadados cifra, os Servidores DTLS exigem um tampão para manter as sessões de DTLS e um tampão de montagem de pacotes usado para desencriptar registos DTLS de entrada.</span><span class="sxs-lookup"><span data-stu-id="467ae-245">In addition to the DTLS Server control block, TLS ciphersuites, and cipher scratchspace/metadata buffer, DTLS Servers require a buffer to maintain DTLS sessions and a packet reassembly buffer used to decrypt incoming DTLS records.</span></span>

<span data-ttu-id="467ae-246">Além dos amortecedores de sessão, os Servidores DTLS requerem um *Certificado Digital*, que é um documento utilizado para identificar o servidor TLS ao cliente TLS de ligação, e os certificados correspondentes *Private Key*, normalmente para o algoritmo de encriptação RSA.</span><span class="sxs-lookup"><span data-stu-id="467ae-246">In addition to the session buffers, DTLS Servers require a *Digital Certificate*, which is a document used to identify the TLS server to the connecting TLS client, and the certificates corresponding *Private Key*, usually for the RSA encryption algorithm.</span></span> <span data-ttu-id="467ae-247">A norma International Telecommunications Union X.509 especifica o formato de certificado utilizado pela TLS/DTLS e existem inúmeros utilitários para a criação de certificados digitais X.509.</span><span class="sxs-lookup"><span data-stu-id="467ae-247">The International Telecommunications Union X.509 standard specifies the certificate format used by TLS/DTLS and there are numerous utilities for creating X.509 digital certificates.</span></span>

<span data-ttu-id="467ae-248">Para o NetX Secure DTLS, o certificado X.509 deve ser codificado bináriamente utilizando o formato de Regras de Codificação (DER) distintos de ASN.1.</span><span class="sxs-lookup"><span data-stu-id="467ae-248">For NetX Secure DTLS, the X.509 certificate must be binary-encoded using the Distinguished Encoding Rules (DER) format of ASN.1.</span></span> <span data-ttu-id="467ae-249">DER é o formato binário padrão TLS over-the-wire para certificados.</span><span class="sxs-lookup"><span data-stu-id="467ae-249">DER is the standard TLS over-the-wire binary format for certificates.</span></span>

<span data-ttu-id="467ae-250">A chave privada associada ao certificado fornecido deve estar em DER-Encoded formato PKCS#1.</span><span class="sxs-lookup"><span data-stu-id="467ae-250">The private key associated with the provided certificate must be in DER-Encoded PKCS#1 format.</span></span> <span data-ttu-id="467ae-251">A chave privada é utilizada apenas no dispositivo e nunca será transmitida através do fio.</span><span class="sxs-lookup"><span data-stu-id="467ae-251">The private key is only used on the device and will never be transmitted over the wire.</span></span> <span data-ttu-id="467ae-252">Mantenha as chaves privadas seguras, pois fornecem a segurança das comunicações TLS/DTLS!</span><span class="sxs-lookup"><span data-stu-id="467ae-252">Keep private keys safe as they provide the security for TLS/DTLS communications!</span></span>

<span data-ttu-id="467ae-253">Para inicializar o certificado DTLS Server, a aplicação deve fornecer um ponteiro a um tampão contendo o certificado X.509 codificado pelo DER e dados chave privados opcionais de PKCS#1 RSA utilizando o serviço ***de nx_secure_x509_certificate_intialize,*** que povoa a estrutura **NX_SECURE_X509_CERT** com os dados de certificado apropriados para utilização por TLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-253">To initialize the DTLS Server certificate, the application must provide a pointer to a buffer containing the DER-encoded X.509 certificate and optional DER-encoded PKCS#1 RSA private key data using the ***nx_secure_x509_certificate_intialize*** service, which populates the **NX_SECURE_X509_CERT** structure with the appropriate certificate data for use by TLS.</span></span>

<span data-ttu-id="467ae-254">Uma vez inicializado o certificado do servidor, este deve ser adicionado ao bloco de controlo TLS utilizando o serviço ***nx_secure_dtls_server_local_certificate_add.***</span><span class="sxs-lookup"><span data-stu-id="467ae-254">Once the server certificate has been initialized, it must be added to the TLS control block using the ***nx_secure_dtls_server_local_certificate_add*** service.</span></span>

<span data-ttu-id="467ae-255">Uma vez adicionado o certificado do servidor ao bloco de controlo do Servidor DTLS, o servidor pode ser utilizado para comunicações DTLS seguras (ver exemplo acima).</span><span class="sxs-lookup"><span data-stu-id="467ae-255">Once the server’s certificate has been added to the DTLS Server control block, the server can be used for secure DTLS communications (see example above).</span></span>

### <a name="initialization--dtls-client"></a><span data-ttu-id="467ae-256">Inicialização – Cliente DTLS</span><span class="sxs-lookup"><span data-stu-id="467ae-256">Initialization – DTLS Client</span></span>

<span data-ttu-id="467ae-257">O modo de cliente NetX Secure DTLS é simples de funcionar em comparação com o servidor DTLS, uma vez que existe apenas uma única ligação de saída ao hospedeiro remoto sobre a tomada UDP.</span><span class="sxs-lookup"><span data-stu-id="467ae-257">NetX Secure DTLS Client mode is simple in operation compared to the DTLS server since there is only a single outgoing connection to the remote host over the UDP socket.</span></span>

<span data-ttu-id="467ae-258">Para configurar um Cliente DTLS, requer uma Loja de *Certificados Fidedignas,* que é uma coleção de certificados digitais codificados X.509 das Autoridades de Certificados Fidedignas (CA's).</span><span class="sxs-lookup"><span data-stu-id="467ae-258">To setup a DTLS Client, it requires a *Trusted Certificate Store*, which is a collection of X.509-encoded digital certificates from trusted Certificate Authorities (CA’s).</span></span> <span data-ttu-id="467ae-259">Estes certificados são assumidos pelo protocolo DTLS como "confiáveis" e servem de base para autenticar certificados fornecidos por entidades de servidores DTLS à aplicação do Cliente DTLS Seguro NetX.</span><span class="sxs-lookup"><span data-stu-id="467ae-259">These certificates are assumed by the DTLS protocol to be “trusted” and serve as the basis for authenticating certificates provided by DTLS server entities to the NetX Secure DTLS Client application.</span></span>

<span data-ttu-id="467ae-260">Um certificado de CA fidedigno pode ser *auto-assinado* ou assinado por outra AC, caso em que esse certificado é chamado de *Ac Intermediário* (ICA).</span><span class="sxs-lookup"><span data-stu-id="467ae-260">A trusted CA certificate may either be *self-signed* or signed by another CA, in which case that certificate is called an *Intermediate CA* (ICA).</span></span> <span data-ttu-id="467ae-261">Numa aplicação típica de TLS/DTLS, o servidor fornece os certificados ICA juntamente com o seu certificado de servidor, mas o único requisito para a autenticação bem sucedida é que uma cadeia de emitentes (certificados usados para assinar outros certificados) pode ser rastreada do certificado de servidor de volta para um certificado de CA fidedigno na Loja de Certificados Fidedignos.</span><span class="sxs-lookup"><span data-stu-id="467ae-261">In a typical TLS/DTLS application, the server provides the ICA certificates along with its server certificate, but the only requirement for successful authentication is that a chain of issuers (certificates used to sign other certificates) can be traced from the server certificate back to a trusted CA certificate in the Trusted Certificate Store.</span></span> <span data-ttu-id="467ae-262">Esta cadeia é conhecida como uma *cadeia de fiéis* ou cadeia de *certificados.*</span><span class="sxs-lookup"><span data-stu-id="467ae-262">This chain is known as a *chain of trust* or *certificate chain*.</span></span>

<span data-ttu-id="467ae-263">Para inicializar um certificado ca ou ica fidedigno, o pedido deve fornecer um ponteiro a um tampão contendo o certificado X.509 codificado pelo DER utilizando o serviço ***nx_secure_x509_certificate_intialize** _ que povoa a estrutura _ *NX_SECURE_X509_CERT** com os dados de certificado adequados para utilização pela TLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-263">To initialize a trusted CA or ICA certificate, the application must provide a pointer to a buffer containing the DER-encoded X.509 certificate using the ***nx_secure_x509_certificate_intialize** _ service, which populates the _ *NX_SECURE_X509_CERT** structure with the appropriate certificate data for use by TLS.</span></span>

<span data-ttu-id="467ae-264">O Cliente DTLS também precisa de espaço para que o certificado do servidor de entrada seja atribuído (assumindo que não está a ser utilizado um modo chave pré-partilhado) e um tampão para a montagem de pacotes em registos DTLS a serem desencriptados.</span><span class="sxs-lookup"><span data-stu-id="467ae-264">The DTLS Client also needs space for the incoming server certificate to be allocated (assuming a Pre-Shared Key mode is not being used) and a buffer for assembling packets into DTLS records to be decrypted.</span></span> <span data-ttu-id="467ae-265">Estes tampão são passados como parâmetros para o serviço ***nx_secure_dtls_session_create*** (ver referência API para mais informações).</span><span class="sxs-lookup"><span data-stu-id="467ae-265">These buffers are passed in as parameters to the ***nx_secure_dtls_session_create*** service (see API reference for more information).</span></span>

<span data-ttu-id="467ae-266">Os certificados fidedignos que foram inicializados são adicionados ao bloco de controlo de sessão DTLS criado utilizando o serviço ***nx_secure_dtls_session_trusted_certificate_add.***</span><span class="sxs-lookup"><span data-stu-id="467ae-266">Trusted certificates that have been initialized are then added to the created DTLS session control block using the ***nx_secure_dtls_session_trusted_certificate_add*** service.</span></span> <span data-ttu-id="467ae-267">A não adição de um certificado fará com que a sessão do Cliente DTLS falhe, uma vez que não haverá forma de o protocolo DTLS autenticar os anfitriões de servidores remotos.</span><span class="sxs-lookup"><span data-stu-id="467ae-267">Failure to add a certificate will cause the DTLS Client session to fail as there will be no way for the DTLS protocol to authenticate remote server hosts.</span></span>

<span data-ttu-id="467ae-268">Uma vez criada a Loja de Certificados Fidedignos, a sessão poderá ser utilizada para estabelecer uma ligação segura ao Cliente TLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-268">Once the Trusted Certificate Store has been created the session may be used to establish a secure TLS Client connection.</span></span>

### <a name="application-interface-calls"></a><span data-ttu-id="467ae-269">Chamadas de Interface de Aplicação</span><span class="sxs-lookup"><span data-stu-id="467ae-269">Application Interface Calls</span></span>

<span data-ttu-id="467ae-270">As aplicações DTLS NetX Secure normalmente farão chamadas de função a partir de fios de aplicação que funcionam sob o ThreadX RTOS.</span><span class="sxs-lookup"><span data-stu-id="467ae-270">NetX Secure DTLS applications will typically make function calls from within application threads running under the ThreadX RTOS.</span></span> <span data-ttu-id="467ae-271">Alguma inicialização, nomeadamente para os protocolos de comunicações de rede subjacentes (por exemplo, UDP e IP) pode ser chamada de \***tx_application_define\*.**</span><span class="sxs-lookup"><span data-stu-id="467ae-271">Some initialization, particularly for the underlying network communications protocols (e.g. UDP and IP) may be called from \***tx_application_define\*.**</span></span> <span data-ttu-id="467ae-272">Consulte o Guia do Utilizador NetX/NetXDuo para obter mais informações sobre a inicialização das comunicações de rede.</span><span class="sxs-lookup"><span data-stu-id="467ae-272">See the NetX/NetXDuo User Guide for more information on initializing network communications.</span></span>

<span data-ttu-id="467ae-273">O DTLS faz uso pesado de rotinas de encriptação que são operações intensivas de processador.</span><span class="sxs-lookup"><span data-stu-id="467ae-273">DTLS makes heavy use of encryption routines which are processor-intensive operations.</span></span> <span data-ttu-id="467ae-274">Geralmente, estas operações serão realizadas no contexto da linha de chamada.</span><span class="sxs-lookup"><span data-stu-id="467ae-274">Generally, these operations will be performed within the context of calling thread.</span></span>

### <a name="dtls-session-start"></a><span data-ttu-id="467ae-275">Início da sessão DTLS</span><span class="sxs-lookup"><span data-stu-id="467ae-275">DTLS Session Start</span></span>

<span data-ttu-id="467ae-276">O DTLS requer um protocolo de rede de camadas de transporte subjacente para funcionar.</span><span class="sxs-lookup"><span data-stu-id="467ae-276">DTLS requires an underlying transport-layer network protocol in order to function.</span></span> <span data-ttu-id="467ae-277">O protocolo normalmente utilizado é TCP.</span><span class="sxs-lookup"><span data-stu-id="467ae-277">The protocol typically used is TCP.</span></span> <span data-ttu-id="467ae-278">Para estabelecer uma sessão NetX Secure TLS, **NX_UDP_SOCKET** deve ser criada e passada para o serviço **_de nx_secure_dtls_client_session_start_** para clientes DTLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-278">In order to establish a NetX Secure TLS session an **NX_UDP_SOCKET** must be created and passed into the **_nx_secure_dtls_client_session_start_** service for DTLS Clients.</span></span>

<span data-ttu-id="467ae-279">Os Servidores DTLS funcionam de forma diferente.</span><span class="sxs-lookup"><span data-stu-id="467ae-279">DTLS Servers operate differently.</span></span> <span data-ttu-id="467ae-280">A tomada UDP utilizada para os pedidos do Cliente DTLS está contida no bloco de controlo NX_SECURE_DTLS_SERVER e é inicializada na chamada para \***nx_secure_dtls_server_create** _, que toma a porta UDP local como parâmetro.</span><span class="sxs-lookup"><span data-stu-id="467ae-280">The UDP socket used for incoming DTLS Client requests is contained within the NX_SECURE_DTLS_SERVER control block and is initialized in the call to \***nx_secure_dtls_server_create** _, which takes the local UDP port as a parameter.</span></span> <span data-ttu-id="467ae-281">O _*_nx_secure_dtls_server_start_*_ de serviço é então utilizado para iniciar o DTLS Server para lidar com pedidos de entrada.</span><span class="sxs-lookup"><span data-stu-id="467ae-281">The service _*_nx_secure_dtls_server_start_*_ is then used to start the DTLS Server to handle incoming requests.</span></span> <span data-ttu-id="467ae-282">Todos os pedidos de entrada são tratados em rotinas de retorno fornecidas a _nx_secure_dtls_server_create\*: um para ligações e outro para receber notificações. Cabe ao pedido de decisão a partir da sessão DTLS quando for recebida uma notificação de ligação (a chamada de notificação de ligação é invocada pela DTLS) ligando \***nx_secure_dtls_server_session_start**_.</span><span class="sxs-lookup"><span data-stu-id="467ae-282">All incoming requests are handled in callback routines provided to _nx_secure_dtls_server_create\*: one for connections and one for receive notifications. It is up to the application to handle starting the DTLS session when a connection notification is received (the connect notify callback is invoked by DTLS) by calling \***nx_secure_dtls_server_session_start**_.</span></span> <span data-ttu-id="467ae-283">A aplicação também deve tratar os dados de entrada quando a chamada de notificação recebida for invocada (que segue um aperto de mão DTLS completo) chamando _\*_nx_secure_dtls_session_receive_\*\*.</span><span class="sxs-lookup"><span data-stu-id="467ae-283">The application also must handle incoming data when the receive notify callback is invoked (which follows a completed DTLS handshake) by calling _\*_nx_secure_dtls_session_receive_\*\*.</span></span> <span data-ttu-id="467ae-284">Os pormenores deste facto são fornecidos no exemplo acima referido e na referência da API para cada um dos serviços acima mencionados.</span><span class="sxs-lookup"><span data-stu-id="467ae-284">The details of this are provided in the example above and in the API reference for each of the above mentioned services.</span></span>

### <a name="dtls-packet-allocation"></a><span data-ttu-id="467ae-285">Alocação de pacotes DTLS</span><span class="sxs-lookup"><span data-stu-id="467ae-285">DTLS Packet Allocation</span></span>

<span data-ttu-id="467ae-286">O NetX Secure DTLS utiliza a mesma estrutura de pacotes que o NetX/NetXDuo TCP (***NX_PACKET** _) exceto que, em vez de ligar para o serviço _*_nx_packet_allocate,_*_ o serviço _ *_nx_secure_dtls_packet_allocate_** deve ser chamado para que o espaço para o cabeçalho DTLS possa ser devidamente atribuído.</span><span class="sxs-lookup"><span data-stu-id="467ae-286">NetX Secure DTLS uses the same packet structure as NetX/NetXDuo TCP (***NX_PACKET** _) except that instead of calling the _*_nx_packet_allocate_*_ service, the _ *_nx_secure_dtls_packet_allocate_** service must be called so that space for the DTLS header may be allocated properly.</span></span>

### <a name="dtls-session-send"></a><span data-ttu-id="467ae-287">DTLS Sessão Enviar</span><span class="sxs-lookup"><span data-stu-id="467ae-287">DTLS Session Send</span></span>

<span data-ttu-id="467ae-288">Uma vez iniciada a sessão TLS, a aplicação poderá enviar dados utilizando o serviço ***nx_secure_dtls_session_send.***</span><span class="sxs-lookup"><span data-stu-id="467ae-288">Once the TLS session has started, the application may send data using the ***nx_secure_dtls_session_send*** service.</span></span> <span data-ttu-id="467ae-289">O serviço de envio é idêntico em uso ao serviço ***nx_udp_socket_send** _, tomando uma estrutura de dados _ *_NX_PACKET_** contendo os dados enviados, um endereço IP alvo e uma porta UDP alvo.</span><span class="sxs-lookup"><span data-stu-id="467ae-289">The send service is identical in use to the ***nx_udp_socket_send** _ service, taking an _ *_NX_PACKET_** data structure containing the data being sent, a target IP address, and a target UDP port.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="467ae-290">Ao enviar dados utilizando nx_secure_dtls_session_send, é importante utilizar o mesmo endereço IP e porta que foram utilizados para estabelecer a sessão DTLS, a menos que exista um mecanismo para mover a sessão para um novo endereço e porta UDP on-the-fly (isto não é comum).</span><span class="sxs-lookup"><span data-stu-id="467ae-290">When sending data using nx_secure_dtls_session_send, it is important to use the same IP address and port that were used to establish the DTLS session, unless there is a mechanism in place to move the session to a new address and UDP port on-the-fly (this is not common).</span></span>

<span data-ttu-id="467ae-291">Quaisquer dados enviados através do DTLS serão encriptados pela pilha NX Secure DTLS e pelas rotinas de encriptação configuradas antes de serem enviados.</span><span class="sxs-lookup"><span data-stu-id="467ae-291">Any data sent over DTLS will be encrypted by the NX Secure DTLS stack and the configured encryption routines before being sent.</span></span>

### <a name="dtls-session-receive"></a><span data-ttu-id="467ae-292">Sessão DTLS receber</span><span class="sxs-lookup"><span data-stu-id="467ae-292">DTLS Session Receive</span></span>

<span data-ttu-id="467ae-293">Uma vez iniciada a sessão DTLS, a aplicação pode começar a receber dados utilizando o serviço \***nx_secure_Dtls_session_receive** _ .</span><span class="sxs-lookup"><span data-stu-id="467ae-293">Once the DTLS session has started, the application may begin receiving data using the \***nx_secure_Dtls_session_receive** _ service.</span></span> <span data-ttu-id="467ae-294">Tal como a Sessão DTLS envia, este serviço é idêntico em uso para _\*_nx_udp_socket_receive_\*\*, exceto que os dados de entrada são desencriptados e verificados pela pilha DTLS antes de serem devolvidos na estrutura do pacote.</span><span class="sxs-lookup"><span data-stu-id="467ae-294">Like the DTLS Session send, this service is identical in use to _\*_nx_udp_socket_receive_\*\*, except that the incoming data is decrypted and verified by the DTLS stack before being returned in the packet structure.</span></span>

### <a name="tls-session-close"></a><span data-ttu-id="467ae-295">Sessão TLS fechar</span><span class="sxs-lookup"><span data-stu-id="467ae-295">TLS Session Close</span></span>

<span data-ttu-id="467ae-296">Uma vez concluída uma sessão DTLS, tanto o cliente DTLS como o servidor devem enviar um alerta CloseNotify para o outro lado para encerrar a sessão.</span><span class="sxs-lookup"><span data-stu-id="467ae-296">Once a DTLS session is complete, both the DTLS client and server must send a CloseNotify alert to the other side to shut down the session.</span></span> <span data-ttu-id="467ae-297">Ambas as partes devem receber e processar o alerta para garantir uma paragem de sessão bem sucedida.</span><span class="sxs-lookup"><span data-stu-id="467ae-297">Both sides must receive and process the alert to ensure a successful session shutdown.</span></span>

<span data-ttu-id="467ae-298">Se o anfitrião remoto enviar um alerta CloseNotify, qualquer chamada para o serviço ***nx_secure_dtls_session_receive** _ processará o alerta, enviará o alerta correspondente de volta para o hospedeiro remoto e devolverá um valor de _*_NX_SECURE_TLS_SESSION_CLOSED_\*\*.</span><span class="sxs-lookup"><span data-stu-id="467ae-298">If the remote host sends a CloseNotify alert, any calls to the ***nx_secure_dtls_session_receive** _ service will process the alert, send the corresponding alert back to the remote host, and return a value of _*_NX_SECURE_TLS_SESSION_CLOSED_\*\*.</span></span> <span data-ttu-id="467ae-299">Uma vez encerrada a sessão, quaisquer outras tentativas de enviar ou receber dados com essa sessão DTLS falharão.</span><span class="sxs-lookup"><span data-stu-id="467ae-299">Once the session is closed, any further attempts to send or receive data with that DTLS session will fail.</span></span>

<span data-ttu-id="467ae-300">Se a aplicação pretender encerrar a sessão TLS, o serviço \***nx_secure_dtls_session_end** _ deve ser chamado.</span><span class="sxs-lookup"><span data-stu-id="467ae-300">If the application wishes to close the TLS session, the \***nx_secure_dtls_session_end** _ service must be called.</span></span> <span data-ttu-id="467ae-301">O serviço enviará o alerta CloseNotify e processará a resposta CloseNotify.</span><span class="sxs-lookup"><span data-stu-id="467ae-301">The service will send the CloseNotify alert and process the response CloseNotify.</span></span> <span data-ttu-id="467ae-302">Se a resposta não for recebida, será devolvido um valor de erro de _ *_NX_SECURE_TLS_SESSION_CLOSE_FAIL_*\* indicando que a sessão DTLS não foi totalmente encerrada, uma possível falha de segurança.</span><span class="sxs-lookup"><span data-stu-id="467ae-302">If the response is not received, an error value of _ *_NX_SECURE_TLS_SESSION_CLOSE_FAIL_*\* will be returned, indicating that the DTLS session was not cleanly shutdown, a possible security breach.</span></span>

### <a name="tlsdtls-alerts"></a><span data-ttu-id="467ae-303">Alertas TLS/DTLS</span><span class="sxs-lookup"><span data-stu-id="467ae-303">TLS/DTLS Alerts</span></span>

<span data-ttu-id="467ae-304">TLS/DTLS é projetado para fornecer a máxima segurança, por isso qualquer comportamento errante no protocolo é considerado uma potencial violação de segurança.</span><span class="sxs-lookup"><span data-stu-id="467ae-304">TLS/DTLS is designed to provide maximum security, so any errant behavior in the protocol is considered a potential security breach.</span></span> <span data-ttu-id="467ae-305">Por esta razão, quaisquer erros no processamento de mensagens ou encriptação/desencriptação são considerados erros fatais que terminam o aperto de mão ou a sessão imediatamente.</span><span class="sxs-lookup"><span data-stu-id="467ae-305">For this reason, any errors in message processing or encryption/decryption are considered fatal errors that terminate the handshake or session immediately.</span></span>

<span data-ttu-id="467ae-306">Embora os erros de manuseamento de uma aplicação local sejam relativamente simples, o anfitrião remoto precisa de saber que ocorreu um erro para lidar adequadamente com a situação e evitar eventuais possíveis falhas de segurança.</span><span class="sxs-lookup"><span data-stu-id="467ae-306">While handling errors in a local application is relatively straightforward, the remote host needs to know that an error has occurred in order to properly handle the situation and prevent any further possible security breaches.</span></span> <span data-ttu-id="467ae-307">Por esta razão, o TLS/DTLS enviará uma mensagem *de alerta* ao anfitrião remoto em qualquer erro.</span><span class="sxs-lookup"><span data-stu-id="467ae-307">For this reason, TLS/DTLS will send an *Alert* message to the remote host upon any error.</span></span>

<span data-ttu-id="467ae-308">Os alertas são tratados da mesma forma que qualquer outra mensagem TLS/DTLS e são encriptados durante a sessão para impedir que um intruso recolha informações do tipo de alerta fornecido.</span><span class="sxs-lookup"><span data-stu-id="467ae-308">Alerts are treated in the same manner as any other TLS/DTLS messages and are encrypted during the session to prevent an attacker from gathering information from the type of alert provided.</span></span> <span data-ttu-id="467ae-309">Durante o aperto de mão, os alertas enviados são limitados no âmbito para limitar a quantidade de informação que poderia ser obtida por um potencial atacante.</span><span class="sxs-lookup"><span data-stu-id="467ae-309">During the handshake, the alerts sent are limited in scope to limit the amount of information that could be obtained by a potential attacker.</span></span>

<span data-ttu-id="467ae-310">O alerta CloseNotify, usado para encerrar a sessão TLS/DTLS, é o único alerta não fatal.</span><span class="sxs-lookup"><span data-stu-id="467ae-310">The CloseNotify alert, used to close the TLS/DTLS session, is the only non-fatal alert.</span></span> <span data-ttu-id="467ae-311">Embora seja considerado um alerta e enviado como uma mensagem de alerta, um CloseNotify é diferente de outros alertas na medida em que não indica que tenha ocorrido um erro.</span><span class="sxs-lookup"><span data-stu-id="467ae-311">While it is considered an alert and sent as an alert message, a CloseNotify is unlike other alerts in that it does not indicate an error has occurred.</span></span>

### <a name="tlsdtls-session-renegotiation-and-resumption"></a><span data-ttu-id="467ae-312">TLS/DTLS Sessão renegociação e retoma</span><span class="sxs-lookup"><span data-stu-id="467ae-312">TLS/DTLS Session Renegotiation and Resumption</span></span>

<span data-ttu-id="467ae-313">O TLS apoia a noção de "renegociação" que é simplesmente uma renegociação dos parâmetros da sessão TLS no contexto de uma sessão TLS existente.</span><span class="sxs-lookup"><span data-stu-id="467ae-313">TLS supports the notion of “renegotiation” which is simply a renegotiation of the TLS session parameters within the context of an existing TLS session.</span></span>

<span data-ttu-id="467ae-314">O *reinício da* sessão TLS não deve ser confundido com *a renegociação* da sessão , apesar de algumas semelhanças.</span><span class="sxs-lookup"><span data-stu-id="467ae-314">TLS session *resumption* should not be confused with session *renegotiation*, despite some similarities.</span></span> <span data-ttu-id="467ae-315">Onde a *renegociação* da sessão envolve iniciar um novo aperto de mão dentro de uma sessão TLS existente, *o recomeço da* sessão é uma característica puramente opcional que envolve reiniciar uma sessão de TLS fechada sem realizar um aperto de mão TLS completo.</span><span class="sxs-lookup"><span data-stu-id="467ae-315">Where session *renegotiation* involves starting a new handshake within an existing TLS session, session *resumption* is a purely optional feature that involves restarting a closed TLS session without performing a complete TLS handshake.</span></span>

<span data-ttu-id="467ae-316">O NX Secure DTLS lida com pedidos de renegociação de anfitriões remotos.</span><span class="sxs-lookup"><span data-stu-id="467ae-316">NX Secure DTLS handles incoming renegotiation requests from remote hosts.</span></span> <span data-ttu-id="467ae-317">**Não** suporta o reinício da sessão.</span><span class="sxs-lookup"><span data-stu-id="467ae-317">It does **not** support session resumption.</span></span> <span data-ttu-id="467ae-318">Uma discussão mais completa destas funcionalidades pode ser encontrada no Capítulo 3 do Guia do Utilizador NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-318">A more complete discussion of these features can be found in Chapter 3 of the NetX Secure TLS User Guide.</span></span>

### <a name="protocol-layering"></a><span data-ttu-id="467ae-319">Camada de protocolo</span><span class="sxs-lookup"><span data-stu-id="467ae-319">Protocol Layering</span></span>

<span data-ttu-id="467ae-320">O protocolo TLS (e, portanto, também dTLS) encaixa na pilha de rede entre a camada de transporte (por exemplo, TCP ou UDP) e a camada de aplicação.</span><span class="sxs-lookup"><span data-stu-id="467ae-320">The TLS protocol (and therefore DTLS as well) fits into the networking stack between the transport layer (e.g. TCP or UDP) and the application layer.</span></span> <span data-ttu-id="467ae-321">O TLS é por vezes considerado um protocolo de camada de transporte (daí a Segurança *da Camada de Transporte),* mas porque atua como uma aplicação no que diz respeito aos protocolos de rede subjacentes, é por vezes agrupado na camada de aplicação.</span><span class="sxs-lookup"><span data-stu-id="467ae-321">TLS is sometimes considered a transport-layer protocol (hence *Transport Layer* Security) but because it acts as an application with regard to the underlying network protocols it is sometimes grouped into the application layer.</span></span>

<span data-ttu-id="467ae-322">O TLS requer um protocolo de camada de transporte que suporte a entrega em ordem e sem perdas, como o TCP.</span><span class="sxs-lookup"><span data-stu-id="467ae-322">TLS requires a transport layer protocol that supports in-order and lossless delivery, such as TCP.</span></span> <span data-ttu-id="467ae-323">Devido a este requisito, o TLS não pode funcionar em cima da UDP, uma vez que a UDP não garante a entrega de datagramas.</span><span class="sxs-lookup"><span data-stu-id="467ae-323">Due to this requirement, TLS cannot run on top of UDP since UDP does not guarantee delivery of datagrams.</span></span> <span data-ttu-id="467ae-324">*DTLS* é uma versão modificada do TLS, é usada para aplicações que precisam da segurança de TLS sobre um protocolo de datagrama como uDP.</span><span class="sxs-lookup"><span data-stu-id="467ae-324">*DTLS* is a modified version of TLS, is used for applications that need the security of TLS over a datagram protocol like UDP.</span></span>

![Diagrama de uma camada de protocolo TLS.](media/image6.png)

<span data-ttu-id="467ae-326">**Figura 4- TCP/IP, UDP e TLS/DTLS**</span><span class="sxs-lookup"><span data-stu-id="467ae-326">**Figure 4- TCP/IP, UDP and TLS/DTLS protocol layers**</span></span>

## <a name="network-communications-security-and-encryption"></a><span data-ttu-id="467ae-327">Segurança e Encriptação de Comunicações de Rede</span><span class="sxs-lookup"><span data-stu-id="467ae-327">Network Communications Security and Encryption</span></span>

<span data-ttu-id="467ae-328">A segurança das comunicações através das redes públicas e da Internet é um tema de extrema importância e tema de um vasto número de livros, artigos e soluções.</span><span class="sxs-lookup"><span data-stu-id="467ae-328">Securing communications over public networks and the Internet is a critically important topic and the subject of vast numbers of books, articles, and solutions.</span></span> <span data-ttu-id="467ae-329">O tema é incrivelmente complexo, mas pode ser reduzido a uma ideia simples: enviar informação por uma rede para que apenas o alvo pretendido possa aceder ou alterar essa informação.</span><span class="sxs-lookup"><span data-stu-id="467ae-329">The topic is mind-bogglingly complex, but can be reduced to a simple idea: sending information over a network so that only the intended target can access or change that information.</span></span> <span data-ttu-id="467ae-330">Isto divide-se em três conceitos importantes: sigilo, integridade e autenticação.</span><span class="sxs-lookup"><span data-stu-id="467ae-330">This breaks down into three important concepts: secrecy, integrity, and authentication.</span></span> <span data-ttu-id="467ae-331">O protocolo TLS/DTLS fornece soluções para os três.</span><span class="sxs-lookup"><span data-stu-id="467ae-331">The TLS/DTLS protocol provides solutions for all three.</span></span>

<span data-ttu-id="467ae-332">A encriptação é usada de diferentes formas para fornecer sigilo, integridade e autenticação dentro dos protocolos TLS e DTLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-332">Encryption is used in different ways to provide secrecy, integrity, and authentication within the TLS and DTLS protocols.</span></span> <span data-ttu-id="467ae-333">A encriptação deve ser fornecida ao TLS ou DTLS após a criação de uma sessão ou instância de servidor, uma vez que o TLS fornece uma estrutura flexível para o uso da encriptação e não a encriptação em si.</span><span class="sxs-lookup"><span data-stu-id="467ae-333">The encryption must be supplied to TLS or DTLS upon creation of a session or server instance as TLS provides a flexible framework for using encryption and not the encryption itself.</span></span> <span data-ttu-id="467ae-334">O NetX Secure DTLS fornece as rotinas de encriptação necessárias para a maioria das aplicações, pelo que não tem de se preocupar em encontrar encriptação adequada.</span><span class="sxs-lookup"><span data-stu-id="467ae-334">NetX Secure DTLS provides the necessary encryption routines for most applications so you do not have to be concerned about finding appropriate encryption.</span></span>

<span data-ttu-id="467ae-335">Uma descrição mais detalhada destes tópicos pode ser encontrada no capítulo 3 do Guia do Utilizador NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-335">A more detailed description of these topics can be found in Chapter 3 of the NetX Secure TLS User Guide.</span></span>

## <a name="tls-and-dtls-extensions"></a><span data-ttu-id="467ae-336">Extensões TLS e DTLS</span><span class="sxs-lookup"><span data-stu-id="467ae-336">TLS and DTLS Extensions</span></span>

<span data-ttu-id="467ae-337">O TLS (e, portanto, o DTLS) fornece uma série de extensões que fornecem funcionalidades adicionais para determinadas aplicações.</span><span class="sxs-lookup"><span data-stu-id="467ae-337">TLS (and therefore DTLS) provides a number of extensions that provide additional functionality for certain applications.</span></span> <span data-ttu-id="467ae-338">Estas extensões são normalmente enviadas como parte das mensagens ClientHello ou ServerHello, indicando a um anfitrião remoto o desejo de usar uma extensão ou fornecer detalhes adicionais para uso no estabelecimento da sessão TLS segura.</span><span class="sxs-lookup"><span data-stu-id="467ae-338">These extensions are typically sent as part of the ClientHello or ServerHello messages, indicating to a remote host the desire to use an extension or providing additional details for use in establishing the secure TLS session.</span></span>

<span data-ttu-id="467ae-339">O NetX Secure DTLS suporta todas as extensões encontradas no NetX Secure TLS, e uma descrição completa delas pode ser encontrada no Guia de Utilizador NetX Secure TLS, Capítulo 3.</span><span class="sxs-lookup"><span data-stu-id="467ae-339">NetX Secure DTLS supports all of the extensions found in NetX Secure TLS, and a complete description of those can be found in the NetX Secure TLS User Guide, Chapter 3.</span></span>

## <a name="authentication-methods"></a><span data-ttu-id="467ae-340">Métodos de Autenticação</span><span class="sxs-lookup"><span data-stu-id="467ae-340">Authentication Methods</span></span>

<span data-ttu-id="467ae-341">O TLS e o DTLS fornecem o quadro para estabelecer uma ligação segura entre dois dispositivos através de uma rede insegura, mas parte do problema é saber a identidade do dispositivo na outra extremidade dessa ligação.</span><span class="sxs-lookup"><span data-stu-id="467ae-341">TLS and DTLS provide the framework for establishing a secure connection between two devices over an insecure network, but part of the problem is knowing the identity of the device on the other end of that connection.</span></span> <span data-ttu-id="467ae-342">Sem um mecanismo para autenticar a identidade dos anfitriões remotos, torna-se uma operação trivial para um intruso fazer-se passar por um dispositivo de confiança.</span><span class="sxs-lookup"><span data-stu-id="467ae-342">Without a mechanism for authenticating the identity of remote hosts, it becomes a trivial operation for an attacker to pose as a trusted device.</span></span>

<span data-ttu-id="467ae-343">Inicialmente, pode parecer que a utilização de endereços IP, endereços MAC de hardware ou DNS forneceria um nível de confiança relativamente elevado para identificar os anfitriões numa rede, mas dada a natureza da tecnologia TCP/IP e a facilidade com que os endereços podem ser falsificados e as entradas de DNS corrompidas (por exemplo, através do envenenamento por cache DNS), torna-se claro que o TLS precisa de uma camada adicional de proteção contra identidades fraudulentas.</span><span class="sxs-lookup"><span data-stu-id="467ae-343">Initially, it may seem that using IP addresses, hardware MAC addresses, or DNS would provide a relatively high level of confidence for identifying hosts on a network, but given the nature of TCP/IP technology and the ease with which addresses can be spoofed and DNS entries corrupted (e.g. through DNS cache poisoning), it becomes clear that TLS needs an additional layer of protection against fraudulent identities.</span></span>

<span data-ttu-id="467ae-344">Existem vários mecanismos que podem fornecer esta camada extra de autenticação para TLS, mas o mais comum é o *certificado digital.*</span><span class="sxs-lookup"><span data-stu-id="467ae-344">There are various mechanisms that can provide this extra layer of authentication for TLS, but the most common is the *digital certificate.*</span></span> <span data-ttu-id="467ae-345">Outros mecanismos incluem chaves pré-partilhadas (PSK) e esquemas de senha.</span><span class="sxs-lookup"><span data-stu-id="467ae-345">Other mechanisms include Pre-Shared Keys (PSK) and password schemes.</span></span>

### <a name="digital-cerificates"></a><span data-ttu-id="467ae-346">Cerifas digitais</span><span class="sxs-lookup"><span data-stu-id="467ae-346">Digital Cerificates</span></span>

<span data-ttu-id="467ae-347">Os certificados digitais são o método mais comum para autenticar um hospedeiro remoto em TLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-347">Digital certificates are the most common method for authenticating a remote host in TLS.</span></span> <span data-ttu-id="467ae-348">Essencialmente, um certificado digital é um documento com formatação específica que fornece informações de identidade para um dispositivo numa rede de computador.</span><span class="sxs-lookup"><span data-stu-id="467ae-348">Essentially, a digital certificate is a document with specific formatting that provides identity information for a device on a computer network.</span></span>

<span data-ttu-id="467ae-349">O TLS normalmente usa um formato chamado X.509, uma norma desenvolvida pela União Internacional de Telecomunicações, embora outros formatos de certificados possam ser usados se os anfitriões TLS puderem concordar com o formato que está a ser utilizado.</span><span class="sxs-lookup"><span data-stu-id="467ae-349">TLS normally uses a format called X.509, a standard developed by the International Telecommunication Union, though other formats of certificates may be used if the TLS hosts can agree on the format being used.</span></span> <span data-ttu-id="467ae-350">X.509 define um formato específico para certificados e várias codificações que podem ser usadas para produzir um documento digital.</span><span class="sxs-lookup"><span data-stu-id="467ae-350">X.509 defines a specific format for certificates and various encodings that can be used to produce a digital document.</span></span> <span data-ttu-id="467ae-351">A maioria dos certificados X.509 utilizados com TLS são codificados usando uma variante de ASN.1, outra norma de telecomunicações.</span><span class="sxs-lookup"><span data-stu-id="467ae-351">Most X.509 certificates used with TLS are encoded using a variant of ASN.1, another telecommunications standard.</span></span> <span data-ttu-id="467ae-352">Dentro da ASN.1 existem várias codificações digitais, mas a codificação mais comum para certificados TLS é a norma de codificação distinguida (DER).</span><span class="sxs-lookup"><span data-stu-id="467ae-352">Within ASN.1 there are various digital encodings, but the most common encoding for TLS certificates is the Distinguished Encoding Rules (DER) standard.</span></span> <span data-ttu-id="467ae-353">O DER é um subconjunto simplificado das Regras Básicas de Codificação (BER) as ASN.1 que são concebidas para ser inequívocas, facilitando a análise.</span><span class="sxs-lookup"><span data-stu-id="467ae-353">DER is a simplified subset of the ASN.1 Basic Encoding Rules (BER) that is designed to be unambiguous, making parsing easier.</span></span> <span data-ttu-id="467ae-354">Por cima do fio, os certificados TLS são geralmente codificados em DER binário, e este é o formato que o NetX Secure espera para os certificados X.509.</span><span class="sxs-lookup"><span data-stu-id="467ae-354">Over the wire, TLS certificates are usually encoded in binary DER, and this is the format that NetX Secure expects for X.509 certificates.</span></span>

<span data-ttu-id="467ae-355">Embora os certificados binários formatados pelo DER sejam utilizados no protocolo TLS real, podem ser gerados e armazenados em várias codificações diferentes, com extensões de ficheiros tais como .pem, .crt e .p12.</span><span class="sxs-lookup"><span data-stu-id="467ae-355">Though DER-formatted binary certificates are used in the actual TLS protocol, they may be generated and stored in a number of different encodings, with file extensions such as .pem, .crt, and .p12.</span></span> <span data-ttu-id="467ae-356">As diferentes variantes são usadas por diferentes aplicações de diferentes fabricantes, mas geralmente todas podem ser convertidas em DER usando ferramentas amplamente disponíveis.</span><span class="sxs-lookup"><span data-stu-id="467ae-356">The different variants are used by different applications from different manufacturers, but generally all can be converted into DER using widely available tools.</span></span>

<span data-ttu-id="467ae-357">A mais comum das codificações de certificados alternativos é o PEM.</span><span class="sxs-lookup"><span data-stu-id="467ae-357">The most common of the alternative certificate encodings is PEM.</span></span> <span data-ttu-id="467ae-358">O formato PEM (a partir do Privacy-Enhanced Mail) é uma versão codificada base-64 da codificação DER que é frequentemente utilizada porque a codificação resulta em texto imprimível que pode ser facilmente enviado usando protocolos de e-mail ou web.</span><span class="sxs-lookup"><span data-stu-id="467ae-358">The PEM format (from Privacy-Enhanced Mail) is a base-64 encoded version of the DER encoding that is often used because the encoding results in printable text that can be easily sent using email or web-based protocols.</span></span>

<span data-ttu-id="467ae-359">Gerar um certificado para a sua aplicação NetX Secure está geralmente fora do âmbito deste manual, mas a ferramenta de linha de comando OpenSSL[(www.openssl.org)](http://www.openssl.org)está amplamente disponível e pode converter entre a maioria dos formatos.</span><span class="sxs-lookup"><span data-stu-id="467ae-359">Generating a certificate for your NetX Secure application is generally outside the scope of this manual, but the OpenSSL command-line tool ([www.openssl.org](http://www.openssl.org)) is widely available and can convert between most formats.</span></span>

<span data-ttu-id="467ae-360">Dependendo da sua aplicação, poderá gerar os seus próprios certificados, ser fornecido certificados por um fabricante ou organização governamental, ou adquirir certificados a uma autoridade de certificados comerciais.</span><span class="sxs-lookup"><span data-stu-id="467ae-360">Depending on your application, you may generate your own certificates, be provided certificates by a manufacturer or government organization, or purchase certificates from a commercial certificate authority.</span></span>

<span data-ttu-id="467ae-361">Para utilizar um certificado digital na sua aplicação NetX Secure, tem primeiro de converter o seu certificado num formato binário DER e, opcionalmente, converter a chave privada associada (o "expoente privado" para rSA, por exemplo) num formato binário, tipicamente uma chave RSA codificada por PKCS#1- der-codificada.</span><span class="sxs-lookup"><span data-stu-id="467ae-361">To use a digital certificate in your NetX Secure application, you must first convert your certificate into a binary DER format and, optionally, convert the associated private key (the “private exponent” for RSA, for example) into a binary format, typically a PKCS#1-formatted, DER-encoded RSA key.</span></span> <span data-ttu-id="467ae-362">Uma vez concluída a conversão, cabe-lhe a si carregar o certificado e a chave privada no dispositivo.</span><span class="sxs-lookup"><span data-stu-id="467ae-362">Once the conversion is complete, it is up to you to load the certificate and private key onto the device.</span></span> <span data-ttu-id="467ae-363">As opções possíveis incluem a utilização de um sistema de ficheiros baseado em flash ou a geração de um conjunto C a partir dos dados (utilizando uma ferramenta como "xxd" do Linux) e a compilação do certificado e chave na sua aplicação como dados constantes.</span><span class="sxs-lookup"><span data-stu-id="467ae-363">Possible options include using a flash-based file system or generating a C array from the data (using a tool such as “xxd” from Linux) and compiling the certificate and key into your application as constant data.</span></span>

<span data-ttu-id="467ae-364">Uma vez que o seu certificado é carregado no dispositivo, a API DTLS pode ser usada para associar o seu certificado a uma sessão ou servidor DTLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-364">Once your certificate is loaded onto the device, the DTLS API can be used to associate your certificate with a DTLS session or server.</span></span>

<span data-ttu-id="467ae-365">Para mais detalhes e exemplos sobre como utilizar certificados X.509 com DTLS NetX Secure, consulte a secção "Importar certificados X.509 em NetX Secure" no Guia de Utilizador NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-365">For details and examples on how to use X.509 certificates with NetX Secure DTLS, see the section “Importing X.509 certificates into NetX Secure” in the NetX Secure TLS User Guide.</span></span>

<span data-ttu-id="467ae-366">Consulte os seguintes serviços DTLS na referência API para obter mais informações:</span><span class="sxs-lookup"><span data-stu-id="467ae-366">Refer to the following DTLS services in the API reference for more information:</span></span>

- <span data-ttu-id="467ae-367">nx_secure_x509_certificate_initialize,</span><span class="sxs-lookup"><span data-stu-id="467ae-367">nx_secure_x509_certificate_initialize,</span></span>
- <span data-ttu-id="467ae-368">nx_secure_dtls_session_local_certificate_add,</span><span class="sxs-lookup"><span data-stu-id="467ae-368">nx_secure_dtls_session_local_certificate_add,</span></span>
- <span data-ttu-id="467ae-369">nx_secure_dtls_server_local_certificate_add,</span><span class="sxs-lookup"><span data-stu-id="467ae-369">nx_secure_dtls_server_local_certificate_add,</span></span>
- <span data-ttu-id="467ae-370">nx_secure_dtls_session_local_certificate_remove,</span><span class="sxs-lookup"><span data-stu-id="467ae-370">nx_secure_dtls_session_local_certificate_remove,</span></span>
- <span data-ttu-id="467ae-371">nx_secure_dtls_server_local_certificate_remove,</span><span class="sxs-lookup"><span data-stu-id="467ae-371">nx_secure_dtls_server_local_certificate_remove,</span></span>
- <span data-ttu-id="467ae-372">nx_secure_dtls_session_trusted_certificate_add,</span><span class="sxs-lookup"><span data-stu-id="467ae-372">nx_secure_dtls_session_trusted_certificate_add,</span></span>
- <span data-ttu-id="467ae-373">nx_secure_dtls_server_trusted_certificate_add,</span><span class="sxs-lookup"><span data-stu-id="467ae-373">nx_secure_dtls_server_trusted_certificate_add,</span></span>
- <span data-ttu-id="467ae-374">nx_secure_dtls_session_trusted_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="467ae-374">nx_secure_dtls_session_trusted_certificate_remove</span></span>
- <span data-ttu-id="467ae-375">nx_secure_dtls_server_trusted_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="467ae-375">nx_secure_dtls_server_trusted_certificate_remove</span></span>

### <a name="tls-client-certificate-specifics"></a><span data-ttu-id="467ae-376">Especificidades do Certificado de Cliente TLS</span><span class="sxs-lookup"><span data-stu-id="467ae-376">TLS Client Certificate Specifics</span></span>

<span data-ttu-id="467ae-377">As implementações do Cliente DTLS geralmente não requerem que um certificado local seja carregado no dispositivo.</span><span class="sxs-lookup"><span data-stu-id="467ae-377">DTLS Client implementations generally do not require a local certificate to be loaded onto the device.</span></span> <span data-ttu-id="467ae-378">Um certificado local é um certificado que identifica o dispositivo local.</span><span class="sxs-lookup"><span data-stu-id="467ae-378">A local certificate is a certificate that identifies the local device.</span></span> <span data-ttu-id="467ae-379">Especificamente, um certificado local fornece informações de identidade para o dispositivo sobre o qual a aplicação TLS/DTLS é carregada.</span><span class="sxs-lookup"><span data-stu-id="467ae-379">Specifically, a local certificate provides identity information for the device upon which the TLS/DTLS application is loaded.</span></span> <span data-ttu-id="467ae-380">A exceção a isso é quando a Autenticação do Certificado de Cliente está ativada, mas isso é menos comum.</span><span class="sxs-lookup"><span data-stu-id="467ae-380">The exception to this is when Client Certificate Authentication is enabled, but this is less common.</span></span>

<span data-ttu-id="467ae-381">Um Cliente DTLS requer que pelo menos um certificado de confiança seja carregado (mais pode ser carregado se necessário) e espaço para a atribuição de um certificado remoto.</span><span class="sxs-lookup"><span data-stu-id="467ae-381">A DTLS Client requires at least one trusted certificate to be loaded (more may be loaded if required), and space for a remote certificate to be allocated.</span></span> <span data-ttu-id="467ae-382">Um certificado de confiança é um certificado que fornece uma base de confiança e autenticação do dispositivo remoto, quer diretamente quer através de uma Infraestrutura de Chave Pública (PKI).</span><span class="sxs-lookup"><span data-stu-id="467ae-382">A trusted certificate is a certificate that provides a basis for trust and authentication of the remote device, either directly or through a Public Key Infrastructure (PKI).</span></span> <span data-ttu-id="467ae-383">A raiz da cadeia de confiança é geralmente chamada de Autoridade de Certificação ou certificado de CA.</span><span class="sxs-lookup"><span data-stu-id="467ae-383">The root of the chain of trust is usually called a Certification Authority or CA certificate.</span></span> <span data-ttu-id="467ae-384">Um certificado remoto refere-se ao certificado enviado pelo anfitrião remoto durante o aperto de mão TLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-384">A remote certificate refers to the certificate sent by the remote host during the TLS handshake.</span></span> <span data-ttu-id="467ae-385">Fornece identidade para o hospedeiro remoto e é autenticado comparando-o com um certificado de confiança no dispositivo local.</span><span class="sxs-lookup"><span data-stu-id="467ae-385">It provides identity for that remote host and is authenticated by comparing it to a trusted certificate on the local device.</span></span>

<span data-ttu-id="467ae-386">Para obter mais informações sobre a adição de certificados fidedignos e a atribuição de espaço para certificados remotos, consulte a referência TLS API para os seguintes serviços: nx_secure_dtls_session_create, nx_secure_dtls_session_trusted_certificate_add.</span><span class="sxs-lookup"><span data-stu-id="467ae-386">For more information on adding trusted certificates and allocating space for remote certificates, see the TLS API reference for the following services: nx_secure_dtls_session_create, nx_secure_dtls_session_trusted_certificate_add.</span></span>

### <a name="tlsdtls-server-certificate-specifics"></a><span data-ttu-id="467ae-387">Especificidades do certificado do servidor TLS/DTLS</span><span class="sxs-lookup"><span data-stu-id="467ae-387">TLS/DTLS Server Certificate Specifics</span></span>

<span data-ttu-id="467ae-388">As implementações do DTLS Server geralmente não requerem certificados "fidedignos" para serem carregados no dispositivo ou certificados remotos a serem atribuídos.</span><span class="sxs-lookup"><span data-stu-id="467ae-388">DTLS Server implementations generally do not require “trusted” certificates to be loaded onto the device or remote certificates to be allocated.</span></span> <span data-ttu-id="467ae-389">A exceção a este ser quando a Autenticação do Certificado de Cliente está ativada.</span><span class="sxs-lookup"><span data-stu-id="467ae-389">The exception to this being when Client Certificate Authentication is enabled.</span></span>

<span data-ttu-id="467ae-390">Um Servidor TLS requer que seja carregado um certificado "local" (ou "identidade") para que o servidor possa fornecá-lo ao cliente remoto durante o aperto de mão TLS para autenticar o servidor ao cliente.</span><span class="sxs-lookup"><span data-stu-id="467ae-390">A TLS Server requires a “local” (or “identity”) certificate to be loaded so the server can provide it to the remote client during the TLS handshake to authenticate the server to the client.</span></span>

<span data-ttu-id="467ae-391">Para obter mais informações sobre o carregamento de certificados locais para utilização com aplicações de servidor NetX TLS, consulte a referência API para os seguintes serviços: nx_secure_dtls_server_local_certificate_add, nx_secure_dtls_server_local_certificate_remove.</span><span class="sxs-lookup"><span data-stu-id="467ae-391">For more information about loading local certificates for use with NetX TLS server applications, see the API reference for the following services: nx_secure_dtls_server_local_certificate_add, nx_secure_dtls_server_local_certificate_remove.</span></span>


### <a name="pre-shared-keys-psk"></a><span data-ttu-id="467ae-392">Chaves pré-partilhadas (PSK)</span><span class="sxs-lookup"><span data-stu-id="467ae-392">Pre-Shared Keys (PSK)</span></span>

<span data-ttu-id="467ae-393">Um mecanismo alternativo para fornecer autenticação de identificação em TLS é a noção de Chaves Pré-Partilhadas (PSK).</span><span class="sxs-lookup"><span data-stu-id="467ae-393">An alternative mechanism for providing identification authentication in TLS is the notion of Pre-Shared Keys (PSK).</span></span> <span data-ttu-id="467ae-394">A utilização de um cifrasuite PSK remove a necessidade de fazer as operações de encriptação intensivas de chaves públicas do processador, um bónus para dispositivos incorporados com recursos limitados.</span><span class="sxs-lookup"><span data-stu-id="467ae-394">Using a PSK ciphersuite removes the need to do the processor-intensive public-key encryption operations, a boon for resource-constrained embedded devices.</span></span> <span data-ttu-id="467ae-395">O PSK substitui o certificado no aperto de mão TLS/DTLS e é utilizado no lugar da chave de chave de sessão pré-master encriptada para a geração de chaves de sessão TLS/DTLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-395">The PSK replaces the certificate in the TLS/DTLS handshake and is used in place of the encrypted Pre-Master Secret for TLS/DTLS session key generation.</span></span>

<span data-ttu-id="467ae-396">As cifrasuites PSK são limitadas no sentido de que um segredo partilhado deve estar presente em ambos os dispositivos antes de uma sessão TLS/DTLS ser estabelecida.</span><span class="sxs-lookup"><span data-stu-id="467ae-396">The PSK ciphersuites are limited in the sense that that a shared secret must be present on both devices before a TLS/DTLS session can be established.</span></span> <span data-ttu-id="467ae-397">Isto significa que os dispositivos devem ter sido carregados com esse segredo usando alguns meios seguros que não uma ligação PSK TLS - os PSKs podem ser atualizados através de uma ligação PSK TLS, mas o dispositivo deve necessariamente começar com uma PSK que é carregada através de algum outro mecanismo.</span><span class="sxs-lookup"><span data-stu-id="467ae-397">This means that the devices must have been loaded with that secret using some secure means other than a TLS PSK connection - PSKs may be updated over a TLS PSK connection, but the device must necessarily start with a PSK that is loaded through some other mechanism.</span></span> <span data-ttu-id="467ae-398">Por exemplo, um dispositivo sensor e o seu dispositivo gateway poderiam ser carregados com PSKs na fábrica antes do envio, ou uma ligação TLS padrão (com um certificado) poderia ser usada para carregar o PSK.</span><span class="sxs-lookup"><span data-stu-id="467ae-398">For example, a sensor device and its gateway device could be loaded with PSKs in the factory before shipping, or a standard TLS connection (with a certificate) could be used to load the PSK.</span></span>

<span data-ttu-id="467ae-399">Os cifrasuites PSK vêm em algumas formas, descritas no RFC 4279.</span><span class="sxs-lookup"><span data-stu-id="467ae-399">PSK ciphersuites come in a couple of forms, described in RFC 4279.</span></span> <span data-ttu-id="467ae-400">A primeira utiliza teclas RSA ou Diffie-Hellman que são utilizadas da mesma forma que as chaves públicas transmitidas no certificado nos apertos de mão TLS padrão.</span><span class="sxs-lookup"><span data-stu-id="467ae-400">The first uses RSA or Diffie-Hellman keys which are used in the same manner as the public keys transmitted in the certificate in standard TLS handshakes.</span></span> <span data-ttu-id="467ae-401">O segundo formulário, que é mais utilizado num ambiente restrito a recursos, utiliza uma PSK que é usada para gerar diretamente as teclas de sessão (para utilização pela AES, por exemplo), evitando a utilização das operações de RSA ou Diffie-Hellman caras.</span><span class="sxs-lookup"><span data-stu-id="467ae-401">The second form, which is of more use in a resource-constrained environment, uses a PSK that is used to directly generate the session keys (for use by AES, for example), avoiding the use of the expensive RSA or Diffie-Hellman operations.</span></span>

<span data-ttu-id="467ae-402">O NetX Secure suporta a segunda forma de cifrasuites PSK, permitindo que as aplicações removam todo o código de criptografia e utilização da memória de chaves públicas.</span><span class="sxs-lookup"><span data-stu-id="467ae-402">NetX Secure supports the second form of PSK ciphersuites, enabling applications to remove all public-key cryptography code and memory usage.</span></span> <span data-ttu-id="467ae-403">O PSK em si não é uma chave AES, mas pode ser considerado como sendo mais uma palavra-passe a partir da qual as chaves reais são geradas.</span><span class="sxs-lookup"><span data-stu-id="467ae-403">The PSK itself is not an AES key, but can be considered as being more like a password from which the actual keys are generated.</span></span> <span data-ttu-id="467ae-404">Existem poucas restrições sobre o valor psk, embora valores mais longos forneçam mais segurança (o mesmo que com as palavras-passe).</span><span class="sxs-lookup"><span data-stu-id="467ae-404">There are few restrictions on what the PSK value can be, though longer values will provide more security (same as with passwords).</span></span>

<span data-ttu-id="467ae-405">Para utilizar o PSK com a sua aplicação NetX Secure, tem primeiro de definir a macro global **NX_SECURE_ENABLE_PSK_CIPHERSUITES**.</span><span class="sxs-lookup"><span data-stu-id="467ae-405">To use PSK with your NetX Secure application, you must first define the global macro **NX_SECURE_ENABLE_PSK_CIPHERSUITES**.</span></span> <span data-ttu-id="467ae-406">Isto é geralmente feito através das definições do seu compilador, mas a definição também pode ser colocada no ficheiro de cabeçalho nx_secure_tls.h.</span><span class="sxs-lookup"><span data-stu-id="467ae-406">This is usually done through your compiler settings, but the definition can also be placed in the nx_secure_tls.h header file.</span></span> <span data-ttu-id="467ae-407">Com o suporte de cifrasumita psk definido, o suporte cifrasuite PSK será compilado na sua aplicação DTLS NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="467ae-407">With the macro defined, PSK ciphersuite support will be compiled into your NetX Secure DTLS application.</span></span>

<span data-ttu-id="467ae-408">Com o suporte psk ativado, pode então utilizar a API DTLS para configurar PSKs para a sua aplicação.</span><span class="sxs-lookup"><span data-stu-id="467ae-408">With PSK support enabled, you can then use the DTLS API to set up PSKs for your application.</span></span> <span data-ttu-id="467ae-409">Cada PSK exigirá um valor PSK (a "chave" secreta real – mantenha este valor seguro), um valor de "identidade" usado para identificar o PSK específico, e uma "dica de identidade" que é usada por um servidor TLS para escolher um determinado valor PSK.</span><span class="sxs-lookup"><span data-stu-id="467ae-409">Each PSK will require a PSK value (the actual secret “key” – keep this value safe), an “identity” value used to identify the specific PSK, and an “identity hint” that is used by a TLS server to choose a particular PSK value.</span></span>

<span data-ttu-id="467ae-410">O próprio PSK pode ser qualquer valor binário, uma vez que nunca é enviado por uma ligação de rede.</span><span class="sxs-lookup"><span data-stu-id="467ae-410">The PSK itself can be any binary value as it is never sent over a network connection.</span></span> <span data-ttu-id="467ae-411">O PSK pode ter qualquer valor até 64 bytes de comprimento.</span><span class="sxs-lookup"><span data-stu-id="467ae-411">The PSK can be any value up to 64 bytes in length.</span></span>

<span data-ttu-id="467ae-412">A identidade e a sugestão devem ser cordas de caracteres imprimíveis formatadas usando UTF-8.</span><span class="sxs-lookup"><span data-stu-id="467ae-412">The identity and hint must be printable character strings formatted using UTF-8.</span></span> <span data-ttu-id="467ae-413">Os valores de identidade e sugestão podem ter até 128 bytes.</span><span class="sxs-lookup"><span data-stu-id="467ae-413">The identity and hint values may be any length up to 128 bytes.</span></span>

<span data-ttu-id="467ae-414">A identidade e o PSK formam um par único que é carregado em todos os dispositivos da rede que precisam de comunicar uns com os outros.</span><span class="sxs-lookup"><span data-stu-id="467ae-414">The identity and PSK form a unique pair that is loaded onto every device in the network that need to communicate with one another.</span></span>

<span data-ttu-id="467ae-415">A "dica" é usada principalmente para definir perfis de aplicação específicos para grupo de PSKs por função ou serviço.</span><span class="sxs-lookup"><span data-stu-id="467ae-415">The “hint” is primarily used for defining specific application profiles to group PSKs by function or service.</span></span> <span data-ttu-id="467ae-416">Estes valores devem ser acordados antecipadamente e dependem da aplicação.</span><span class="sxs-lookup"><span data-stu-id="467ae-416">These values must be agreed upon in advance and are application dependent.</span></span> <span data-ttu-id="467ae-417">Como exemplo, a aplicação do servidor da linha de comando OpenSSL (com o PSK ativado) utiliza a cadeia padrão "Client_identity", que deve ser fornecida por um cliente TLS para continuar com o aperto de mão TLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-417">As an example, the OpenSSL command-line server application (with PSK enabled) uses the default string “Client_identity”, which must be provided by a TLS client in order to continue with the TLS handshake.</span></span>

<span data-ttu-id="467ae-418">Para obter mais informações sobre psks, consulte a referência NetX Secure API para os seguintes serviços: nx_secure_dtls_psk_add, nx_secure_dtls_server_psk_add.</span><span class="sxs-lookup"><span data-stu-id="467ae-418">For more information on PSKs, see the NetX Secure API reference for the following services: nx_secure_dtls_psk_add, nx_secure_dtls_server_psk_add.</span></span>

## <a name="importing-x509-certificates-into-netx-secure"></a><span data-ttu-id="467ae-419">Importar certificados X.509 para o NetX Secure</span><span class="sxs-lookup"><span data-stu-id="467ae-419">Importing X.509 certificates into NetX Secure</span></span>

<span data-ttu-id="467ae-420">São necessários certificados digitais para a maioria das ligações TLS na Internet.</span><span class="sxs-lookup"><span data-stu-id="467ae-420">Digital certificates are required for most TLS connections on the Internet.</span></span> <span data-ttu-id="467ae-421">Os certificados fornecem um método para autenticar anfitriões anteriormente desconhecidos através da Internet através da utilização de intermediários de confiança, normalmente *chamados Autoridades de Certificados* ou CAs.</span><span class="sxs-lookup"><span data-stu-id="467ae-421">Certificates provide a method for authenticating previously unknown hosts over the Internet through the use of trusted intermediaries, usually called *Certificate Authorities* or CAs.</span></span> <span data-ttu-id="467ae-422">Para ligar o seu dispositivo NetX Secure a um serviço de nuvem comercial (como a Amazon Web Services), terá de importar certificados para a sua aplicação carregando-os no seu dispositivo.</span><span class="sxs-lookup"><span data-stu-id="467ae-422">To connect your NetX Secure device with a commercial cloud service (such as Amazon Web Services), you will need to import certificates into your application by loading them onto your device.</span></span>

<span data-ttu-id="467ae-423">Juntamente com os certificados, você também vai precisar de uma *chave privada* que está associada ao seu certificado.</span><span class="sxs-lookup"><span data-stu-id="467ae-423">Along with certificates, you will also sometimes need a *private key* that is associated with your certificate.</span></span> <span data-ttu-id="467ae-424">Em algumas aplicações (como o Cliente TLS quando a Autenticação do Certificado de Cliente não estiver a ser utilizada) o certificado por si só será suficiente, mas se o seu certificado estiver a ser utilizado para identificar o seu dispositivo, necessitará de uma chave privada.</span><span class="sxs-lookup"><span data-stu-id="467ae-424">In some applications (such as TLS Client when Client Certificate Authentication is not being used) the certificate alone will be sufficient, but if your certificate is being used to identify your device you will need a private key.</span></span> <span data-ttu-id="467ae-425">As chaves privadas são normalmente geradas quando cria o seu certificado e são armazenadas num ficheiro separado, muitas vezes encriptado com uma palavra-passe.</span><span class="sxs-lookup"><span data-stu-id="467ae-425">Private keys are typically generated when you create your certificate and are stored in a separate file, often encrypted with a password.</span></span>

<span data-ttu-id="467ae-426">Para obter uma descrição detalhada dos certificados de importação em aplicações NetX Secure, consulte o Capítulo 3 no Guia de Utilizador NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-426">For a detailed description of importing certificates into NetX Secure applications, please refer to Chapter 3 in the NetX Secure TLS User Guide.</span></span>

## <a name="client-certificate-authentication-in-netx-secure-tls"></a><span data-ttu-id="467ae-427">Autenticação de Certificado de Cliente em NetX Secure TLS</span><span class="sxs-lookup"><span data-stu-id="467ae-427">Client Certificate Authentication in NetX Secure TLS</span></span>

<span data-ttu-id="467ae-428">Ao utilizar a autenticação do certificado X.509, o protocolo TLS/DTLS exige que a instância do DTLS Server forneça um certificado de identificação, mas por padrão a instância do Cliente DTLS não necessita de fornecer um certificado de autenticação, utilizando outra forma de autenticação em vez disso (por exemplo, um nome de utilizador/combinação de palavra-passe).</span><span class="sxs-lookup"><span data-stu-id="467ae-428">When using X.509 certificate authentication, the TLS/DTLS protocol requires that the DTLS Server instance provide a certificate for identification, but by default the DTLS Client instance does not need to provide a certificate for authentication, using another form of authentication instead (e.g. a username/password combination).</span></span> <span data-ttu-id="467ae-429">Isto corresponde ao uso mais comum de TLS na Internet para web sites.</span><span class="sxs-lookup"><span data-stu-id="467ae-429">This matches the most common use of TLS on the Internet for Web sites.</span></span> <span data-ttu-id="467ae-430">Por exemplo, um site de retalho online deve provar a um potencial cliente usando um navegador web que o servidor é legítimo, mas o utilizador usará um login/senha para aceder a uma conta específica.</span><span class="sxs-lookup"><span data-stu-id="467ae-430">For example, an online retail site must prove to a potential customer using a web browser that the server is legitimate, but the user will use a login/password to access a specific account.</span></span>

<span data-ttu-id="467ae-431">No entanto, o caso padrão nem sempre é desejável, pelo que o TLS/DTLS permite opcionalmente que a instância do DTLS Server solicite um certificado ao Cliente remoto.</span><span class="sxs-lookup"><span data-stu-id="467ae-431">However, the default case is not always desirable, so TLS/DTLS optionally allows for the DTLS Server instance to request a certificate from the remote Client.</span></span> <span data-ttu-id="467ae-432">Quando esta funcionalidade estiver ativada, o Servidor DTLS enviará uma mensagem CertificateRequest ao Cliente DTLS durante o aperto de mão.</span><span class="sxs-lookup"><span data-stu-id="467ae-432">When this feature is enabled, the DTLS Server will send a CertificateRequest message to the DTLS Client during the handshake.</span></span> <span data-ttu-id="467ae-433">O Cliente deve responder com um certificado próprio e uma mensagem CertificateVerify que contenha um símbolo criptográfico que comprove que o Cliente é dono da chave privada correspondente associada a esse certificado.</span><span class="sxs-lookup"><span data-stu-id="467ae-433">The Client must respond with a certificate of its own and a CertificateVerify message which contains a cryptographic token proving that the Client owns the matching private key associated with that certificate.</span></span> <span data-ttu-id="467ae-434">Se a verificação falhar ou o certificado não estiver ligado a um certificado de confiança no Servidor, o aperto de mão TLS falha.</span><span class="sxs-lookup"><span data-stu-id="467ae-434">If the verification fails or the certificate is not connected to a trusted certificate on the Server, the TLS handshake fails.</span></span>

<span data-ttu-id="467ae-435">Existem dois casos distintos de Autenticação de Certificado de Cliente em TLS – as seguintes secções cobrem ambos os casos.</span><span class="sxs-lookup"><span data-stu-id="467ae-435">There are two separate cases for Client Certificate Authentication in TLS – the following sections cover both cases.</span></span>

### <a name="client-certificate-authentication-for-dtls-clients"></a><span data-ttu-id="467ae-436">Autenticação de Certificado de Cliente para Clientes DTLS</span><span class="sxs-lookup"><span data-stu-id="467ae-436">Client Certificate Authentication for DTLS Clients</span></span>

<span data-ttu-id="467ae-437">Um Cliente DTLS pode tentar uma ligação a um servidor que solicite um certificado para autenticação do cliente.</span><span class="sxs-lookup"><span data-stu-id="467ae-437">A DTLS Client may attempt a connection to a server that requests a certificate for client authentication.</span></span> <span data-ttu-id="467ae-438">Neste caso, o Cliente deve fornecer um certificado ao servidor e verificar se é dono da chave privada correspondente ou o Servidor terminará o aperto de mão DTLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-438">In this case the Client must provide a certificate to the server and verify that it owns the matching private key or the Server will terminate the DTLS handshake.</span></span>

<span data-ttu-id="467ae-439">No DTLS NetX Secure, não existe uma configuração especial para suportar esta funcionalidade, mas a aplicação terá de fornecer um certificado de identificação local para a instância do Cliente TLS utilizando o serviço *nx_secure_tls_session_local_certificate_add.*</span><span class="sxs-lookup"><span data-stu-id="467ae-439">In NetX Secure DTLS, there is no special configuration to support this feature but the application will have to provide a local identification certificate for the TLS Client instance using the *nx_secure_tls_session_local_certificate_add* service.</span></span> <span data-ttu-id="467ae-440">Se nenhum certificado for fornecido pela aplicação, mas o servidor remoto estiver a utilizar a Autenticação do Certificado de Cliente e solicitar um certificado, o aperto de mão DTLS falhará.</span><span class="sxs-lookup"><span data-stu-id="467ae-440">If no certificate is provided by the application but the remote server is using Client Certificate Authentication and requests a certificate, the DTLS handshake will fail.</span></span> <span data-ttu-id="467ae-441">O certificado fornecido à Sessão DTLS com *nx_secure_dtls_session_local_certificate_add* deve ser reconhecido pelo servidor remoto para completar o aperto de mão DTLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-441">The certificate provided to the DTLS Session with *nx_secure_dtls_session_local_certificate_add* must be recognized by the remote server in order to complete the DTLS handshake.</span></span>

### <a name="client-certificate-authentication-for-tls-servers"></a><span data-ttu-id="467ae-442">Autenticação de Certificado de Cliente para Servidores TLS</span><span class="sxs-lookup"><span data-stu-id="467ae-442">Client Certificate Authentication for TLS Servers</span></span>

<span data-ttu-id="467ae-443">O caso do Servidor DTLS para autenticação de certificado de cliente é ligeiramente mais complexo do que o caso do Cliente DTLS devido à funcionalidade ser opcional.</span><span class="sxs-lookup"><span data-stu-id="467ae-443">The DTLS Server case for Client Certificate Authentication is slightly more complex than the DTLS Client case due to the feature being optional.</span></span> <span data-ttu-id="467ae-444">Neste caso, o Servidor TLS precisa de solicitar especificamente um certificado ao cliente TLS remoto, em seguida, processar a mensagem CertificateVerify para verificar se o Cliente remoto possui a chave privada correspondente, e então o Servidor deve verificar se o certificado fornecido pelo Cliente pode ser rastreado a um certificado na loja de certificados de confiança local.</span><span class="sxs-lookup"><span data-stu-id="467ae-444">In this case, the TLS Server needs to specifically request a certificate from the remote TLS Client, then process the CertificateVerify message to verify that the remote Client owns the matching private key, and then the Server must check that the certificate provided by the Client can be traced to a certificate in the local trusted certificate store.</span></span>

<span data-ttu-id="467ae-445">Nas instâncias do NetX Secure TLS Server, a autenticação do certificado de cliente é controlada pelos serviços *de nx_secure_dtls_server_x509_client_verify_configure* e *nx_secure_dtls_server_x509_client_verify_disable.*</span><span class="sxs-lookup"><span data-stu-id="467ae-445">In NetX Secure TLS Server instances, Client Certificate Authentication is controlled by the *nx_secure_dtls_server_x509_client_verify_configure* and *nx_secure_dtls_server_x509_client_verify_disable* services.</span></span>

<span data-ttu-id="467ae-446">Para ativar a autenticação do certificado do cliente, uma aplicação deve ligar *para nx_secure_dtls_server_x509_client_verify_configure* com a instância de sessão do DTLS Server antes de ligar *para nx_secure_dtls_server_start*.</span><span class="sxs-lookup"><span data-stu-id="467ae-446">To enable Client Certificate Authentication, an application must call *nx_secure_dtls_server_x509_client_verify_configure* with the DTLS Server session instance before calling *nx_secure_dtls_server_start*.</span></span> <span data-ttu-id="467ae-447">A verificação requer espaço para a atribuição de certificados de cliente que são fornecidos como parâmetro para *nx_secure_dtls_server_x509_client_verify_configure.*</span><span class="sxs-lookup"><span data-stu-id="467ae-447">The verification requires space to be allocated for incoming client certificates which is provided as a parameter to *nx_secure_dtls_server_x509_client_verify_configure.*</span></span> <span data-ttu-id="467ae-448">Note que o tampão deve ser suficientemente grande para manter a cadeia de certificados de tamanho máximo fornecida por um cliente *vezes o número de sessões de servidores DTLS*.</span><span class="sxs-lookup"><span data-stu-id="467ae-448">Note that the buffer must be large enough to hold the maximum-size certificate chain provided by a client *times the number of DTLS server sessions*.</span></span> <span data-ttu-id="467ae-449">Cada sessão de servidor requer espaço que será atribuído a partir do único tampão fornecido.</span><span class="sxs-lookup"><span data-stu-id="467ae-449">Each server session requires space which will be allocated from the single provided buffer.</span></span> <span data-ttu-id="467ae-450">Certifique-se de que o tampão é grande o suficiente ou ocorrerá um erro se a cadeia de certificados do Cliente fornecido for demasiado grande.</span><span class="sxs-lookup"><span data-stu-id="467ae-450">Make sure the buffer is large enough or an error will occur if the provided Client certificate chain is too large.</span></span>

<span data-ttu-id="467ae-451">Quando a autenticação do Certificado de Cliente estiver ativada, o Servidor DTLS solicitará um certificado ao Cliente DTLS remoto durante o aperto de mão DTLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-451">When Client Certificate Authentication is enabled, the DTLS Server will request a certificate from the remote DTLS Client during the DTLS handshake.</span></span> <span data-ttu-id="467ae-452">No NetX Secure DTLS Server, o certificado Cliente é verificado contra a loja de certificados fidedignos criados com *nx_secure_dtls_server_trusted_certificate_add* seguindo a cadeia de emissores X.509.</span><span class="sxs-lookup"><span data-stu-id="467ae-452">In NetX Secure DTLS Server, the Client certificate is checked against the store of trusted certificates created with *nx_secure_dtls_server_trusted_certificate_add* by following the X.509 issuer chain.</span></span> <span data-ttu-id="467ae-453">O Cliente remoto deve fornecer uma cadeia que ligue o seu certificado de identidade a um certificado na loja fidedigna ou o aperto de mão DTLS falhará.</span><span class="sxs-lookup"><span data-stu-id="467ae-453">The remote Client must provide a chain that connects its identity certificate to a certificate in the trusted store or the DTLS handshake will fail.</span></span> <span data-ttu-id="467ae-454">Além disso, se o processamento de mensagem CertificadoVerificar falhar, o aperto de mão DTLS também falhará.</span><span class="sxs-lookup"><span data-stu-id="467ae-454">Additionally, if the CertificateVerify message processing fails, the DTLS handshake will also fail.</span></span>

<span data-ttu-id="467ae-455">Os métodos de assinatura utilizados para o método CertificadoVerify são fixados para a versão 1.0 e TLS da versão 1.0 e TLS 1.1, e são especificados pelo Servidor TLS na versão 1.2 do TLS, sobre o qual se baseia o DTLS NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="467ae-455">The signature methods used for the CertificateVerify method are fixed for TLS version 1.0 and TLS version 1.1, and are specified by the TLS Server in TLS version 1.2, upon which NetX Secure DTLS is based.</span></span> <span data-ttu-id="467ae-456">Para o DTLS 1.2, os métodos de assinatura suportados geralmente seguem os métodos relevantes fornecidos na tabela do método criptográfico, mas tipicamente RSA com SHA-256 (ver a secção "Criptografia em NetX Secure TLS" para obter mais informações sobre a inicialização de TLS com métodos criptográficos).</span><span class="sxs-lookup"><span data-stu-id="467ae-456">For DTLS 1.2, the signature methods supported generally follow the relevant methods supplied in the cryptographic method table, but typically RSA with SHA-256 (see the section “Cryptography in NetX Secure TLS” for more information on initializing TLS with cryptographic methods).</span></span>

## <a name="cryptography-in-netx-secure-tls"></a><span data-ttu-id="467ae-457">Criptografia em NetX Secure TLS</span><span class="sxs-lookup"><span data-stu-id="467ae-457">Cryptography in NetX Secure TLS</span></span>

<span data-ttu-id="467ae-458">O TLS define um protocolo no qual a criptografia pode ser usada para garantir comunicações de rede.</span><span class="sxs-lookup"><span data-stu-id="467ae-458">TLS defines a protocol in which cryptography can be used to secure network communications.</span></span> <span data-ttu-id="467ae-459">Como tal, deixa a criptografia real a ser usada bastante aberta para os utilizadores de TLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-459">As such, it leaves the actual cryptography to be used fairly wide open for TLS users.</span></span> <span data-ttu-id="467ae-460">A especificação requer apenas uma única cifrasuita a ser implementada – no caso do TLS 1.2, essa cifrasuite é TLS_RSA_WITH_AES_128_CBC_SHA, indicando a utilização de RSA para operações de chave pública, AES no modo CBC com teclas de 128 bits para encriptação de sessão, e SHA-1 para a autenticação de mensagens.</span><span class="sxs-lookup"><span data-stu-id="467ae-460">The specification only requires a single ciphersuite to be implemented – in the case of TLS 1.2, that ciphersuite is TLS_RSA_WITH_AES_128_CBC_SHA, indicating the use of RSA for public-key operations, AES in CBC mode with 128-bit keys for session encryption, and SHA-1 for message authentication hashes.</span></span>

<span data-ttu-id="467ae-461">Sendo TLS 1.2 conforme, o NetX Secure permite a TLS_RSA_WITH_AES_128_CBC_SHA cifra por padrão, mas dado o número de possíveis implementações para cada um dos métodos criptográficos devido a capacidades de hardware e outras considerações, o NetX Secure fornece uma API criptográfica genérica que permite ao utilizador especificar quais os métodos criptográficos a utilizar com TLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-461">Being TLS 1.2-compliant, NetX Secure enables the mandatory TLS_RSA_WITH_AES_128_CBC_SHA ciphersuite by default, but given the number of possible implementations for each of the cryptographic methods due to hardware capabilities and other considerations, NetX Secure provides a generic cryptographic API that allows a user to specify which cryptographic methods to use with TLS.</span></span>

> [!NOTE]
> <span data-ttu-id="467ae-462">O mecanismo genérico de API criptográfico também permite que os utilizadores implementem os seus próprios cifrasuites, mas isso é recomendado para utilizadores avançados que estejam familiarizados com os cifrasuites e extensões TLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-462">The generic cryptographic API mechanism also allows users to implement their own ciphersuites, but this is recommended for advanced users who are familiar with the TLS ciphersuites and extensions.</span></span> <span data-ttu-id="467ae-463">Por favor contacte o seu representante da Express Logic se estiver interessado em apoiar os seus próprios cifrasuites.</span><span class="sxs-lookup"><span data-stu-id="467ae-463">Please contact your Express Logic representative if you are interested in supporting your own ciphersuites.</span></span>

<span data-ttu-id="467ae-464">Consulte o Guia de Utilizador NetX Secure TLS, Capítulo 3, para uma discussão detalhada sobre como configurar métodos criptográficos para DTLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-464">Please see the NetX Secure TLS User Guide, Chapter 3 for a detailed discussion about how to configure cryptographic methods for DTLS.</span></span> <span data-ttu-id="467ae-465">O mesmo processo aplica-se tanto ao TLS como ao DTLS.</span><span class="sxs-lookup"><span data-stu-id="467ae-465">The same process applies to both TLS and DTLS.</span></span>
