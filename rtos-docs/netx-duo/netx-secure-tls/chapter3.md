---
title: Capítulo 3 - Descrição funcional do Azure RTOS NetX Secure
description: Este capítulo contém uma descrição funcional do NetX Secure TLS.
author: philmea
ms.author: philmea
ms.date: 06/04/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: c28ad0255f99986a4ddfe5faefad81e70840e5e0
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: MT
ms.contentlocale: pt-PT
ms.lasthandoff: 03/22/2021
ms.locfileid: "104825687"
---
# <a name="chapter-3---functional-description-of-azure-rtos-netx-secure"></a><span data-ttu-id="75655-103">Capítulo 3 - Descrição funcional do Azure RTOS NetX Secure</span><span class="sxs-lookup"><span data-stu-id="75655-103">Chapter 3 - Functional description of Azure RTOS NetX Secure</span></span>

## <a name="execution-overview"></a><span data-ttu-id="75655-104">Visão geral da execução</span><span class="sxs-lookup"><span data-stu-id="75655-104">Execution Overview</span></span>

<span data-ttu-id="75655-105">Este capítulo contém uma descrição funcional de Azure RTOS NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-105">This chapter contains a functional description of Azure RTOS NetX Secure TLS.</span></span> <span data-ttu-id="75655-106">Existem dois tipos primários de execução de programas numa aplicação NetX Secure TLS: inicialização e chamadas de interface de aplicação.</span><span class="sxs-lookup"><span data-stu-id="75655-106">There are two primary types of program execution in a NetX Secure TLS application: initialization and application interface calls.</span></span> 

<span data-ttu-id="75655-107">*NetX Secure assume a existência de ThreadX e NetX/NetXDuo. Da ThreadX, requer execução de fios, suspensão, temporizadores periódicos e instalações de exclusão mútua. A partir da NetX/NetXDuo requer as instalações de rede TCP/IP e os controladores.*</span><span class="sxs-lookup"><span data-stu-id="75655-107">*NetX Secure assumes the existence of ThreadX and NetX/NetXDuo. From ThreadX, it requires thread execution, suspension, periodic timers, and mutual exclusion facilities. From NetX/NetXDuo it requires the TCP/IP networking facilities and drivers.*</span></span>

## <a name="transport-layer-security-tls-and-secure-sockets-layer-ssl"></a><span data-ttu-id="75655-108">Segurança da camada de transporte (TLS) e camada de tomadas seguras (SSL)</span><span class="sxs-lookup"><span data-stu-id="75655-108">Transport Layer Security (TLS) and Secure Sockets Layer (SSL)</span></span>

<span data-ttu-id="75655-109">O componente de protocolo de rede seguro do NetX secure é uma implementação do protocolo de Segurança da Camada de Transporte (TLS), tal como descrito nos RFCs 2246 (versão 1.0), 4346 (versão 1.1), 5246 (versão 1.2) e 8446 (versão 1.3).</span><span class="sxs-lookup"><span data-stu-id="75655-109">The secure network protocol component of NetX secure is an implementation of the Transport Layer Security (TLS) protocol as described in RFCs 2246 (version 1.0), 4346 (version 1.1), 5246 (version 1.2) and 8446 (version 1.3).</span></span> <span data-ttu-id="75655-110">Também estão incluídas as rotinas de suporte para X.509 básico (RFC 5280).</span><span class="sxs-lookup"><span data-stu-id="75655-110">Also included are support routines for basic X.509 (RFC 5280).</span></span>

<span data-ttu-id="75655-111">NetX Secure TLS suporta as versões TLS 1.2 e 1.3.</span><span class="sxs-lookup"><span data-stu-id="75655-111">NetX Secure TLS supports TLS versions 1.2 and 1.3.</span></span> <span data-ttu-id="75655-112">As implementações estão previstas para os TLS 1.0 e TLS 1.1 agora prectados, mas devem ser explicitamente inicializadas e não são recomendadas para utilização em novos produtos.</span><span class="sxs-lookup"><span data-stu-id="75655-112">Implementations are provided for the now-deprecated TLS 1.0 and TLS 1.1, but they must be explicitly initialized and are not recommended for use in new products.</span></span>

<span data-ttu-id="75655-113">*Secure Sockets Layer* (SSL) foi o nome original de TLS antes de se tornar um padrão em RFC 2246 e "SSL" é frequentemente usado como um nome genérico para os protocolos TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-113">*Secure Sockets Layer* (SSL) was the original name of TLS before it became a standard in RFC 2246 and "SSL" is often used as a generic name for the TLS protocols.</span></span> <span data-ttu-id="75655-114">A última versão do SSL foi 3.0, e tLS 1.0 é por vezes referida como versão SSL 3.1.</span><span class="sxs-lookup"><span data-stu-id="75655-114">The last version of SSL was 3.0, and TLS 1.0 is sometimes referred to as SSL version 3.1.</span></span> <span data-ttu-id="75655-115">Todas as versões do protocolo oficial "SSL" são consideradas obsoletas e inseguras e atualmente o NetX Secure não fornece uma implementação SSL.</span><span class="sxs-lookup"><span data-stu-id="75655-115">All versions of the official "SSL" protocol are considered obsolete and insecure and currently NetX Secure does not provide an SSL implementation.</span></span>

<span data-ttu-id="75655-116">O TLS especifica um protocolo para gerar *teclas* de sessão que são criadas durante o *aperto de mão* TLS entre um cliente TLS e servidor e essas teclas são usadas para encriptar dados enviados pela aplicação durante a sessão TLS. </span><span class="sxs-lookup"><span data-stu-id="75655-116">TLS specifies a protocol to generate *session keys* which are created during the TLS *handshake* between a TLS client and server and those keys are used to encrypt data sent by the application during the TLS *session.*</span></span>

<span data-ttu-id="75655-117">Os dados TLS são divididos em *registos* equivalentes em conceito a um pacote TCP.</span><span class="sxs-lookup"><span data-stu-id="75655-117">TLS data is divided into *records* which are equivalent in concept to a TCP packet.</span></span> <span data-ttu-id="75655-118">Cada registo TLS tem um cabeçalho, e os registos encriptados TLS também têm um rodapé (hash de sistema de verificação).</span><span class="sxs-lookup"><span data-stu-id="75655-118">Every TLS record has a header, and TLS encrypted records also have a footer (checksum hash).</span></span> <span data-ttu-id="75655-119">Os registos de aperto de mão TLS têm um cabeçalho adicional encapsulado dentro do registo TLS maior.</span><span class="sxs-lookup"><span data-stu-id="75655-119">TLS handshake records have an additional header encapsulated within the larger TLS record.</span></span> <span data-ttu-id="75655-120">O registo TLS é encapsulado pelo protocolo de rede de camadas de transporte da mesma forma que um pacote TCP é encapsulado por um pacote IP.</span><span class="sxs-lookup"><span data-stu-id="75655-120">The TLS record is encapsulated by the  transport layer network protocol in the same manner that a TCP packet is encapsulated by an IP packet.</span></span>

### <a name="tls-13"></a><span data-ttu-id="75655-121">TLS 1.3</span><span class="sxs-lookup"><span data-stu-id="75655-121">TLS 1.3</span></span>

<span data-ttu-id="75655-122">Em agosto de 2018, a especificação TLS 1.3 foi finalizada.</span><span class="sxs-lookup"><span data-stu-id="75655-122">In August 2018, the TLS 1.3 specification was finalized.</span></span> <span data-ttu-id="75655-123">A nova versão do protocolo é uma atualização bastante significativa que altera alguns aspetos fundamentais da segurança e desempenho subjacentes do TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-123">The new version of the protocol is a fairly significant update that changes some fundamental aspects of the underlying security and performance of TLS.</span></span> <span data-ttu-id="75655-124">No entanto, estas alterações são em grande parte invisíveis para o utilizador típico do TLS, uma vez que se aplicam principalmente à máquina de aperto de mão TLS e à geração chave de sessão.</span><span class="sxs-lookup"><span data-stu-id="75655-124">However, these changes are largely invisible to the typical TLS user since they apply primarily to the TLS handshake state machine and session key generation.</span></span> <span data-ttu-id="75655-125">Foram também adicionadas algumas funcionalidades e extensões opcionais.</span><span class="sxs-lookup"><span data-stu-id="75655-125">A number of optional features and extensions were added as well.</span></span> <span data-ttu-id="75655-126">Segue-se um resumo das alterações e como impactam a funcionalidade TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-126">The following is a summary of the changes and how they impact TLS functionality.</span></span>

- <span data-ttu-id="75655-127">A máquina de aperto de mão foi otimizada removendo uma troca completa de mensagens pelo servidor.</span><span class="sxs-lookup"><span data-stu-id="75655-127">The handshake state machine was optimized by removing an entire exchange of messages by the server.</span></span>
- <span data-ttu-id="75655-128">A geração chave foi atualizada para usar uma rotina padronizada chamada HKDF (Função de Derivação de Chaves baseada em HMAC) e liga as teclas de sessão a todas as mensagens de aperto de mão (em vez de alguns parâmetros selecionados).</span><span class="sxs-lookup"><span data-stu-id="75655-128">Key generation was updated to use a standardized routine called HKDF (HMAC-based Key Derivation Function) and ties the session keys to all of the handshake messages (instead of a few select parameters).</span></span>
- <span data-ttu-id="75655-129">Todos os TLS 1.2 e cifrasuites anteriores são precários e são incompatíveis com TLS 1.3.</span><span class="sxs-lookup"><span data-stu-id="75655-129">All TLS 1.2 and earlier ciphersuites are deprecated and are incompatible with TLS 1.3.</span></span> <span data-ttu-id="75655-130">Da mesma forma, todas as cifrasuites TLS 1.3 são inutilizáveis com versões anteriores.</span><span class="sxs-lookup"><span data-stu-id="75655-130">Similarly, all TLS 1.3 ciphersuites are unusable with previous versions.</span></span>
- <span data-ttu-id="75655-131">Todos os TLS 1.3 cifrasuites fornecem sigilo perfeito para a frente (PFS) usando chaves efémeras<sup>6</sup></span><span class="sxs-lookup"><span data-stu-id="75655-131">All TLS 1.3 ciphersuites provide Perfect Forward Secrecy (PFS) using ephemeral keys<sup>6</sup></span></span> 
- <span data-ttu-id="75655-132">TLS 1.3 remove o "código de autenticação de mensagem" (MAC) em cada registo a favor da utilização de 7 cifras AEAD<sup>7</sup></span><span class="sxs-lookup"><span data-stu-id="75655-132">TLS 1.3 removes the "message authentication code" (MAC) in each record in favor of using AEAD<sup>7</sup> ciphers</span></span>
- <span data-ttu-id="75655-133">Foram adicionadas algumas funcionalidades opcionais adicionais, incluindo 0-RTT (Zero Round Trip Time) que permite que os dados da aplicação sejam enviados durante o aperto de mão.</span><span class="sxs-lookup"><span data-stu-id="75655-133">Some additional optional features were added, including 0-RTT (Zero Round Trip Time) which allows for application data to be sent during the handshake.</span></span> <span data-ttu-id="75655-134">0-RTT é puramente opcional e não é atualmente suportado em Azure RTOS TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-134">0-RTT is purely optional and is not currently supported in Azure RTOS TLS.</span></span>

<span data-ttu-id="75655-135">O TLS 1.3 não afeta significativamente as aplicações dos utilizadores.</span><span class="sxs-lookup"><span data-stu-id="75655-135">TLS 1.3 does not significantly affect user applications.</span></span> <span data-ttu-id="75655-136">A API permanece exatamente a mesma entre versões, e os cifrasuites são marcados para que uma única tabela cifrassuite possa ser usada.</span><span class="sxs-lookup"><span data-stu-id="75655-136">The API remains exactly the same between versions, and ciphersuites are marked so a single ciphersuite table may be used.</span></span>

<span data-ttu-id="75655-137">Para utilizar o TLS 1.3, o NX_SECURE_TLS_ENABLE_TLS_1_3 macro deve ser definido globalmente.</span><span class="sxs-lookup"><span data-stu-id="75655-137">In order to use TLS 1.3, the macro NX_SECURE_TLS_ENABLE_TLS_1_3 must be globally defined.</span></span> <span data-ttu-id="75655-138">TLS 1.3 é desativado por padrão em Azure RTOS TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-138">TLS 1.3 is disabled by default in Azure RTOS TLS.</span></span>

6. <span data-ttu-id="75655-139">As teclas "efémeras" são pares de chaves assimétricos que são gerados durante o aperto de mão TLS e usados para a troca de segredos apenas por essa sessão.</span><span class="sxs-lookup"><span data-stu-id="75655-139">“Ephemeral” keys are asymmetric key pairs that are generated during the TLS handshake and used for the secrets exchange for only that session.</span></span> <span data-ttu-id="75655-140">O par-chave é descartado após a utilização – isto impede que um intruso possa aceder a dados encriptados numa sessão de TLS gravada, mesmo que uma chave privada de certificado seja comprometida a qualquer momento no futuro – daí o "Perfeito Segredo para a Frente".</span><span class="sxs-lookup"><span data-stu-id="75655-140">They key pair is discarded after use – this prevents an attacker from being able to access encrypted data in a recorded TLS session even if a certificate private key is compromised at any time in the future – hence “Perfect Forward Secrecy”.</span></span>

7. <span data-ttu-id="75655-141">Encriptação Autenticada com Dados Associados – um modo para cifras como a AES que combina encriptação e verificação de integridade numa única operação, eliminando a necessidade de um haxixe separado dos dados para verificação de integridade.</span><span class="sxs-lookup"><span data-stu-id="75655-141">Authenticated Encryption with Associated Data – a mode for ciphers like AES that combines encryption and integrity checking in a single operation, eliminating the need for a separate hash of the data for integrity checking.</span></span>

### <a name="tls-record-header"></a><span data-ttu-id="75655-142">Cabeçalho de registo TLS</span><span class="sxs-lookup"><span data-stu-id="75655-142">TLS Record header</span></span>

<span data-ttu-id="75655-143">Qualquer registo TLS válido deve ter um cabeçalho TLS, como mostrado no Erro!</span><span class="sxs-lookup"><span data-stu-id="75655-143">Any valid TLS record must have a TLS header, as shown in Error!</span></span> <span data-ttu-id="75655-144">Fonte de referência não encontrada.</span><span class="sxs-lookup"><span data-stu-id="75655-144">Reference source not found.</span></span>

![Diagrama de um cabeçalho de registo TLS.](media/image2.png)

<span data-ttu-id="75655-146">Figura 1 - Cabeçalho de registo TLS</span><span class="sxs-lookup"><span data-stu-id="75655-146">Figure 1 - TLS record header</span></span>

<span data-ttu-id="75655-147">Os campos do cabeçalho de registo TLS são definidos da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="75655-147">The fields of the TLS record header are defined as follows:</span></span>

| <span data-ttu-id="75655-148">Campo de cabeçalho TLS</span><span class="sxs-lookup"><span data-stu-id="75655-148">TLS Header Field</span></span> | <span data-ttu-id="75655-149">Objetivo</span><span class="sxs-lookup"><span data-stu-id="75655-149">Purpose</span></span>     |
| ---------------- | ------------- |
| <span data-ttu-id="75655-150">**Tipo de mensagem de 8 bits**</span><span class="sxs-lookup"><span data-stu-id="75655-150">**8-bit Message Type**</span></span> | <span data-ttu-id="75655-151">Este campo contém o tipo de registo TLS enviado.</span><span class="sxs-lookup"><span data-stu-id="75655-151">This field contains the type of TLS record being sent.</span></span> <span data-ttu-id="75655-152">Os tipos válidos são os seguintes:</span><span class="sxs-lookup"><span data-stu-id="75655-152">Valid types are as follows:</span></span><br /><span data-ttu-id="75655-153">- ChangeCipherSpec<sup>8</sup>: 0x14</span><span class="sxs-lookup"><span data-stu-id="75655-153">- ChangeCipherSpec<sup>8</sup>: 0x14</span></span><br /><span data-ttu-id="75655-154">- Alerta: 0x15</span><span class="sxs-lookup"><span data-stu-id="75655-154">- Alert: 0x15</span></span><br /><span data-ttu-id="75655-155">- Aperto de mão: 0x16</span><span class="sxs-lookup"><span data-stu-id="75655-155">- Handshake: 0x16</span></span><br /><span data-ttu-id="75655-156">- Dados da aplicação: 0x17</span><span class="sxs-lookup"><span data-stu-id="75655-156">- Application Data: 0x17</span></span> |
| <span data-ttu-id="75655-157">**Versão do protocolo de 16 bits**</span><span class="sxs-lookup"><span data-stu-id="75655-157">**16-bit Protocol Version**</span></span> | <span data-ttu-id="75655-158">Este campo contém a versão do protocolo TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-158">This field contains the TLS protocol version.</span></span> <span data-ttu-id="75655-159">Os valores válidos são os seguintes:</span><span class="sxs-lookup"><span data-stu-id="75655-159">Valid values are as follows:</span></span><br /><span data-ttu-id="75655-160">- SSL 3.0: 0x0300</span><span class="sxs-lookup"><span data-stu-id="75655-160">- SSL 3.0: 0x0300</span></span><br /><span data-ttu-id="75655-161">- TLS 1.0: 0x0301</span><span class="sxs-lookup"><span data-stu-id="75655-161">- TLS 1.0: 0x0301</span></span><br /><span data-ttu-id="75655-162">- TLS 1.1: 0x0302</span><span class="sxs-lookup"><span data-stu-id="75655-162">- TLS 1.1: 0x0302</span></span><br /><span data-ttu-id="75655-163">- TLS 1.2: 0x0303</span><span class="sxs-lookup"><span data-stu-id="75655-163">- TLS 1.2: 0x0303</span></span><br /><span data-ttu-id="75655-164">- **TLS 1.3 <sup>9</sup>**: **0x0303**</span><span class="sxs-lookup"><span data-stu-id="75655-164">- **TLS 1.3 <sup>9</sup>**: **0x0303**</span></span> |
| <span data-ttu-id="75655-165">**Comprimento de 16 bits**</span><span class="sxs-lookup"><span data-stu-id="75655-165">**16-bit Length**</span></span> | <span data-ttu-id="75655-166">Este campo contém o comprimento dos dados encapsulados no registo TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-166">This field contains the length of the data encapsulated in the TLS record.</span></span> |

8. <span data-ttu-id="75655-167">No TLS 1.3 a mensagem ChangeCipherSpec já não é utilizada, embora ainda possa ser enviada por razões de compatibilidade, caso em que a mensagem é ignorada.</span><span class="sxs-lookup"><span data-stu-id="75655-167">In TLS 1.3 the ChangeCipherSpec message is no longer used, though it still may be sent for compatibility reasons in which case the message is ignored.</span></span>

9. <span data-ttu-id="75655-168">O TLS 1.3 teria tecnicamente um valor de 0x0304 se este regime fosse continuado, mas o protocolo foi alterado para ter a versão do protocolo real numa extensão, pelo que todos os registos TLS 1.3 utilizam 0x0303 nos campos da versão protocolar para retrocompatibilidade.</span><span class="sxs-lookup"><span data-stu-id="75655-168">TLS 1.3 would technically have a value of 0x0304 if this scheme was continued, but the protocol was changed to have the actual protocol version in an extension, so all TLS 1.3 records use 0x0303 in protocol version fields for backward-compatibility.</span></span>

### <a name="tls-handshake-record-header"></a><span data-ttu-id="75655-169">Cabeçalho de recorde de aperto de mão TLS</span><span class="sxs-lookup"><span data-stu-id="75655-169">TLS Handshake Record header</span></span>

<span data-ttu-id="75655-170">Qualquer registo de aperto de mão válido do TLS deve ter um cabeçalho de aperto de mão TLS, como mostra a Figura 2.</span><span class="sxs-lookup"><span data-stu-id="75655-170">Any valid TLS handshake record must have a TLS Handshake header, as shown in Figure 2.</span></span>

![Diagrama de um cabeçalho de recorde de aperto de mão TLS.](media/image3.png)

<span data-ttu-id="75655-172">Figura 2 - Cabeçalho recorde de aperto de mão TLS</span><span class="sxs-lookup"><span data-stu-id="75655-172">Figure 2 - TLS Handshake record header</span></span>

<span data-ttu-id="75655-173">Os campos do cabeçalho de registo do aperto de mão TLS são definidos da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="75655-173">The fields of the TLS Handshake record header are defined as follows:</span></span>

| <span data-ttu-id="75655-174">Campo de cabeçalho TLS</span><span class="sxs-lookup"><span data-stu-id="75655-174">TLS Header Field</span></span> | <span data-ttu-id="75655-175">Objetivo</span><span class="sxs-lookup"><span data-stu-id="75655-175">Purpose</span></span> |
| ---------------- |----------------------- |
| <span data-ttu-id="75655-176">**Tipo de mensagem de 8 bits**</span><span class="sxs-lookup"><span data-stu-id="75655-176">**8-bit Message Type**</span></span> | <span data-ttu-id="75655-177">Este campo contém o tipo de registo TLS enviado.</span><span class="sxs-lookup"><span data-stu-id="75655-177">This field contains the type of TLS record being sent.</span></span> <span data-ttu-id="75655-178">Os tipos válidos são os seguintes:</span><span class="sxs-lookup"><span data-stu-id="75655-178">Valid types are as follows:</span></span><br /><span data-ttu-id="75655-179">- ChangeCipherSpec<sup>10</sup>: 0x14</span><span class="sxs-lookup"><span data-stu-id="75655-179">- ChangeCipherSpec<sup>10</sup>: 0x14</span></span><br /><span data-ttu-id="75655-180">- Alerta: 0x15</span><span class="sxs-lookup"><span data-stu-id="75655-180">- Alert: 0x15</span></span><br /><span data-ttu-id="75655-181">- Aperto de mão: 0x16</span><span class="sxs-lookup"><span data-stu-id="75655-181">- Handshake: 0x16</span></span><br /><span data-ttu-id="75655-182">- Dados da aplicação: 0x17</span><span class="sxs-lookup"><span data-stu-id="75655-182">- Application Data: 0x17</span></span> |
| <span data-ttu-id="75655-183">**Versão do protocolo de 16 bits**</span><span class="sxs-lookup"><span data-stu-id="75655-183">**16-bit Protocol Version**</span></span> | <span data-ttu-id="75655-184">Este campo contém a versão do protocolo TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-184">This field contains the TLS protocol version.</span></span> <span data-ttu-id="75655-185">Os valores válidos são os seguintes:</span><span class="sxs-lookup"><span data-stu-id="75655-185">Valid values are as follows:</span></span><br /><span data-ttu-id="75655-186">- SSL 3.0: 0x0300</span><span class="sxs-lookup"><span data-stu-id="75655-186">- SSL 3.0: 0x0300</span></span><br /><span data-ttu-id="75655-187">- TLS 1.0: 0x0301</span><span class="sxs-lookup"><span data-stu-id="75655-187">- TLS 1.0: 0x0301</span></span><br /><span data-ttu-id="75655-188">- TLS 1.1: 0x0302</span><span class="sxs-lookup"><span data-stu-id="75655-188">- TLS 1.1: 0x0302</span></span><br /><span data-ttu-id="75655-189">- TLS 1.2: 0x0303</span><span class="sxs-lookup"><span data-stu-id="75655-189">- TLS 1.2: 0x0303</span></span><br /><span data-ttu-id="75655-190">- **TLS 1.3 <sup>11</sup>**: **0x0303**</span><span class="sxs-lookup"><span data-stu-id="75655-190">- **TLS 1.3 <sup>11</sup>**: **0x0303**</span></span> |
| <span data-ttu-id="75655-191">**Comprimento de 16 bits**</span><span class="sxs-lookup"><span data-stu-id="75655-191">**16-bit Length**</span></span>    | <span data-ttu-id="75655-192">Este campo contém o comprimento dos dados encapsulados no registo TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-192">This field contains the length of the data encapsulated in the TLS record.</span></span> |
| <span data-ttu-id="75655-193">**Tipo de aperto de mão de 8 bits**</span><span class="sxs-lookup"><span data-stu-id="75655-193">**8-bit Handshake Type**</span></span> | <span data-ttu-id="75655-194">Este campo contém o tipo de mensagem de aperto de mão.</span><span class="sxs-lookup"><span data-stu-id="75655-194">This field contains the handshake message type.</span></span> <span data-ttu-id="75655-195">Os valores válidos são os seguintes (\*as mensagens em **negrito** foram adicionadas em TLS 1.3):</span><span class="sxs-lookup"><span data-stu-id="75655-195">Valid values are as follows (\*messages in **bold** were added in TLS 1.3):</span></span><br /><span data-ttu-id="75655-196">- HelloRequest: 0x00</span><span class="sxs-lookup"><span data-stu-id="75655-196">- HelloRequest: 0x00</span></span><br /><span data-ttu-id="75655-197">- ClientHello: 0x01</span><span class="sxs-lookup"><span data-stu-id="75655-197">- ClientHello: 0x01</span></span><br /><span data-ttu-id="75655-198">- ServerHello: 0x02</span><span class="sxs-lookup"><span data-stu-id="75655-198">- ServerHello: 0x02</span></span><br /><span data-ttu-id="75655-199">- **HelloVerifyRequest**: **0x03**</span><span class="sxs-lookup"><span data-stu-id="75655-199">- **HelloVerifyRequest**: **0x03**</span></span><br /><span data-ttu-id="75655-200">- **NewSessionTicket**: **0x04**</span><span class="sxs-lookup"><span data-stu-id="75655-200">- **NewSessionTicket**: **0x04**</span></span><br /><span data-ttu-id="75655-201">- **EndOfEarlyData**: **0x05**</span><span class="sxs-lookup"><span data-stu-id="75655-201">- **EndOfEarlyData**: **0x05**</span></span><br /><span data-ttu-id="75655-202">- **CriptografadasTensions**: **0x08**</span><span class="sxs-lookup"><span data-stu-id="75655-202">- **EncryptedExtensions**: **0x08**</span></span><br /><span data-ttu-id="75655-203">- Certificado: 0x0B</span><span class="sxs-lookup"><span data-stu-id="75655-203">- Certificate: 0x0B</span></span><br /><span data-ttu-id="75655-204">- ServerKeyExchange: 0x0C</span><span class="sxs-lookup"><span data-stu-id="75655-204">- ServerKeyExchange: 0x0C</span></span><br /><span data-ttu-id="75655-205">- CertificadoRequest: 0x0D</span><span class="sxs-lookup"><span data-stu-id="75655-205">- CertificateRequest: 0x0D</span></span><br /><span data-ttu-id="75655-206">- ServerHelloDone: 0x0E</span><span class="sxs-lookup"><span data-stu-id="75655-206">- ServerHelloDone: 0x0E</span></span><br /><span data-ttu-id="75655-207">- CertificaçãoVerifical: 0x0F</span><span class="sxs-lookup"><span data-stu-id="75655-207">- CertificateVerify: 0x0F</span></span><br /><span data-ttu-id="75655-208">- ClientKeyExchange: 0x10</span><span class="sxs-lookup"><span data-stu-id="75655-208">- ClientKeyExchange: 0x10</span></span><br /><span data-ttu-id="75655-209">- Acabado: 0x14</span><span class="sxs-lookup"><span data-stu-id="75655-209">- Finished: 0x14</span></span><br /><span data-ttu-id="75655-210">- **KeyUpdate**: **0x18**</span><span class="sxs-lookup"><span data-stu-id="75655-210">- **KeyUpdate**: **0x18**</span></span><br /><span data-ttu-id="75655-211">- **MessageHash**: **0xFE**</span><span class="sxs-lookup"><span data-stu-id="75655-211">- **MessageHash**: **0xFE**</span></span> |
| <span data-ttu-id="75655-212">**Comprimento de 24 bits**</span><span class="sxs-lookup"><span data-stu-id="75655-212">**24-bit Length**</span></span>    | <span data-ttu-id="75655-213">Este campo contém o comprimento dos dados da mensagem de aperto de mão.</span><span class="sxs-lookup"><span data-stu-id="75655-213">This field contains the length of the handshake message data.</span></span> |

10. <span data-ttu-id="75655-214">No TLS 1.3 a mensagem ChangeCipherSpec já não é utilizada, embora ainda possa ser enviada por razões de compatibilidade, caso em que a mensagem é ignorada.</span><span class="sxs-lookup"><span data-stu-id="75655-214">In TLS 1.3 the ChangeCipherSpec message is no longer used, though it still may be sent for compatibility reasons in which case the message is ignored.</span></span>

11. <span data-ttu-id="75655-215">O TLS 1.3 teria tecnicamente um valor de 0x0304 se este regime fosse continuado, mas o protocolo foi alterado para ter a versão do protocolo real numa extensão, pelo que todos os registos TLS 1.3 utilizam 0x0303 nos campos da versão protocolar para retrocompatibilidade.</span><span class="sxs-lookup"><span data-stu-id="75655-215">TLS 1.3 would technically have a value of 0x0304 if this scheme was continued, but the protocol was changed to have the actual protocol version in an extension, so all TLS 1.3 records use 0x0303 in protocol version fields for backward-compatibility.</span></span>

### <a name="the-tls-handshake-and-tls-session"></a><span data-ttu-id="75655-216">O aperto de mão tls e sessão TLS</span><span class="sxs-lookup"><span data-stu-id="75655-216">The TLS Handshake and TLS Session</span></span>

<span data-ttu-id="75655-217">Um aperto de mão TLS típico (versões 1.0-1.2) é mostrado na Figura 3.</span><span class="sxs-lookup"><span data-stu-id="75655-217">A typical TLS handshake (versions 1.0-1.2) is shown in Figure 3.</span></span> <span data-ttu-id="75655-218">Um aperto de mão TLS começa quando o Cliente TLS envia uma mensagem *ClientHello* para um servidor TLS, indicando o seu desejo de iniciar uma sessão de TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-218">A TLS handshake begins when the TLS Client sends a *ClientHello* message to a TLS server, indicating its desire to start a TLS session.</span></span> <span data-ttu-id="75655-219">A mensagem contém informações sobre a encriptação que o cliente gostaria de usar para a sessão, juntamente com as informações usadas para gerar as teclas de sessão mais tarde no aperto de mão.</span><span class="sxs-lookup"><span data-stu-id="75655-219">The message contains information about the encryption the client would like to use for the session, along with information used to generate the session keys later in the handshake.</span></span> <span data-ttu-id="75655-220">Até que as teclas de sessão sejam geradas, todas as mensagens no aperto de mão TLS não são encriptadas.</span><span class="sxs-lookup"><span data-stu-id="75655-220">Until the session keys are generated, all messages in the TLS handshake are not encrypted.</span></span> <span data-ttu-id="75655-221">O TLS 1.3 altera um pouco o aperto de mão – os detalhes são apresentados na secção seguinte.</span><span class="sxs-lookup"><span data-stu-id="75655-221">TLS 1.3 changes the handshake somewhat – details are presented in the next section.</span></span>

<span data-ttu-id="75655-222">O Servidor TLS responde ao ClientHello com uma mensagem ServerHello, indicando uma seleção das opções de encriptação fornecidas pelo cliente.</span><span class="sxs-lookup"><span data-stu-id="75655-222">The TLS Server responds to the ClientHello with a ServerHello message, indicating a selection from the encryption options provided by the client.</span></span> <span data-ttu-id="75655-223">O ServerHello é seguido por uma mensagem de Certificado, na qual o servidor fornece um certificado digital para autenticar a sua identidade ao cliente.</span><span class="sxs-lookup"><span data-stu-id="75655-223">The ServerHello is followed by a Certificate message, in which the server provides a digital certificate to authenticate its identity to the client.</span></span> <span data-ttu-id="75655-224">Finalmente, o servidor envia uma mensagem ServerHelloDone para indicar que não tem mais mensagens para enviar.</span><span class="sxs-lookup"><span data-stu-id="75655-224">Finally, the server sends a ServerHelloDone message to indicate it has no more messages to send.</span></span> <span data-ttu-id="75655-225">O servidor pode enviar opcionalmente outras mensagens seguindo o ServerHello e em alguns casos pode não enviar uma mensagem de Certificado, daí a necessidade da mensagem ServerHelloDone.</span><span class="sxs-lookup"><span data-stu-id="75655-225">The server may optionally send other messages following the ServerHello and in some cases it may not send a Certificate message, hence the need for the ServerHelloDone message.</span></span>

<span data-ttu-id="75655-226">Uma vez que o cliente tenha recebido todas as mensagens do servidor, tem informações suficientes para gerar as teclas de sessão.</span><span class="sxs-lookup"><span data-stu-id="75655-226">Once the client has received all the server's messages, it has enough information to generate the session keys.</span></span> <span data-ttu-id="75655-227">O TLS faz isso criando uma parte partilhada de dados aleatórios *chamados Pre-Master Secret*, que é um tamanho fixo e é usado como uma semente para gerar todas as teclas necessárias uma vez que a encriptação é ativada.</span><span class="sxs-lookup"><span data-stu-id="75655-227">TLS does this by creating a shared bit of random data called the *Pre-Master Secret*, which is a fixed-size and is used as a seed to generate all the keys needed once encryption is enabled.</span></span> <span data-ttu-id="75655-228">O Segredo Pré-Mestre é encriptado utilizando o algoritmo de chave pública (por exemplo, RSA) especificado nas mensagens Hello (ver abaixo para obter informações sobre algoritmos de chaves públicas) e a chave pública fornecida pelo servidor no seu certificado.</span><span class="sxs-lookup"><span data-stu-id="75655-228">The Pre-Master Secret is encrypted using the public key algorithm (e.g. RSA) specified in the Hello messages (see below for information on public key algorithms) and the public key provided by the server in its certificate.</span></span> <span data-ttu-id="75655-229">Uma funcionalidade opcional de TLS chamada Chaves Pré-Partilhadas (PSK) permite cifrasuites que não usam um certificado, mas em vez disso usam um valor secreto partilhado entre os anfitriões (geralmente através de transferência física ou outro método seguro).</span><span class="sxs-lookup"><span data-stu-id="75655-229">An optional TLS feature called Pre-Shared Keys (PSK) enables ciphersuites that do not use a certificate but instead use a secret value shared between the hosts (usually through physical transfer or other secured method).</span></span> <span data-ttu-id="75655-230">O segredo partilhado é usado para gerar o Segredo Pré-Mestre em vez de usar uma mensagem encriptada para enviar o Segredo Pré-Mestre.</span><span class="sxs-lookup"><span data-stu-id="75655-230">The shared secret is used to generate the Pre-Master Secret instead of using an encrypted message to send the Pre-Master Secret.</span></span> <span data-ttu-id="75655-231">Veja a secção em Chaves Pré-Partilhadas abaixo.</span><span class="sxs-lookup"><span data-stu-id="75655-231">See the section on Pre-Shared Keys below.</span></span>

<span data-ttu-id="75655-232">O Pre-Master Secret encriptado é enviado para o servidor na mensagem ClientKeyExchange.</span><span class="sxs-lookup"><span data-stu-id="75655-232">The encrypted Pre-Master Secret is sent to the server in the ClientKeyExchange message.</span></span> <span data-ttu-id="75655-233">O servidor, ao receber a mensagem ClientKeyExchange, desencripta o Segredo Pré-Mestre usando a sua chave privada e procede à geração das teclas de sessão em paralelo com o cliente TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-233">The server, upon receiving the ClientKeyExchange message, decrypts the Pre-Master Secret using its private key and proceeds to generate the session keys in parallel with the TLS client.</span></span>

<span data-ttu-id="75655-234">Uma vez geradas as teclas de sessão, todas as mensagens adicionais podem ser encriptadas utilizando o algoritmo de tecla privada (por exemplo, AES) selecionado nas mensagens Hello.</span><span class="sxs-lookup"><span data-stu-id="75655-234">Once the session keys are generated, all further messages can be encrypted using the private-key algorithm (e.g. AES) selected in the Hello messages.</span></span> <span data-ttu-id="75655-235">Uma última mensagem não encriptada chamada ChangeCipherSpec é enviada pelo cliente e pelo servidor para indicar que todas as mensagens adicionais serão encriptadas.</span><span class="sxs-lookup"><span data-stu-id="75655-235">One final un-encrypted message called ChangeCipherSpec is sent by both the client and server to indicate that all further messages will be encrypted.</span></span>

<span data-ttu-id="75655-236">A primeira mensagem encriptada enviada pelo cliente e pelo servidor é também a mensagem final de aperto de mão TLS, chamada Finished.</span><span class="sxs-lookup"><span data-stu-id="75655-236">The first encrypted message sent by both the client and server is also the final TLS handshake message, called Finished.</span></span> <span data-ttu-id="75655-237">Esta mensagem contém um haxixe de todas as mensagens de aperto de mão recebidas e enviadas.</span><span class="sxs-lookup"><span data-stu-id="75655-237">This message contains a hash of all the handshake messages received and sent.</span></span> <span data-ttu-id="75655-238">Este haxixe é utilizado para verificar se nenhuma das mensagens no aperto de mão foi adulterada ou corrompida (indicando uma possível violação da segurança).</span><span class="sxs-lookup"><span data-stu-id="75655-238">This hash is used to verify that none of the messages in the handshake have been tampered with or corrupted (indicating a possible breach of security).</span></span>

<span data-ttu-id="75655-239">Uma vez recebidas as mensagens Acabadas e verificadas as hashes de aperto de mão, a sessão TLS começa e a aplicação começa a enviar e receber dados.</span><span class="sxs-lookup"><span data-stu-id="75655-239">Once the Finished messages are received and the handshake hashes are verified, the TLS session begins, and the application begins sending and receiving data.</span></span> <span data-ttu-id="75655-240">Todos os dados enviados por ambos os lados durante a sessão TLS são primeiro hashed usando o algoritmo de haxixe escolhido nas mensagens Hello (para fornecer integridade da mensagem) e encriptado usando o algoritmo de chave privada escolhido com as teclas de sessão geradas.</span><span class="sxs-lookup"><span data-stu-id="75655-240">All data sent by either side during the TLS session is first hashed using the hash algorithm chosen in the Hello messages (to provide message integrity) and encrypted using the chosen private-key algorithm with the generated session keys.</span></span>

<span data-ttu-id="75655-241">Finalmente, uma sessão TLS só pode ser terminada com sucesso se o Cliente ou o Servidor optarem por fazê-lo.</span><span class="sxs-lookup"><span data-stu-id="75655-241">Finally, a TLS session can only be successfully ended if either the Client or Server chooses to do so.</span></span> <span data-ttu-id="75655-242">Uma sessão truncada é considerada uma falha de segurança (uma vez que um intruso pode estar a tentar evitar que todos os dados sejam enviados) pelo que é enviada uma notificação especial quando ambos os lados querem terminar a sessão, chamado alerta CloseNotify.</span><span class="sxs-lookup"><span data-stu-id="75655-242">A truncated session is considered a security breach (since an attacker may be attempting to prevent all the data being sent from being received) so a special notification is sent when either side wants to end the session, called a CloseNotify alert.</span></span> <span data-ttu-id="75655-243">Tanto o cliente como o servidor devem enviar e processar um alerta CloseNotify para uma paragem de sessão bem sucedida.</span><span class="sxs-lookup"><span data-stu-id="75655-243">Both the client and server must send and process a CloseNotify alert for a successful session shutdown.</span></span>

![Diagrama de um aperto de mão típico do TLS.](media/image4.png)

<span data-ttu-id="75655-245">Figura 3- Aperto de mão típico do TLS</span><span class="sxs-lookup"><span data-stu-id="75655-245">Figure 3- Typical TLS handshake</span></span>

### <a name="tls-13-handshake"></a><span data-ttu-id="75655-246">TLS 1.3 Aperto de Mão</span><span class="sxs-lookup"><span data-stu-id="75655-246">TLS 1.3 Handshake</span></span>

<span data-ttu-id="75655-247">O TLS 1.3 é uma revisão bastante importante do protocolo TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-247">TLS 1.3 is a fairly major overhaul of the TLS protocol.</span></span> <span data-ttu-id="75655-248">A grande maioria das alterações foram feitas ao aperto de mão para aumentar a segurança e o desempenho.</span><span class="sxs-lookup"><span data-stu-id="75655-248">The vast majority of the changes were made to the handshake to increase security and performance.</span></span> <span data-ttu-id="75655-249">Um aperto de mão típico TLS 1.3 é mostrado na Figura 4.</span><span class="sxs-lookup"><span data-stu-id="75655-249">A typical TLS 1.3 handshake is shown in Figure 4.</span></span> <span data-ttu-id="75655-250">A diferença primária pode ser observada no número de trocas entre o servidor e o cliente.</span><span class="sxs-lookup"><span data-stu-id="75655-250">The primary difference can be seen in the number of exchanges between the server and client.</span></span>

<span data-ttu-id="75655-251">No TLS 1.2 e mais cedo, o servidor enviaria dois voos<sup>12</sup> de mensagens – primeiro o ServerHello e depois uma mensagem ChangeCipherSpec antes de enviar a mensagem terminada encriptada que termina o aperto de mão.</span><span class="sxs-lookup"><span data-stu-id="75655-251">In TLS 1.2 and earlier, the server would send two flights<sup>12</sup> of messages – first the ServerHello and then a ChangeCipherSpec message before sending the encrypted Finished message that ends the handshake.</span></span> <span data-ttu-id="75655-252">No TLS 1.3, o servidor envia tudo no primeiro voo – ServerHello, extensões, certificado e Terminado.</span><span class="sxs-lookup"><span data-stu-id="75655-252">In TLS 1.3, the server sends everything in the first flight – ServerHello, extensions, certificate, and Finished.</span></span> <span data-ttu-id="75655-253">A mensagem ChangeCipherSpec foi eliminada e o servidor gera as suas teclas de sessão e começa a encriptar mensagens de aperto de mão imediatamente após o ServerHello.</span><span class="sxs-lookup"><span data-stu-id="75655-253">The ChangeCipherSpec message was eliminated and the server generates its session keys and starts encrypting handshake messages immediately following the ServerHello.</span></span>

<span data-ttu-id="75655-254">O novo acordo significa que mais do aperto de mão TLS está protegido por encriptação, limitando a quantidade de dados de texto simples a que um intruso pode aceder.</span><span class="sxs-lookup"><span data-stu-id="75655-254">The new arrangement means that more of the TLS handshake is protected by encryption, limiting the amount of plaintext data an attacker can access.</span></span> <span data-ttu-id="75655-255">Além disso, a remoção do segundo voo do servidor (que era apenas um ChangeCipherSpec seguido de um Terminado) significa que um cliente TLS já não precisa de esperar para começar a transmitir dados da aplicação – assim que o cliente envia a sua própria mensagem Terminada, a sessão é iniciada.</span><span class="sxs-lookup"><span data-stu-id="75655-255">Additionally, the removal of the second server flight (which was just a ChangeCipherSpec followed by a Finished) means that a TLS client no longer needs to wait to start transmitting application data – as soon as the client sends its own Finished message the session is started.</span></span>

12. <span data-ttu-id="75655-256">Um voo é simplesmente uma coleção de mensagens TLS enviadas simultaneamente em grupo.</span><span class="sxs-lookup"><span data-stu-id="75655-256">A flight is simply a collection of TLS messages sent simultaneously in a group.</span></span>

![Diagrama de um Aperto de Mão TLS 1.3.](media/image5.png)

<span data-ttu-id="75655-258">Figura 4 - TLS 1.3 Aperto de mão</span><span class="sxs-lookup"><span data-stu-id="75655-258">Figure 4 - TLS 1.3 Handshake</span></span>

> [!NOTE]
> <span data-ttu-id="75655-259">*O TLS 1.3 também introduziu a noção de "Dados Antecipados" e 0-RTT (Tempo de Viagem Redonda Zero), o que significa que alguns dados da aplicação podem ser enviados no primeiro voo de mensagens. Esta funcionalidade opcional foi adicionada principalmente como uma otimização para a capacidade de resposta do navegador web (por exemplo, para enviar cabeçalhos HTTP precoces para começar a renderizar uma página). A partir de Azure RTOS 6.0 esta funcionalidade NÃO é suportada.*</span><span class="sxs-lookup"><span data-stu-id="75655-259">*TLS 1.3 also introduced the notion of "Early data" and 0-RTT (Zero Round Trip Time), meaning that some application data can be sent in the first flight of messages. This optional feature was added primarily as an optimization for web browser responsiveness (e.g. to send early HTTP headers to start rendering a page). As of Azure RTOS 6.0 this feature is NOT supported.*</span></span>

### <a name="initialization"></a><span data-ttu-id="75655-260">Inicialização</span><span class="sxs-lookup"><span data-stu-id="75655-260">Initialization</span></span>

<span data-ttu-id="75655-261">A pilha NetX ou NetXDuo TCP/IP deve ser inicializada antes da utilização do NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-261">The NetX or NetXDuo TCP/IP stack must be initialized prior to using NetX Secure TLS.</span></span> <span data-ttu-id="75655-262">Consulte o Guia de Utilizador NetX ou NetXDuo para obter informações sobre como inicializar corretamente a pilha TCP/IP.</span><span class="sxs-lookup"><span data-stu-id="75655-262">Refer to the NetX or NetXDuo User Guide for information on how to properly initialize the TCP/IP stack.</span></span>

<span data-ttu-id="75655-263">Uma vez iniciada a stack NetX TCP/IP, o TLS pode ser ativado.</span><span class="sxs-lookup"><span data-stu-id="75655-263">Once the NetX TCP/IP stack has been initialized, TLS can be enabled.</span></span> <span data-ttu-id="75655-264">Internamente, todo o tráfego e processamento da rede TLS é tratado pela pilha NetX/NetXDuo sem necessidade de intervenção do utilizador.</span><span class="sxs-lookup"><span data-stu-id="75655-264">Internally, all TLS network traffic and processing is handled by the NetX/NetXDuo stack without requiring user intervention.</span></span> <span data-ttu-id="75655-265">No entanto, o TLS tem alguns requisitos específicos que devem ser tratados separadamente da pilha de rede subjacente.</span><span class="sxs-lookup"><span data-stu-id="75655-265">However, TLS has some specific requirements that must be handled separately from the underlying network stack.</span></span> <span data-ttu-id="75655-266">Estes parâmetros são atribuídos ao bloco de controlo TLS chamado ***NX_SECURE_TLS_SESSION** _ utilizando o serviço _ *_nx_secure_tls_session_create_** .</span><span class="sxs-lookup"><span data-stu-id="75655-266">These parameters are assigned to the TLS control block called ***NX_SECURE_TLS_SESSION** _ using the _ *_nx_secure_tls_session_create_** service.</span></span>

<span data-ttu-id="75655-267">O TLS tem dois modos, Server e Cliente, qualquer um dos quais pode ser ativado numa aplicação (mas apenas um modo por tomada NetX), e cada um tem os seus próprios requisitos específicos, detalhados abaixo.</span><span class="sxs-lookup"><span data-stu-id="75655-267">TLS has two modes, Server and Client, either of which may be enabled in an application (but only one mode per NetX socket), and each have their own specific requirements, detailed below.</span></span>

<span data-ttu-id="75655-268">Em ambos os modos, o NetX Secure TLS requer a criação e configuração de uma tomada TCP (\***NX_TCP_SOCKET** _) para comunicações TCP com o anfitrião remoto.</span><span class="sxs-lookup"><span data-stu-id="75655-268">In either mode, NetX Secure TLS requires a TCP socket (\***NX_TCP_SOCKET** _) to be created and set up for TCP communications with the remote host.</span></span> <span data-ttu-id="75655-269">A tomada TCP é atribuída a uma instância de sessão TLS com o serviço _ *_nx_secure_tls_session_start*_\* detalhado abaixo.</span><span class="sxs-lookup"><span data-stu-id="75655-269">The TCP socket is assigned to a TLS session instance with the _ *_nx_secure_tls_session_start_*\* service, detailed below.</span></span>

### <a name="initialization--tls-server"></a><span data-ttu-id="75655-270">Inicialização - Servidor TLS</span><span class="sxs-lookup"><span data-stu-id="75655-270">Initialization – TLS Server</span></span>

<span data-ttu-id="75655-271">Além de uma tomada TCP, o modo NetX Secure TLS Server requer um *Certificado Digital*, que é um documento utilizado para identificar o servidor TLS ao cliente TLS de ligação, e os certificados correspondentes *Private Key*, normalmente para o algoritmo de encriptação RSA.</span><span class="sxs-lookup"><span data-stu-id="75655-271">In addition to a TCP socket, NetX Secure TLS Server mode requires a *Digital Certificate*, which is a document used to identify the TLS server to the connecting TLS client, and the certificates corresponding *Private Key*, usually for the RSA encryption algorithm.</span></span> <span data-ttu-id="75655-272">A norma International Telecommunications Union X.509 especifica o formato de certificado utilizado pela TLS e existem inúmeros utilitários para a criação de certificados digitais X.509.</span><span class="sxs-lookup"><span data-stu-id="75655-272">The International Telecommunications Union X.509 standard specifies the certificate format used by TLS and there are numerous utilities for creating X.509 digital certificates.</span></span>

<span data-ttu-id="75655-273">Para o NetX Secure TLS, o certificado X.509 deve ser codificado bináriamente utilizando o formato de Regras de Codificação (DER) distintos de ASN.1.</span><span class="sxs-lookup"><span data-stu-id="75655-273">For NetX Secure TLS, the X.509 certificate must be binary-encoded using the Distinguished Encoding Rules (DER) format of ASN.1.</span></span> <span data-ttu-id="75655-274">DER é o formato binário padrão TLS over-the-wire para certificados.</span><span class="sxs-lookup"><span data-stu-id="75655-274">DER is the standard TLS over-the-wire binary format for certificates.</span></span>

<span data-ttu-id="75655-275">A chave privada associada ao certificado fornecido deve estar em DER-Encoded formato PKCS#1.</span><span class="sxs-lookup"><span data-stu-id="75655-275">The private key associated with the provided certificate must be in DER-Encoded PKCS#1 format.</span></span> <span data-ttu-id="75655-276">A chave privada é utilizada apenas no dispositivo e nunca será transmitida através do fio.</span><span class="sxs-lookup"><span data-stu-id="75655-276">The private key is only used on the device and will never be transmitted over the wire.</span></span> <span data-ttu-id="75655-277">Mantenha as chaves privadas seguras, pois fornecem a segurança das comunicações TLS!</span><span class="sxs-lookup"><span data-stu-id="75655-277">Keep private keys safe as they provide the security for TLS communications!</span></span>

<span data-ttu-id="75655-278">Para inicializar o certificado do Servidor TLS, a aplicação deve fornecer um ponteiro a um tampão contendo o certificado X.509 codificado pelo DER e dados chave privados opcionais de PKCS#1 RSA utilizando o serviço ***nx_secure_x509_certificate_intialize** _ que povoa a estrutura _ *NX_SECURE_X509_CERT** com os dados de certificado adequados para utilização por TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-278">To initialize the TLS Server certificate, the application must provide a pointer to a buffer containing the DER-encoded X.509 certificate and optional DER-encoded PKCS#1 RSA private key data using the ***nx_secure_x509_certificate_intialize** _ service, which populates the _ *NX_SECURE_X509_CERT** structure with the appropriate certificate data for use by TLS.</span></span>

<span data-ttu-id="75655-279">Uma vez inicializado o certificado do servidor, este deve ser adicionado ao bloco de controlo TLS utilizando o serviço ***nx_secure_tls_local_certificate_add.***</span><span class="sxs-lookup"><span data-stu-id="75655-279">Once the server certificate has been initialized, it must be added to the TLS control block using the ***nx_secure_tls_local_certificate_add*** service.</span></span>

<span data-ttu-id="75655-280">Uma vez adicionado o certificado do servidor ao bloco de controlo TLS, a tomada pode ser utilizada para estabelecer uma ligação segura do Servidor TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-280">Once the server's certificate has been added to the TLS control block, the socket may be used to establish a secure TLS Server connection.</span></span>

### <a name="initialization--tls-client"></a><span data-ttu-id="75655-281">Inicialização - Cliente TLS</span><span class="sxs-lookup"><span data-stu-id="75655-281">Initialization – TLS Client</span></span>

<span data-ttu-id="75655-282">O modo cliente NetX Secure TLS requer uma Loja de *Certificados Fidedignas,* que é uma coleção de certificados digitais codificados X.509 das Autoridades de Certificados Fidedignas (CA's).</span><span class="sxs-lookup"><span data-stu-id="75655-282">NetX Secure TLS Client mode requires a *Trusted Certificate Store*, which is a collection of X.509-encoded digital certificates from trusted Certificate Authorities (CA's).</span></span> <span data-ttu-id="75655-283">Estes certificados são assumidos pelo protocolo TLS como "confiáveis" e servem de base para autenticar certificados fornecidos por entidades de servidores TLS ao Cliente NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-283">These certificates are assumed by the TLS protocol to be "trusted" and serve as the basis for authenticating certificates provided by TLS server entities to NetX Secure TLS Client.</span></span>

<span data-ttu-id="75655-284">Um certificado de CA fidedigno pode ser *auto-assinado* ou assinado por outra AC, caso em que esse certificado é chamado de *Ac Intermediário* (ICA).</span><span class="sxs-lookup"><span data-stu-id="75655-284">A trusted CA certificate may either be *self-signed* or signed by another CA, in which case that certificate is called an *Intermediate CA* (ICA).</span></span> <span data-ttu-id="75655-285">Numa aplicação típica de TLS, o servidor fornece os certificados ICA juntamente com o seu certificado de servidor, mas o único requisito para a autenticação bem sucedida é que uma cadeia de emitentes (certificados usados para assinar outros certificados) pode ser rastreada do certificado do servidor de volta para um certificado de CA fidedigno na Loja de Certificados Fidedignos.</span><span class="sxs-lookup"><span data-stu-id="75655-285">In a typical TLS application, the server provides the ICA certificates along with its server certificate, but the only requirement for successful authentication is that a chain of issuers (certificates used to sign other certificates) can be traced from the server certificate back to a trusted CA certificate in the Trusted Certificate Store.</span></span> <span data-ttu-id="75655-286">Esta cadeia é conhecida como uma *cadeia de fiéis* ou cadeia de *certificados.*</span><span class="sxs-lookup"><span data-stu-id="75655-286">This chain is known as a  *chain of trust* or *certificate chain*.</span></span>

<span data-ttu-id="75655-287">Para inicializar um certificado ca ou ica fidedigno, o pedido deve fornecer um ponteiro a um tampão contendo o certificado X.509 codificado pelo DER utilizando o serviço ***nx_secure_x509_certificate_intialize** _ que povoa a estrutura _ *NX_SECURE_X509_CERT** com os dados de certificado adequados para utilização pela TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-287">To initialize a trusted CA or ICA certificate, the application must provide a pointer to a buffer containing the DER-encoded X.509 certificate using the ***nx_secure_x509_certificate_intialize** _ service, which populates the _ *NX_SECURE_X509_CERT** structure with the appropriate certificate data for use by TLS.</span></span>

<span data-ttu-id="75655-288">Os certificados fidedignos que foram inicializados são adicionados ao bloco de controlo TLS utilizando o serviço ***nx_secure_tls_trusted_certificate_add.***</span><span class="sxs-lookup"><span data-stu-id="75655-288">Trusted certificates that have been initialized are then added to the TLS control block using the ***nx_secure_tls_trusted_certificate_add*** service.</span></span> <span data-ttu-id="75655-289">A não adição de um certificado fará com que a sessão do Cliente TLS falhe, uma vez que não haverá forma de o protocolo TLS autenticar os anfitriões remotos do servidor TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-289">Failure to add a certificate will cause the TLS Client session to fail as there will be no way for the TLS protocol to authenticate remote TLS server hosts.</span></span>

<span data-ttu-id="75655-290">O Cliente TLS também precisa de espaço para que o certificado do servidor de entrada seja atribuído (assumindo que não está a ser utilizado um modo chave pré-partilhado).</span><span class="sxs-lookup"><span data-stu-id="75655-290">The TLS Client also needs space for the incoming server certificate to be allocated (assuming a Pre-Shared Key mode is not being used).</span></span> <span data-ttu-id="75655-291">A partir do NetX Secure TLS 5.12, já não é necessário que a aplicação aloque espaço para certificado remoto.</span><span class="sxs-lookup"><span data-stu-id="75655-291">As of NetX Secure TLS 5.12, it is no longer necessary for the application to allocate space for remote certificate.</span></span> <span data-ttu-id="75655-292">No entanto, a opção de atribuição de espaço para um certificado de servidor ainda se encontra disponível e os certificados atribuídos pelo utilizador serão utilizados antes da otimização do tampão de certificado interno <sup>13</sup> – consulte o serviço ***de nx_secure_tls_remote_certificate_allocate*** para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="75655-292">However, the legacy option to allocate space for a server certificate is still available and user-allocated certificates will be used before the internal certificate buffer optimization <sup>13</sup> – see the ***nx_secure_tls_remote_certificate_allocate*** service for more information.</span></span>

<span data-ttu-id="75655-293">Uma vez criada a Loja de Certificados Fidedignos e alocado espaço para o certificado do servidor, a tomada poderá ser utilizada para estabelecer uma ligação segura ao Cliente TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-293">Once the Trusted Certificate Store has been created and space for the server certificate has been allocated, the socket may be used to establish a secure TLS Client connection.</span></span>

13. <span data-ttu-id="75655-294">A otimização utiliza o "tampão de pacote" fornecido pela aplicação do utilizador para a sessão de tls utilizando *nx_secure_tls_session_packet_buffer_set* para alocar as estruturas de análise X.509 em vez de utilizar as estruturas fornecidas pelo utilizador utilizadas em versões anteriores do NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-294">The optimization utilizes the “packet buffer” supplied by the user application to the tls session using *nx_secure_tls_session_packet_buffer_set* to allocate the X.509 parsing structures instead of using the user-supplied structures used in earlier versions of NetX Secure TLS.</span></span> <span data-ttu-id="75655-295">Existe uma possibilidade improvável de encontrar uma cadeia de certificados que exceda o tamanho do tampão do pacote, caso em que o tamanho do tampão do pacote pode ser aumentado ou *nx_secure_tls _remote_certificate_allocate* pode ser utilizado para alocar mais espaço para a cadeia de certificados.</span><span class="sxs-lookup"><span data-stu-id="75655-295">There is an unlikely possibility of encountering a certificate chain exceeding the size of the packet buffer in which case either the packet buffer size may be increased or *nx_secure_tls _remote_certificate_allocate* may be used to allocate more space for the certificate chain.</span></span>

### <a name="application-interface-calls"></a><span data-ttu-id="75655-296">Chamadas de Interface de Aplicação</span><span class="sxs-lookup"><span data-stu-id="75655-296">Application Interface Calls</span></span>

<span data-ttu-id="75655-297">As aplicações NetX Secure TLS normalmente fazem chamadas de função a partir de linhas de aplicação que funcionam sob o ThreadX RTOS.</span><span class="sxs-lookup"><span data-stu-id="75655-297">NetX Secure TLS applications will typically make function calls from within application threads running under the ThreadX RTOS.</span></span> <span data-ttu-id="75655-298">Alguma inicialização, nomeadamente para os protocolos de comunicações de rede subjacentes (por exemplo, TCP e IP) pode ser chamada a partir de \***tx_application_define\*.**</span><span class="sxs-lookup"><span data-stu-id="75655-298">Some initialization, particularly for the underlying network communications protocols (e.g. TCP and IP) may be called from \***tx_application_define\*.**</span></span> <span data-ttu-id="75655-299">Consulte o Guia do Utilizador NetX/NetXDuo para obter mais informações sobre a inicialização das comunicações de rede.</span><span class="sxs-lookup"><span data-stu-id="75655-299">See the NetX/NetXDuo User Guide for more information on initializing network communications.</span></span>

<span data-ttu-id="75655-300">O TLS utiliza fortemente as rotinas de encriptação que são operações intensivas de processador.</span><span class="sxs-lookup"><span data-stu-id="75655-300">TLS makes heavy use of encryption routines which are processor-intensive operations.</span></span> <span data-ttu-id="75655-301">Geralmente, estas operações serão realizadas no contexto da linha de chamada.</span><span class="sxs-lookup"><span data-stu-id="75655-301">Generally, these operations will be performed within the context of calling thread.</span></span>

### <a name="tls-session-start"></a><span data-ttu-id="75655-302">Início da sessão TLS</span><span class="sxs-lookup"><span data-stu-id="75655-302">TLS Session Start</span></span>

<span data-ttu-id="75655-303">O TLS requer um protocolo de rede de camadas de transporte subjacente para funcionar.</span><span class="sxs-lookup"><span data-stu-id="75655-303">TLS requires an underlying transport-layer network protocol in order to function.</span></span> <span data-ttu-id="75655-304">O protocolo normalmente utilizado é TCP.</span><span class="sxs-lookup"><span data-stu-id="75655-304">The protocol typically used is TCP.</span></span> <span data-ttu-id="75655-305">Para estabelecer uma sessão NetX Secure TLS, deve ser estabelecida uma ligação TCP utilizando a API NetX/NetXDuo TCP.</span><span class="sxs-lookup"><span data-stu-id="75655-305">In order to establish a NetX Secure TLS session, a TCP connection must be established using the NetX/NetXDuo TCP API.</span></span> <span data-ttu-id="75655-306">Deve ser criada uma **NX_TCP_SOCKET** e uma ligação estabelecida utilizando os **serviços _nx_tcp_server_socket_listen_ _ *e _*_nx_tcp_server_socket_accept_*_ (para o Servidor TLS) ou o\* serviço de _nx_tcp_client_socket_connect_ _(para*\* o Cliente TLS).</span><span class="sxs-lookup"><span data-stu-id="75655-306">An **NX_TCP_SOCKET** must be created and a connection established using the **_nx_tcp_server_socket_listen_*_ and _*_nx_tcp_server_socket_accept_*_ services (for TLS Server) or the _*_nx_tcp_client_socket_connect_** service (for TLS Client).</span></span>

<span data-ttu-id="75655-307">Uma vez estabelecida uma ligação TCP, a tomada TCP é então passada para o ***serviço nx_secure_tls_session_start.***</span><span class="sxs-lookup"><span data-stu-id="75655-307">Once a TCP connection has been established, the TCP socket is then passed to the ***nx_secure_tls_session_start*** service.</span></span>

### <a name="tls-packet-allocation"></a><span data-ttu-id="75655-308">Alocação de pacotes TLS</span><span class="sxs-lookup"><span data-stu-id="75655-308">TLS Packet Allocation</span></span>

<span data-ttu-id="75655-309">O NetX Secure TLS utiliza a mesma estrutura de pacotes que o NetX/NetXDuo TCP (***NX_PACKET** _) exceto que, em vez de ligar para o serviço _*_nx_packet_allocate,_*_ o serviço _ *_nx_secure_tls_packet_allocate_** deve ser chamado para que o espaço para o cabeçalho TLS possa ser devidamente atribuído.</span><span class="sxs-lookup"><span data-stu-id="75655-309">NetX Secure TLS uses the same packet structure as NetX/NetXDuo TCP (***NX_PACKET** _) except that instead of calling the _*_nx_packet_allocate_*_ service, the _ *_nx_secure_tls_packet_allocate_** service must be called so that space for the TLS header may be allocated properly.</span></span>

### <a name="tls-session-send"></a><span data-ttu-id="75655-310">TLS Sessão Enviar</span><span class="sxs-lookup"><span data-stu-id="75655-310">TLS Session Send</span></span>

<span data-ttu-id="75655-311">Uma vez iniciada a sessão TLS, a aplicação poderá enviar dados utilizando o serviço \***nx_secure_tls_session_send** _ .</span><span class="sxs-lookup"><span data-stu-id="75655-311">Once the TLS session has started, the application may send data using the \***nx_secure_tls_session_send** _ service.</span></span> <span data-ttu-id="75655-312">O serviço de envio é idêntico em uso ao serviço _*_nx_tcp_socket_send,_*_ tomando uma estrutura de dados _*_NX_PACKET_*_ contendo os dados enviados, apenas que os dados serão encriptados pela pilha NX Secure TLS antes de serem enviados, e o pacote deve ser atribuído usando _\*_nx_secure_tls_packet_allocate_\*\*.</span><span class="sxs-lookup"><span data-stu-id="75655-312">The send service is identical in use to the _*_nx_tcp_socket_send_*_ service, taking an _*_NX_PACKET_*_ data structure containing the data being sent, only that data will be encrypted by the NX Secure TLS stack before being sent, and the packet must be allocated using _\*_nx_secure_tls_packet_allocate_\*\*.</span></span>

### <a name="tls-session-receive"></a><span data-ttu-id="75655-313">Sessão TLS receber</span><span class="sxs-lookup"><span data-stu-id="75655-313">TLS Session Receive</span></span>

<span data-ttu-id="75655-314">Uma vez iniciada a sessão TLS, a aplicação pode começar a receber dados utilizando o serviço \***nx_secure_tls_session_receive** _ .</span><span class="sxs-lookup"><span data-stu-id="75655-314">Once the TLS session has started, the application may begin receiving data using the \***nx_secure_tls_session_receive** _ service.</span></span> <span data-ttu-id="75655-315">Tal como o envio da Sessão TLS, este serviço é idêntico em uso para _\*_nx_tcp_socket_receive_\*\*, exceto que os dados de entrada são desencriptados e verificados pela pilha TLS antes de serem devolvidos na estrutura do pacote.</span><span class="sxs-lookup"><span data-stu-id="75655-315">Like the TLS Session send, this service is identical in use to _\*_nx_tcp_socket_receive_\*\*, except that the incoming data is decrypted and verified by the TLS stack before being returned in the packet structure.</span></span>

### <a name="tls-session-close"></a><span data-ttu-id="75655-316">Sessão TLS fechar</span><span class="sxs-lookup"><span data-stu-id="75655-316">TLS Session Close</span></span>

<span data-ttu-id="75655-317">Uma vez concluída uma sessão TLS, tanto o cliente TLS como o servidor devem enviar um alerta CloseNotify para o outro lado para encerrar a sessão.</span><span class="sxs-lookup"><span data-stu-id="75655-317">Once a TLS session is complete, both the TLS client and server must send a CloseNotify alert to the other side to shut down the session.</span></span> <span data-ttu-id="75655-318">Ambas as partes devem receber e processar o alerta para garantir uma paragem de sessão bem sucedida.</span><span class="sxs-lookup"><span data-stu-id="75655-318">Both sides must receive and process the alert to ensure a successful session shutdown.</span></span>

<span data-ttu-id="75655-319">Se o anfitrião remoto enviar um alerta CloseNotify, qualquer chamada para o serviço ***nx_secure_tls_session_receive** _ processará o alerta, enviará o alerta correspondente de volta para o hospedeiro remoto e devolverá um valor de _*_NX_SECURE_TLS_SESSION_CLOSED_\*\*.</span><span class="sxs-lookup"><span data-stu-id="75655-319">If the remote host sends a CloseNotify alert, any calls to the ***nx_secure_tls_session_receive** _ service will process the alert, send the corresponding alert back to the remote host, and return a value of _*_NX_SECURE_TLS_SESSION_CLOSED_\*\*.</span></span> <span data-ttu-id="75655-320">Uma vez encerrada a sessão, quaisquer outras tentativas de enviar ou receber dados com essa sessão TLS falharão.</span><span class="sxs-lookup"><span data-stu-id="75655-320">Once the session is closed, any further attempts to send or receive data with that TLS session will fail.</span></span>

<span data-ttu-id="75655-321">Se a aplicação pretender encerrar a sessão TLS, o serviço \***nx_secure_tls_session_end** _ deve ser chamado.</span><span class="sxs-lookup"><span data-stu-id="75655-321">If the application wishes to close the TLS session, the \***nx_secure_tls_session_end** _ service must be called.</span></span> <span data-ttu-id="75655-322">O serviço enviará o alerta CloseNotify e processará a resposta CloseNotify.</span><span class="sxs-lookup"><span data-stu-id="75655-322">The service will send the CloseNotify alert and process the response CloseNotify.</span></span> <span data-ttu-id="75655-323">Se a resposta não for recebida, será devolvido um erro de _ *_NX_SECURE_TLS_SESSION_CLOSE_FAIL_*\* indicando que a sessão TLS não foi completamente encerrada, uma possível falha de segurança.</span><span class="sxs-lookup"><span data-stu-id="75655-323">If the response is not received, an error value of _ *_NX_SECURE_TLS_SESSION_CLOSE_FAIL_*\* will be returned, indicating that the TLS session was not cleanly shutdown, a possible security breach.</span></span>

### <a name="tls-alerts"></a><span data-ttu-id="75655-324">Alertas TLS</span><span class="sxs-lookup"><span data-stu-id="75655-324">TLS Alerts</span></span>

<span data-ttu-id="75655-325">TLS é projetado para fornecer a máxima segurança, por isso qualquer comportamento errante no protocolo é considerado uma potencial falha de segurança.</span><span class="sxs-lookup"><span data-stu-id="75655-325">TLS is designed to provide maximum security, so any errant behavior in the protocol is considered a potential security breach.</span></span> <span data-ttu-id="75655-326">Por esta razão, quaisquer erros no processamento de mensagens ou encriptação/desencriptação são considerados erros fatais que terminam o aperto de mão ou a sessão imediatamente.</span><span class="sxs-lookup"><span data-stu-id="75655-326">For this reason, any errors in message processing or encryption/decryption are considered fatal errors that terminate the handshake or session immediately.</span></span>

<span data-ttu-id="75655-327">Embora os erros de manuseamento de uma aplicação local sejam relativamente simples, o anfitrião remoto precisa de saber que ocorreu um erro para lidar adequadamente com a situação e evitar eventuais possíveis falhas de segurança.</span><span class="sxs-lookup"><span data-stu-id="75655-327">While handling errors in a local application is relatively straightforward, the remote host needs to know that an error has occurred in order to properly handle the situation and prevent any further possible security breaches.</span></span> <span data-ttu-id="75655-328">Por esta razão, o TLS enviará uma mensagem *de alerta* ao anfitrião remoto em qualquer erro.</span><span class="sxs-lookup"><span data-stu-id="75655-328">For this reason, TLS will send an *Alert* message to the remote host upon any error.</span></span>

<span data-ttu-id="75655-329">Os alertas são tratados da mesma forma que qualquer outra mensagem TLS e são encriptados durante a sessão para impedir que um intruso recolha informações do tipo de alerta fornecido.</span><span class="sxs-lookup"><span data-stu-id="75655-329">Alerts are treated in the same manner as any other TLS messages and are encrypted during the session to prevent an attacker from gathering information from the type of alert provided.</span></span> <span data-ttu-id="75655-330">Durante o aperto de mão, os alertas enviados são limitados no âmbito para limitar a quantidade de informação que poderia ser obtida por um potencial atacante.</span><span class="sxs-lookup"><span data-stu-id="75655-330">During the handshake, the alerts sent are limited in scope to limit the amount of information that could be obtained by a potential attacker.</span></span>

<span data-ttu-id="75655-331">O alerta CloseNotify, usado para encerrar a sessão TLS, é o único alerta não fatal.</span><span class="sxs-lookup"><span data-stu-id="75655-331">The CloseNotify alert, used to close the TLS session, is the only non-fatal alert.</span></span> <span data-ttu-id="75655-332">Embora seja considerado um alerta e enviado como uma mensagem de alerta, um CloseNotify é diferente de outros alertas na medida em que não indica que tenha ocorrido um erro.</span><span class="sxs-lookup"><span data-stu-id="75655-332">While it is considered an alert and sent as an alert message, a CloseNotify is unlike other alerts in that it does not indicate an error has occurred.</span></span>

<span data-ttu-id="75655-333">O valor de alerta e "nível" (os níveis são "alerta" e "fatais" – a maioria dos alertas TLS são "fatais") são definidos nos RFCs TLS e indicam o tipo de erro que ocorreu.</span><span class="sxs-lookup"><span data-stu-id="75655-333">The alert value and "level" (levels are "warning" and "fatal" – most TLS alerts are "fatal") are defined in the TLS RFCs and indicate the type of error that occurred.</span></span> <span data-ttu-id="75655-334">A maioria dos alertas TLS para além do CloseNotify pode ser considerado uma indicação de um potencial problema de segurança e resultará na abortar a sessão TLS ou o aperto de mão.</span><span class="sxs-lookup"><span data-stu-id="75655-334">Most TLS Alerts other than CloseNotify can be considered an indication of a potential security issue and will result in the TLS session or handshake being aborted.</span></span> <span data-ttu-id="75655-335">Se qualquer chamada da API TLS **voltar NX_SECURE_TLS_ALERT_RECEIVED** (0x114), o serviço API **_nx_secure_tls_session_alert_value_get_** (novo na versão 5.12 da NetX Secure TLS) pode ser utilizado para recuperar o valor e o nível de alerta TLS para que a aplicação utilize para quaisquer decisões relativas a respostas a questões de segurança.</span><span class="sxs-lookup"><span data-stu-id="75655-335">If any TLS API call returns **NX_SECURE_TLS_ALERT_RECEIVED** (0x114), the API service **_nx_secure_tls_session_alert_value_get_** (new in NetX Secure TLS version 5.12) may be used to retrieve the TLS alert value and level for the application to use for any decisions regarding responses to security issues.</span></span> <span data-ttu-id="75655-336">Na maioria dos casos, qualquer alerta recebido do hospedeiro remoto que não o CloseNotify deve ser considerado um erro fatal, embora existam algumas excptions – consulte os RFCs TLS para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="75655-336">In most cases, any alert received from the remote host other than CloseNotify should be considered a fatal error, though there are some excptions – see the TLS RFCs for more information.</span></span>

### <a name="tls-session-renegotiation"></a><span data-ttu-id="75655-337">TLS Sessão renegociação</span><span class="sxs-lookup"><span data-stu-id="75655-337">TLS Session Renegotiation</span></span>

<span data-ttu-id="75655-338">O TLS apoia a noção de "renegociação" que é simplesmente uma renegociação dos parâmetros da sessão TLS no contexto de uma sessão TLS existente.</span><span class="sxs-lookup"><span data-stu-id="75655-338">TLS supports the notion of "renegotiation" which is simply a renegotiation of the TLS session parameters within the context of an existing TLS session.</span></span> <span data-ttu-id="75655-339">Na prática, isto significa que as novas mensagens de aperto de mão são encriptadas e autenticadas utilizando a sessão existente.</span><span class="sxs-lookup"><span data-stu-id="75655-339">What this means in practice is that the new handshake messages are encrypted and authenticated using the existing session.</span></span> <span data-ttu-id="75655-340">A renegociação é utilizada quando um anfitrião TLS quer gerar novos parâmetros de sessão (por exemplo, gerar novas teclas de sessão TLS) sem ter de completar a sessão existente.</span><span class="sxs-lookup"><span data-stu-id="75655-340">Renegotiation is used when a TLS host wants to generate new session parameters (e.g. generate new TLS session keys) without having to complete the existing session.</span></span> <span data-ttu-id="75655-341">Por exemplo, a renegociação pode ser desejável quando as políticas de segurança para uma aplicação ditam que as chaves de sessão são usadas apenas por um tempo limitado, mas uma sessão TLS permanece ativa para além desse tempo.</span><span class="sxs-lookup"><span data-stu-id="75655-341">For example, renegotiation may be desirable when security policies for an application dictate that session keys are only used for a limited time but a TLS session remains active beyond that time.</span></span>

<span data-ttu-id="75655-342">Um problema com a renegociação da sessão é que torna o TLS vulnerável a um ataque específico do Man-in-the-Middle onde um intruso pode convencer um servidor a iniciar uma renegociação com novos parâmetros, permitindo assim ao intruso sequestrar a sessão de TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-342">One issue with session renegotiation is that is makes TLS vulnerable to a specific Man-in-the-Middle attack where an attacker can convince a server to initiate a renegotiation with new parameters, thus allowing the attacker to hijack the TLS session.</span></span> <span data-ttu-id="75655-343">Para atenuar este problema, foi introduzida a extensão de Indicação de Renegociação Segura (ver erro de **secção! Fonte de referência não encontrada.**</span><span class="sxs-lookup"><span data-stu-id="75655-343">To mitigate this issue, the Secure Renegotiation Indication extension was introduced (see section **Error! Reference source not found.**</span></span> <span data-ttu-id="75655-344">secção).</span><span class="sxs-lookup"><span data-stu-id="75655-344">section).</span></span>

<span data-ttu-id="75655-345">NetX Secure TLS suporta completamente a renegociação da sessão e a extensão de indicação de renegociação segura.</span><span class="sxs-lookup"><span data-stu-id="75655-345">NetX Secure TLS completely supports session renegotiation and the Secure Renegotiation Indication extension.</span></span>

<span data-ttu-id="75655-346">Ao receber dados de um hospedeiro remoto, as renegotações (e a extensão) são tratadas automaticamente sem interação da aplicação.</span><span class="sxs-lookup"><span data-stu-id="75655-346">When receiving data from a remote host, renegotations (and the extension) are handled automatically without application interaction.</span></span> <span data-ttu-id="75655-347">Se for desejada notificação sobre renegociações de sessão, poderá ser fornecida uma chamada de renegociação com o serviço *nx_secure_tls_session_renegotiate_callback_set.*</span><span class="sxs-lookup"><span data-stu-id="75655-347">If notification about session renegotiations is desired, a renegotiation callback may be supplied with the *nx_secure_tls_session_renegotiate_callback_set* service.</span></span> <span data-ttu-id="75655-348">O retorno será invocado sempre que uma renegociação for solicitada pelo anfitrião remoto, permitindo que o pedido tome medidas se desejar.</span><span class="sxs-lookup"><span data-stu-id="75655-348">The callback will be invoked whenever a renegotiation is requested by the remote host, allowing the application to take action if desired.</span></span>

<span data-ttu-id="75655-349">Para iniciar uma renegociação a partir de uma sessão de TLS ativa, basta invocar o serviço *de nx_secure_tls_session_renegotiate* na sessão TLS desejada.</span><span class="sxs-lookup"><span data-stu-id="75655-349">To initiate a renegotiation from an active TLS session, simply invoke the *nx_secure_tls_session_renegotiate* service on the desired TLS session.</span></span>

### <a name="tls-session-resumption"></a><span data-ttu-id="75655-350">Retoma da Sessão TLS</span><span class="sxs-lookup"><span data-stu-id="75655-350">TLS Session Resumption</span></span>

<span data-ttu-id="75655-351">O reinício da sessão TLS não deve ser confundido com a renegociação da sessão, apesar de algumas semelhanças.</span><span class="sxs-lookup"><span data-stu-id="75655-351">TLS session resumption should not be confused with session renegotiation, despite some similarities.</span></span> <span data-ttu-id="75655-352">Onde a *renegociação* da sessão envolve iniciar um novo aperto de mão dentro de uma sessão TLS existente, *o recomeço da* sessão é uma característica puramente opcional que envolve reiniciar uma sessão de TLS fechada sem realizar um aperto de mão TLS completo.</span><span class="sxs-lookup"><span data-stu-id="75655-352">Where session *renegotiation* involves starting a new handshake within an existing TLS session, session *resumption* is a purely optional feature that involves restarting a closed TLS session without performing a complete TLS handshake.</span></span> <span data-ttu-id="75655-353">Para tal, uma implementação TLS pode cache os parâmetros e teclas da sessão, associando-os a um *ID de sessão,* um identificador único fornecido no aperto de mão original.</span><span class="sxs-lookup"><span data-stu-id="75655-353">To achieve this, a TLS implementation may cache the session parameters and keys, associating them with a *session ID,* a unique identifier supplied in the original handshake.</span></span> <span data-ttu-id="75655-354">Ao fornecer um ID de sessão a um servidor TLS, um cliente indica que uma sessão anterior de TLS entre os anfitriões existiu e completou algum tempo no passado, e que o cliente ainda possui o estado para restabelecer a sessão com um aperto de mão reduzido.</span><span class="sxs-lookup"><span data-stu-id="75655-354">By supplying a session ID to a TLS server, a client indicates that a previous TLS session between the hosts existed and completed some time in the past, and that the client still possesses the state to re-establish the session with a reduced handshake.</span></span> <span data-ttu-id="75655-355">Uma vez que as teclas de sessão são teoricamente ainda secretas e só são conhecidas pelos dois anfitriões comunicantes, o servidor pode iniciar uma nova sessão de TLS e contornar a maioria do aperto de mão normal.</span><span class="sxs-lookup"><span data-stu-id="75655-355">Since the session keys are theoretically still secret and only known by the two communicating host, the server can start a new TLS session and bypass most of the normal handshake.</span></span>

<span data-ttu-id="75655-356">O reinício da sessão pode ser útil para evitar as operações potencialmente dispendiosas de chaves públicas usadas para partilhar o segredo principal de geração chave e verificar assinaturas de certificados, mas também requer que os parâmetros da sessão, chaves e estado cripotgráfico sejam mantidos na memória para todas as sessões possíveis (pelo menos para uma janela de tempo configurável).</span><span class="sxs-lookup"><span data-stu-id="75655-356">Session resumption can be useful to avoid the potentially expensive public-key operations used to share the key generation master secret and verify certificate signatures, but it also requires that the session parameters, keys, and crypotgraphic state be maintained in memory for all possible sessions (at least for a configurable time window).</span></span>

<span data-ttu-id="75655-357">A versão atual do NetX Secure TLS não suporta o reinício da sessão – o ID da sessão é simplesmente ignorado pelos servidores TLS e os clientes TLS fornecem sempre um ID de sessão NU, o que leva o servidor a realizar um aperto de mão completo.</span><span class="sxs-lookup"><span data-stu-id="75655-357">The current version of NetX Secure TLS does not support session resumption – the session ID is simply ignored by TLS servers and TLS clients always supply a NULL session ID which prompts the server to perform a complete handshake.</span></span> <span data-ttu-id="75655-358">A falta de retoma da sessão não deverá causar problemas de interoperabilidade, uma vez que é uma característica completamente opcional e todas as implementações de TLS devem estar por defeito num aperto de mão completo se o ID da sessão for NULO ou não reconhecido.</span><span class="sxs-lookup"><span data-stu-id="75655-358">The lack of session resumption should cause no inter-operability issues as it is a completely optional feature and all TLS implementations must default to a complete handshake should the session ID be NULL or unrecognized.</span></span>

### <a name="protocol-layering"></a><span data-ttu-id="75655-359">Camada de protocolo</span><span class="sxs-lookup"><span data-stu-id="75655-359">Protocol Layering</span></span>

<span data-ttu-id="75655-360">O protocolo TLS enquadra-se na pilha de rede entre a camada de transporte (por exemplo, TCP) e a camada de aplicação.</span><span class="sxs-lookup"><span data-stu-id="75655-360">The TLS protocol fits into the networking stack between the transport layer (e.g. TCP) and the application layer.</span></span> <span data-ttu-id="75655-361">O TLS é por vezes considerado um protocolo de camada de transporte (daí a Segurança *da Camada de Transporte),* mas porque atua como uma aplicação no que diz respeito aos protocolos de rede subjacentes (como o TCP) é por vezes agrupado na camada de aplicação.</span><span class="sxs-lookup"><span data-stu-id="75655-361">TLS is sometimes considered a transport-layer protocol (hence *Transport Layer* Security) but because it acts as an application with regard to the underlying network protocols (such as TCP) it is sometimes grouped into the application layer.</span></span>

<span data-ttu-id="75655-362">O TLS requer um protocolo de camada de transporte que suporte a entrega em ordem e sem perdas, como o TCP.</span><span class="sxs-lookup"><span data-stu-id="75655-362">TLS requires a transport layer protocol that supports in-order and lossless delivery, such as TCP.</span></span> <span data-ttu-id="75655-363">Devido a este requisito, o TLS não pode funcionar em cima da UDP, uma vez que a UDP não garante a entrega de datagramas.</span><span class="sxs-lookup"><span data-stu-id="75655-363">Due to this requirement, TLS cannot run on top of UDP since UDP does not guarantee delivery of datagrams.</span></span> <span data-ttu-id="75655-364">Um protocolo separado chamado *DTLS,* que é uma versão modificada do TLS, é usado para aplicações que precisam da segurança de TLS sobre um protocolo de datagrama como uDP.</span><span class="sxs-lookup"><span data-stu-id="75655-364">A separate protocol called *DTLS,* which is a modified version of TLS, is used for applications that need the security of TLS over a datagram protocol like UDP.</span></span> <span data-ttu-id="75655-365">NetX Secure suporta DTLS, mas a documentação para DTLS é separada deste documento.</span><span class="sxs-lookup"><span data-stu-id="75655-365">NetX Secure supports DTLS, but documentation for DTLS is separate from this document.</span></span>

![Diagrama de camadas de protocolo TCP/IP e TLS.](media/image6.png)

<span data-ttu-id="75655-367">Figura 5- TCP/IP e camadas de protocolo TLS</span><span class="sxs-lookup"><span data-stu-id="75655-367">Figure 5- TCP/IP and TLS protocol layers</span></span>

## <a name="network-communications-security"></a><span data-ttu-id="75655-368">Segurança de Comunicações de Rede</span><span class="sxs-lookup"><span data-stu-id="75655-368">Network Communications Security</span></span>

<span data-ttu-id="75655-369">A segurança das comunicações através das redes públicas e da Internet é um tema de extrema importância e tema de um vasto número de livros, artigos e soluções.</span><span class="sxs-lookup"><span data-stu-id="75655-369">Securing communications over public networks and the Internet is a critically important topic and the subject of vast numbers of books, articles, and solutions.</span></span> <span data-ttu-id="75655-370">O tema é incrivelmente complexo, mas pode ser reduzido a uma ideia simples: enviar informação por uma rede para que apenas o alvo pretendido possa aceder ou alterar essa informação.</span><span class="sxs-lookup"><span data-stu-id="75655-370">The topic is mind-bogglingly complex, but can be reduced to a simple idea: sending information over a network so that only the intended target can access or change that information.</span></span> <span data-ttu-id="75655-371">Isto divide-se em três conceitos importantes: sigilo, integridade e autenticação.</span><span class="sxs-lookup"><span data-stu-id="75655-371">This breaks down into three important concepts: secrecy, integrity, and authentication.</span></span> <span data-ttu-id="75655-372">O protocolo TLS fornece soluções para os três.</span><span class="sxs-lookup"><span data-stu-id="75655-372">The TLS protocol provides solutions for all three.</span></span>

### <a name="secrecy"></a><span data-ttu-id="75655-373">Sigilo</span><span class="sxs-lookup"><span data-stu-id="75655-373">Secrecy</span></span>

<span data-ttu-id="75655-374">Ao enviar dados através de uma rede, é muitas vezes importante que os dados não possam ser obtidos por uma entidade maliciosa.</span><span class="sxs-lookup"><span data-stu-id="75655-374">When sending data over a network, it is often important that the data cannot be obtained by a malicious entity.</span></span> <span data-ttu-id="75655-375">Se os dados forem enviados através de uma ligação TCP/IP, qualquer pessoa com acesso à rede poderá ler esses dados utilizando ferramentas de rede facilmente disponíveis.</span><span class="sxs-lookup"><span data-stu-id="75655-375">If data is sent over a TCP/IP connection, anyone with access to the network will be able to read that data using easily-available networking tools.</span></span> <span data-ttu-id="75655-376">Para evitar que esses dados sejam obtidos, deve ser codificado de modo a que não possa ser lido a não ser pelo alvo pretendido – isto é *sigilo.*</span><span class="sxs-lookup"><span data-stu-id="75655-376">To prevent that data from being obtained, it must be encoded such that it cannot be read except by the intended target – this is *secrecy.*</span></span> <span data-ttu-id="75655-377">No TLS, algoritmos de encriptação como RSA e AES fornecem sigilo.</span><span class="sxs-lookup"><span data-stu-id="75655-377">In TLS, encryption algorithms such as RSA and AES provide secrecy.</span></span>

### <a name="integrity"></a><span data-ttu-id="75655-378">Integridade</span><span class="sxs-lookup"><span data-stu-id="75655-378">Integrity</span></span>

<span data-ttu-id="75655-379">Por vezes, o sigilo não é suficiente para proteger os dados que viajam sobre uma rede.</span><span class="sxs-lookup"><span data-stu-id="75655-379">Sometimes, secrecy is not enough to protect data travelling over a network.</span></span> <span data-ttu-id="75655-380">Em alguns casos, pode ser possível para uma entidade maliciosa alterar o conteúdo de um pacote TCP sem precisar de saber o que esse pacote contém.</span><span class="sxs-lookup"><span data-stu-id="75655-380">In some cases, it may be possible for a malicious entity to alter the contents of a TCP packet without needing to know what that packet contains.</span></span> <span data-ttu-id="75655-381">Os dados encriptados podem ser alterados, tornando a desencriptação inválida ou alterando os parâmetros da mensagem que conduza a qualquer resultado que o intruso possa estar interessado em alcançar.</span><span class="sxs-lookup"><span data-stu-id="75655-381">Encrypted data can be altered, rendering the decryption invalid or changing the parameters of the message leading to whatever result the attacker may be interested in achieving.</span></span> <span data-ttu-id="75655-382">Na rede, não podemos impedir que um intruso altere os dados em trânsito, mas podemos fornecer um mecanismo para saber se os dados foram alterados ou não.</span><span class="sxs-lookup"><span data-stu-id="75655-382">On the network, we cannot prevent an attacker from changing data in transit, but we can provide a mechanism to know whether or not the data has been changed.</span></span> <span data-ttu-id="75655-383">Quando os dados são alterados em trânsito, serão conhecidos e os dados podem ser rejeitados.</span><span class="sxs-lookup"><span data-stu-id="75655-383">When data is changed in transit, it will be known and the data can be rejected.</span></span> <span data-ttu-id="75655-384">Este conceito é *integridade.*</span><span class="sxs-lookup"><span data-stu-id="75655-384">This concept is *integrity*.</span></span> <span data-ttu-id="75655-385">Em TLS, a integridade é fornecida por uma classe de rotinas criptográficas conhecidas como *funções de haxixe*.</span><span class="sxs-lookup"><span data-stu-id="75655-385">In TLS, integrity is provided by a class of cryptographic routines known as *hash functions*.</span></span> <span data-ttu-id="75655-386">Alguns exemplos de funções de haxixe são MD5 e SHA-1.</span><span class="sxs-lookup"><span data-stu-id="75655-386">Some examples of hash functions are MD5 and SHA-1.</span></span>

### <a name="authentication"></a><span data-ttu-id="75655-387">Autenticação</span><span class="sxs-lookup"><span data-stu-id="75655-387">Authentication</span></span>

<span data-ttu-id="75655-388">O terceiro conceito importante na segurança das comunicações em rede é a ideia de que os dados só devem ser comunicados ao objetivo pretendido.</span><span class="sxs-lookup"><span data-stu-id="75655-388">The third important concept in network communications security is the idea that data should only be communicated to the intended target.</span></span> <span data-ttu-id="75655-389">Um intruso pode tentar fazer-se passar por uma entidade legítima para receber dados destinados a outro hospedeiro.</span><span class="sxs-lookup"><span data-stu-id="75655-389">An attacker may attempt to pose as a legitimate entity to receive data intended for another host.</span></span> <span data-ttu-id="75655-390">Mesmo que os dados estejam a ser enviados com mecanismos de sigilo e integridade em vigor, o intruso pode ainda ser capaz de alcançar o resultado desejado (um compromisso de comunicações seguras) através deste engano.</span><span class="sxs-lookup"><span data-stu-id="75655-390">Even if the data is being sent with secrecy and integrity mechanisms in place, the attacker may still be able to achieve the desired result (a compromise of secure communications) through this deception.</span></span> <span data-ttu-id="75655-391">Para evitar isto, é necessário um mecanismo para provar a identidade de um hospedeiro remoto antes de qualquer dado sensível ser enviado.</span><span class="sxs-lookup"><span data-stu-id="75655-391">To prevent this, a mechanism is needed to prove the identity of a remote host before any sensitive data is sent.</span></span> <span data-ttu-id="75655-392">O processo de provar a identidade de um hospedeiro remoto é *a autenticação.*</span><span class="sxs-lookup"><span data-stu-id="75655-392">The process of proving the identity of a remote host is *authentication.*</span></span> <span data-ttu-id="75655-393">No TLS, a autenticação é fornecida usando certificados digitais, funções de haxixe e um mecanismo chamado *assinaturas digitais* que utiliza uma propriedade de encriptação de chaves públicas (descrito abaixo).</span><span class="sxs-lookup"><span data-stu-id="75655-393">In TLS, authentication is provided using digital certificates, hash functions, and a mechanism called *digital signatures* which utilizes a property of public-key encryption (described below).</span></span> <span data-ttu-id="75655-394">Uma forma limitada mas útil de autenticação também pode ser fornecida com uma *chave pré-partilhada* (PSK).</span><span class="sxs-lookup"><span data-stu-id="75655-394">A limited but useful form of authentication can also be provided with a *pre-shared key* (PSK).</span></span>

## <a name="tls-encryption"></a><span data-ttu-id="75655-395">Encriptação TLS</span><span class="sxs-lookup"><span data-stu-id="75655-395">TLS Encryption</span></span>

<span data-ttu-id="75655-396">O protocolo TLS é um quadro para fornecer comunicações seguras de rede através da Internet utilizando encriptação.</span><span class="sxs-lookup"><span data-stu-id="75655-396">The TLS protocol is a framework for providing secure network communications over the Internet utilizing encryption.</span></span> <span data-ttu-id="75655-397">A encriptação é geralmente definida como o processo de codificação de dados de forma a que a obtenção dos dados originais (ou informação sobre esses dados) seja extremamente difícil sem uma *chave*.</span><span class="sxs-lookup"><span data-stu-id="75655-397">Encryption is generally defined as the process of encoding data in such a way that obtaining the original data (or information about that data) is exceedingly difficult without a *key*.</span></span> <span data-ttu-id="75655-398">Nos sistemas informáticos, a encriptação baseia-se em matemáticas complexas, como campos finitos, e pode ser classificada em dois tipos: *chave privada* (ou *encriptação simétrica)* e *chave pública* (ou *encriptação assimétrica).*</span><span class="sxs-lookup"><span data-stu-id="75655-398">In computer systems encryption is based on complex mathematics such as finite fields and can be classified into two types: *private key* (or *symmetric encryption*) and *public key* (or *asymmetric encryption*).</span></span> <span data-ttu-id="75655-399">Exemplos de encriptação de chaves privadas são AES (Advanced Encryption Standard) e RC4 (Rivest Cipher 4).</span><span class="sxs-lookup"><span data-stu-id="75655-399">Examples of private key encryption are AES (Advanced Encryption Standard) and RC4 (Rivest Cipher 4).</span></span> <span data-ttu-id="75655-400">Exemplos de encriptação de chaves públicas são o RSA (Rivest, Shamir, Adleson) e Diffie-Hellman cifras.</span><span class="sxs-lookup"><span data-stu-id="75655-400">Examples of public-key encryption are the RSA (Rivest, Shamir, Adleson) and Diffie-Hellman ciphers.</span></span>

<span data-ttu-id="75655-401">O protocolo TLS utiliza as rotinas de encriptação chave privada e pública para proporcionar um equilíbrio de desempenho, segurança e flexibilidade.</span><span class="sxs-lookup"><span data-stu-id="75655-401">The TLS protocol makes use of both private key and public key encryption routines to provide a balance of performance, security, and flexibility.</span></span>

### <a name="private-key-encryption"></a><span data-ttu-id="75655-402">Encriptação Private-Key</span><span class="sxs-lookup"><span data-stu-id="75655-402">Private-Key Encryption</span></span>

<span data-ttu-id="75655-403">A encriptação de chaves privadas está em uso há milhares de anos.</span><span class="sxs-lookup"><span data-stu-id="75655-403">Private-key encryption has been in use for thousands of years.</span></span> <span data-ttu-id="75655-404">As cifras básicas de substituição (em que uma letra ou palavra é substituída por outra letra ou palavra não relacionada) são os primeiros exemplos conhecidos de encriptação, mas com o advento da idade da informação a encriptação privada da chave melhorou significativamente.</span><span class="sxs-lookup"><span data-stu-id="75655-404">Basic substitution ciphers (where a letter or word is replaced by another unrelated letter or word) are the earliest known examples of encryption, but with the advent of the information age private key encryption has significantly improved.</span></span>

<span data-ttu-id="75655-405">Uma cifra de chave privada usa uma "chave" que é simplesmente um valor (que pode ser uma palavra, frase ou número no caso geral) que é usada para de alguma forma codificar alguns dados para que apenas uma entidade que tivesse acesso a essa chave pudesse descodificar os dados de uma forma significativa.</span><span class="sxs-lookup"><span data-stu-id="75655-405">A private key cipher uses a "key" which is simply a value (which could be a word, phrase, or number in the general case) that is used to somehow encode some data so that only an entity that had access to that key could decode the data in a meaningful way.</span></span> <span data-ttu-id="75655-406">A chave é utilizada tanto para encriptação como desencriptação dos dados, daí a *encriptação simétrica* de outro nome.</span><span class="sxs-lookup"><span data-stu-id="75655-406">The key is used for both encryption and decryption of the data, hence the other name *symmetric encryption*.</span></span>

<span data-ttu-id="75655-407">As cifras-chave privadas são geralmente rápidas e bastante simples de implementar, mesmo que a matemática envolvida sejam extremamente complexas.</span><span class="sxs-lookup"><span data-stu-id="75655-407">Private key ciphers are generally fast and fairly simple to implement, even if the mathematics involved are exceedingly complex.</span></span> <span data-ttu-id="75655-408">Por esta razão, o TLS utiliza cifras de chaves privadas para a maior parte das comunicações seguras.</span><span class="sxs-lookup"><span data-stu-id="75655-408">For this reason, TLS uses private key ciphers for the bulk of secure communications.</span></span>

<span data-ttu-id="75655-409">No entanto, a encriptação de chaves privadas tem um problema quando tentamos aplicá-la às comunicações gerais da rede informática: a chave deve ser partilhada entre ambas as máquinas que tentam comunicar.</span><span class="sxs-lookup"><span data-stu-id="75655-409">However, private key encryption has a problem when we try to apply it to general computer network communications: the key must be shared between both machines trying to communicate.</span></span> <span data-ttu-id="75655-410">No caso geral, é impraticável e muitas vezes impossível comunicar uma chave privada de forma segura entre duas máquinas na Internet, uma vez que se pode presumir que o tráfego de rede pode ser obtido por qualquer número de entidades nos vários saltos que os dados demoram quando são encaminhados através da Internet.</span><span class="sxs-lookup"><span data-stu-id="75655-410">In the general case, it is impractical and often impossible to communicate a private key securely between two machines on the Internet, as it can be assumed that the network traffic can be obtained by any number of entities in the various hops that data takes when being routed through the Internet.</span></span> <span data-ttu-id="75655-411">Se a chave for obtida por uma entidade maliciosa, todos os dados encriptados utilizando essa chave estão comprometidos.</span><span class="sxs-lookup"><span data-stu-id="75655-411">If the key is obtained by a malicious entity, all data encrypted using that key is compromised.</span></span> <span data-ttu-id="75655-412">Como a maioria das máquinas na Internet tem apenas uma ligação de rede e não outro canal seguro para comunicações, o envio de chaves através da rede equivale a enviar os dados desencriptados – não fornece segurança.</span><span class="sxs-lookup"><span data-stu-id="75655-412">As most machines on the Internet have only a network connection and not another secure channel for communications, sending keys over the network is tantamount to sending the data unencrypted – it provides no security.</span></span>

<span data-ttu-id="75655-413">Por esta razão, a encriptação de chaves privadas não é suficiente para implementar um protocolo de segurança de comunicações de rede para fins gerais.</span><span class="sxs-lookup"><span data-stu-id="75655-413">For this reason, private key encryption is not sufficient to implement a general-purpose network communications security protocol.</span></span> <span data-ttu-id="75655-414">É aqui que a encriptação da Chave Pública pode ajudar.</span><span class="sxs-lookup"><span data-stu-id="75655-414">This is where Public Key encryption can help.</span></span>

<span data-ttu-id="75655-415">NetX Secure TLS suporta encriptação de chave privada AES.</span><span class="sxs-lookup"><span data-stu-id="75655-415">NetX Secure TLS supports AES private-key encryption.</span></span>

### <a name="public-key-encryption"></a><span data-ttu-id="75655-416">Encriptação Public-Key</span><span class="sxs-lookup"><span data-stu-id="75655-416">Public-Key Encryption</span></span>

<span data-ttu-id="75655-417">Ao contrário da encriptação de chaves privadas, a encriptação de chaves públicas é um conceito bastante novo, tendo sido desenvolvido na década de 1970.</span><span class="sxs-lookup"><span data-stu-id="75655-417">Unlike private key encryption, public key encryption is a fairly new concept, having been developed in the 1970's.</span></span> <span data-ttu-id="75655-418">Usando um conceito conhecido como "funções de alçapão" em matemática, descobriu-se que havia uma maneira de partilhar uma chave sobre uma rede sem comprometer a segurança de dados então encriptados.</span><span class="sxs-lookup"><span data-stu-id="75655-418">Using a concept known as "trap-door functions" in mathematics, it was discovered that there was a way to share a key over a network without compromising the security of then encrypted data.</span></span>

<span data-ttu-id="75655-419">A forma como a encriptação chave pública funciona é que a chave (no sentido de encriptação de chave privada acima descrito) é dividida em duas partes, uma *chave privada* e uma *chave pública*, de onde a encriptação chave pública obtém o seu nome.</span><span class="sxs-lookup"><span data-stu-id="75655-419">The way public key encryption works is that the key (in the private-key encryption sense described above) is split into two parts, a *private key* and a *public key*, from where public key encryption gets its name.</span></span> <span data-ttu-id="75655-420">O conceito é que uma destas teclas (tipicamente a chave pública) é usada para encriptação, enquanto a outra é usada para desencriptação.</span><span class="sxs-lookup"><span data-stu-id="75655-420">The concept is that one of these keys (typically the public key) is used for encryption, while the other is used for decryption.</span></span> <span data-ttu-id="75655-421">Esta assimetria das chaves é a razão para o outro nome para encriptação de chaves públicas: *encriptação assimétrica*.</span><span class="sxs-lookup"><span data-stu-id="75655-421">This asymmetry of keys is the reason for the other name for public key encryption: *asymmetric encryption*.</span></span>

<span data-ttu-id="75655-422">A matemática por trás da encriptação de chaves públicas é bastante complexa, mas a ideia é que a chave pública *só* pode ser usada para encriptação, e obter essa chave não permite a obtenção de dados encriptados.</span><span class="sxs-lookup"><span data-stu-id="75655-422">The mathematics behind public key encryption are fairly complex, but the idea is that the public key can *only* be used for encryption, and obtaining that key does not allow encrypted data to be obtained.</span></span> <span data-ttu-id="75655-423">A chave privada, por sua vez, é a única forma de desencriptar dados encriptados usando a chave pública.</span><span class="sxs-lookup"><span data-stu-id="75655-423">The private key, in turn, is the only way to decrypt data encrypted using the public key.</span></span> <span data-ttu-id="75655-424">Assim, mantendo o segredo chave privado, quem quiser comunicar de forma segura com o proprietário dessa chave privada só precisa de encriptar os seus dados com a chave pública correspondente, sabendo que apenas alguém na posse dessa chave privada pode obter os dados seguros.</span><span class="sxs-lookup"><span data-stu-id="75655-424">Thus, by keeping the private key secret, anyone wishing to communicate securely with the owner of that private key need only encrypt their data with the corresponding public key with the knowledge that only someone in possession of that private key can obtain the secure data.</span></span>

<span data-ttu-id="75655-425">NetX Secure TLS suporta encriptação de chave pública RSA.</span><span class="sxs-lookup"><span data-stu-id="75655-425">NetX Secure TLS supports RSA public-key encryption.</span></span>

> [!IMPORTANT] 
> <span data-ttu-id="75655-426">*A RSA é uma operação muito intensiva de processador se a implementação do software RSA for utilizada. Tamanhos de chave maiores aumentam a potência de processamento necessária por um fator quadrado – 4X mais lento para um aumento de 2X no tamanho da chave.*</span><span class="sxs-lookup"><span data-stu-id="75655-426">*RSA is a very processor-intensive operation if the software RSA implementation is used. Larger key sizes increase the processing power required by a square factor – 4X slower for a 2X increase in key size.*</span></span>

### <a name="public-key-authentication"></a><span data-ttu-id="75655-427">Autenticação Public-Key</span><span class="sxs-lookup"><span data-stu-id="75655-427">Public-Key Authentication</span></span>

<span data-ttu-id="75655-428">Um efeito colateral interessante do conceito de encriptação de chaves públicas é que ele pode ser usado para fornecer autenticação, bem como encriptação, fazendo a operação em sentido inverso: encriptar usando a chave *privada* e desencriptar usando a chave *pública.*</span><span class="sxs-lookup"><span data-stu-id="75655-428">An interesting side-effect of the public-key encryption concept is that it can be used to provide authentication as well as encryption by doing the operation in reverse: encrypting using the *private* key and decrypting using the *public* key.</span></span> <span data-ttu-id="75655-429">O mecanismo real para o fazer depende da utilização do algoritmo chave público, mas o conceito é o mesmo.</span><span class="sxs-lookup"><span data-stu-id="75655-429">The actual mechanism for doing this depends on the public key algorithm being used, but the concept is the same.</span></span>

<span data-ttu-id="75655-430">Para autenticar a autenticação de chave pública, o proprietário de uma chave privada encripta alguns dados (normalmente um haxixe criptográfico dos dados a autenticar) utilizando essa chave privada.</span><span class="sxs-lookup"><span data-stu-id="75655-430">To authenticate using public key authentication, the owner of a private key encrypts some piece of data (typically a cryptographic hash of the data to be authenticated) using that private key.</span></span> <span data-ttu-id="75655-431">Em seguida, alguém que pretenda autenticar que os dados vieram do proprietário da chave privada utiliza a chave pública associada para desencriptar os dados – se a desencriptação for bem sucedida, e assumindo que o utilizador confiou na validade dessa chave pública, então o utilizador pode ter a certeza de que os dados vieram do proprietário da chave privada.</span><span class="sxs-lookup"><span data-stu-id="75655-431">Then, someone wishing to authenticate that the data came from the owner of the private key uses the associated public key to decrypt the data – if the decryption is successful, and assuming the user trusted the validity of that public key, then the user can be certain that the data came from the owner of the private key.</span></span>

<span data-ttu-id="75655-432">No TLS, a autenticação de chaves públicas é utilizada para verificar a validade de um certificado digital fornecido por um servidor TLS (e opcionalmente o cliente TLS) utilizando chaves públicas da loja de certificados fidedigna.</span><span class="sxs-lookup"><span data-stu-id="75655-432">In TLS, public key authentication is used to verify the validity of a digital certificate provided by a TLS server (and optionally the TLS client) using public keys from the trusted certificate store.</span></span> <span data-ttu-id="75655-433">O certificado é verificado com uma chave pública na loja e os dados no certificado são utilizados para verificar a identidade do servidor.</span><span class="sxs-lookup"><span data-stu-id="75655-433">The certificate is checked against a public key in the store and the data in the certificate is used to check the identity of the server.</span></span>

<span data-ttu-id="75655-434">NetX Secure TLS suporta a autenticação RSA.</span><span class="sxs-lookup"><span data-stu-id="75655-434">NetX Secure TLS supports RSA authentication.</span></span>

### <a name="cryptographic-hashing"></a><span data-ttu-id="75655-435">Hashing criptográfico</span><span class="sxs-lookup"><span data-stu-id="75655-435">Cryptographic Hashing</span></span>

<span data-ttu-id="75655-436">A encriptação não é a única operação criptográfica usada no TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-436">Encryption is not the only cryptographic operation used in TLS.</span></span> <span data-ttu-id="75655-437">Para fornecer integridade da mensagem durante uma sessão de TLS, é necessário um checkum para garantir que o conteúdo da mensagem não foi adulterado.</span><span class="sxs-lookup"><span data-stu-id="75655-437">In order to provide message integrity during a TLS session, a checksum is needed to ensure that the message contents have not been tampered with.</span></span> <span data-ttu-id="75655-438">No entanto, uma simples parte de verificação (como é utilizada em TCP) é insuficiente para garantir um nível de integridade aceitável, uma vez que pode ser facilmente subvertida por um intruso experiente.</span><span class="sxs-lookup"><span data-stu-id="75655-438">However, a simple checksum (as is used in TCP) is insufficient to guarantee an acceptable level of integrity as it can be easily subverted by a knowledgeable attacker.</span></span> <span data-ttu-id="75655-439">O mecanismo utilizado pelo TLS para fornecer integridade da mensagem é conhecido como um *haxixe criptográfico*.</span><span class="sxs-lookup"><span data-stu-id="75655-439">The mechanism used by TLS to provide message integrity is known as a *cryptographic hash*.</span></span>

<span data-ttu-id="75655-440">A encriptação é uma codificação 1:1 – ou seja, a totalidade dos dados originais pode ser obtida a partir dos dados encriptados.</span><span class="sxs-lookup"><span data-stu-id="75655-440">Encryption is a 1:1 encoding – that is, the entirety of the original data can be obtained from the encrypted data.</span></span> <span data-ttu-id="75655-441">No entanto, um haxixe mapeia uma quantidade arbitrária de dados num valor de tamanho fixo, tal como uma função de verificação.</span><span class="sxs-lookup"><span data-stu-id="75655-441">However, a hash maps an arbitrary amount of data into a fixed size value, just like a checksum.</span></span> <span data-ttu-id="75655-442">Ao contrário de uma simples função de verificação, um haxixe é especificamente concebido para reduzir *colisões, onde diferentes dados* de entrada resultam na mesma saída.</span><span class="sxs-lookup"><span data-stu-id="75655-442">Unlike a simple checksum, a hash is specifically designed to reduce *collisions*, where different input data result in the same output.</span></span> <span data-ttu-id="75655-443">Numa simples parte de verificação, se um pouco é virado de 1 para 0 e outro de 0 para 1, a parte de verificação é a mesma.</span><span class="sxs-lookup"><span data-stu-id="75655-443">In a simple checksum, if a bit is flipped from 1 to 0 and another bit from 0 to 1, the checksum is the same.</span></span> <span data-ttu-id="75655-444">Com um haxixe criptográfico, a saída diferia significativamente, dificultando a alteração dos dados de haxixe por parte de um intruso e a operação de haxixe nos dados alterados, resultando assim no mesmo valor (e, portanto, verificando falsamente a integridade desses dados).</span><span class="sxs-lookup"><span data-stu-id="75655-444">With a cryptographic hash, the output would differ significantly, making it difficult for an attacker to change the hashed data and have the hash operation on the changed data still result in the same value (and thus falsely verifying the integrity of that data).</span></span>

<span data-ttu-id="75655-445">O TLS utiliza uma série de algoritmos de haxixe diferentes para fornecer integridade para mensagens, mensagens de aplicação e mensagens de controlo TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-445">TLS uses a number of different hash algorithms to provide integrity for messages, both application messages and TLS control messages.</span></span> <span data-ttu-id="75655-446">Estes incluem MD5, SHA-1 e SHA-256.</span><span class="sxs-lookup"><span data-stu-id="75655-446">These include MD5, SHA-1 and SHA-256.</span></span>

<span data-ttu-id="75655-447">NetX Secure TLS suporta hashing MD5, SHA-1 e SHA-256.</span><span class="sxs-lookup"><span data-stu-id="75655-447">NetX Secure TLS supports MD5, SHA-1, and SHA-256 hashing.</span></span>

## <a name="tls-extensions"></a><span data-ttu-id="75655-448">Extensões TLS</span><span class="sxs-lookup"><span data-stu-id="75655-448">TLS Extensions</span></span>

<span data-ttu-id="75655-449">O TLS fornece uma série de extensões que fornecem funcionalidades adicionais para determinadas aplicações.</span><span class="sxs-lookup"><span data-stu-id="75655-449">TLS provides a number of extensions that provide additional functionality for certain applications.</span></span> <span data-ttu-id="75655-450">Estas extensões são normalmente enviadas como parte das mensagens ClientHello ou ServerHello, indicando a um anfitrião remoto o desejo de usar uma extensão ou fornecer detalhes adicionais para uso no estabelecimento da sessão TLS segura.</span><span class="sxs-lookup"><span data-stu-id="75655-450">These extensions are typically sent as part of the ClientHello or ServerHello messages, indicating to a remote host the desire to use an extension or providing additional details for use in establishing the secure TLS session.</span></span>

<span data-ttu-id="75655-451">Em geral, as extensões fornecem parâmetros opcionais ao TLS no início do aperto de mão que orientam as operações em curso.</span><span class="sxs-lookup"><span data-stu-id="75655-451">In general, extensions provide optional parameters to TLS at the beginning of the handshake that guide the proceeding operations.</span></span> <span data-ttu-id="75655-452">Algumas extensões requerem entrada de aplicação ou tomada de decisão, enquanto outras são tratadas automaticamente.</span><span class="sxs-lookup"><span data-stu-id="75655-452">Some extensions require application input or decision making, while others are handled automatically.</span></span>

<span data-ttu-id="75655-453">O quadro seguinte descreve as extensões TLS atualmente suportadas pelo NetX Secure TLS:</span><span class="sxs-lookup"><span data-stu-id="75655-453">The following table describes the TLS extensions currently supported by NetX Secure TLS:</span></span>

| <span data-ttu-id="75655-454">**Nome de extensão**</span><span class="sxs-lookup"><span data-stu-id="75655-454">**Extension Name**</span></span>              | <span data-ttu-id="75655-455">**Descrição**</span><span class="sxs-lookup"><span data-stu-id="75655-455">**Description**</span></span>              |
| ------------------------------- |----------------------------- |
| <span data-ttu-id="75655-456">Indicação de renegociação segura</span><span class="sxs-lookup"><span data-stu-id="75655-456">Secure Renegotiation Indication</span></span> | <span data-ttu-id="75655-457">Esta extensão atenua uma vulnerabilidade de ataque Man-in-the-Middle que pode ocorrer durante um aperto de mão de renegociação.</span><span class="sxs-lookup"><span data-stu-id="75655-457">This extension mitigates a Man-in-the-Middle attack vulnerability that could occur during a renegotiation handshake.</span></span>|
| <span data-ttu-id="75655-458">Indicação de nome do servidor</span><span class="sxs-lookup"><span data-stu-id="75655-458">Server Name Indication</span></span>          | <span data-ttu-id="75655-459">Esta extensão permite que um Cliente TLS forneça um nome DNS específico a um Servidor TLS, permitindo ao servidor selecionar as credenciais corretas (assume que o servidor tem vários certificados de identidade e pontos de entrada na rede).</span><span class="sxs-lookup"><span data-stu-id="75655-459">This extension allows a TLS Client to supply a specific DNS name to a TLS Server, allowing the server to select the correct credentials (assumes the server has multiple identity certificates and network entrypoints).</span></span> |
| <span data-ttu-id="75655-460">Algoritmos de assinatura</span><span class="sxs-lookup"><span data-stu-id="75655-460">Signature Algorithms</span></span>            | <span data-ttu-id="75655-461">Esta extensão permite que um Cliente TLS forneça uma lista de algoritmos de assinatura e haxixe aceitáveis para um Servidor TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-461">This extension enables a TLS Client to provide a list of acceptable signature and hash algorithms to a TLS Server.</span></span> |

<span data-ttu-id="75655-462">Visão geral das extensões TLS suportadas</span><span class="sxs-lookup"><span data-stu-id="75655-462">Overview of supported TLS Extensions</span></span>

### <a name="secure-renegotiation-indication"></a><span data-ttu-id="75655-463">Indicação de renegociação segura</span><span class="sxs-lookup"><span data-stu-id="75655-463">Secure Renegotiation Indication</span></span>

<span data-ttu-id="75655-464">O TLS suporta a noção de realizar um aperto de mão dentro de uma sessão TLS existente, utilizando assim a sessão estabelecida para encriptar as mensagens de aperto de mão.</span><span class="sxs-lookup"><span data-stu-id="75655-464">TLS supports the notion of performing a handshake within an existing TLS session, thereby using the established session to encrypt the handshake messages.</span></span> <span data-ttu-id="75655-465">Este processo permite que as teclas de sessão criptográfica sejam restabelecidas sem terminar a sessão TLS (ver secção "TLS Session Renegociação").</span><span class="sxs-lookup"><span data-stu-id="75655-465">This process allows the cryptographic session keys to be re-established without ending the TLS session (see section "TLS Session Renegotiation").</span></span>

<span data-ttu-id="75655-466">Infelizmente, depois de o TLS ter usado a renegociação há algum tempo, descobriu-se que havia uma vulnerabilidade a um ataque man-in-the-middle que explorava o recurso de renegociação.</span><span class="sxs-lookup"><span data-stu-id="75655-466">Unfortunately, after TLS had been using renegotiation for some time, it was discovered that there was a vulnerability to a Man-in-the-Middle attack that exploited the renegotiation feature.</span></span> <span data-ttu-id="75655-467">Para colmatar a vulnerabilidade, foi introduzida a extensão da Indicação de Renegociação Segura.</span><span class="sxs-lookup"><span data-stu-id="75655-467">To close the vulnerability, the Secure Renegotiation Indication extension was introduced.</span></span> <span data-ttu-id="75655-468">Essencialmente, a extensão de Renegociação Segura utiliza o hash de mensagem acabado a partir da conexão estabelecida para verificar se os anfitriões originais estão a participar no aperto de mão de renegociação – essencialmente o haxixe é usado como um símbolo de verificação sob o pressuposto de que um intruso não seria capaz de forjar o haxixe (o que exigiria acesso às teclas de sessão).</span><span class="sxs-lookup"><span data-stu-id="75655-468">Essentially, the Secure Renegotiation extension uses the Finished message hash from the established connection to verify that the original hosts are participating in the renegotiation handshake – essentially the hash is used as a verification token under the assumption that an attacker would not be able to forge the hash (which would require access to the session keys).</span></span>

<span data-ttu-id="75655-469">O NetX Secure TLS lida com a renegociação automaticamente e utiliza a Extensão de Renegociação Segura por padrão.</span><span class="sxs-lookup"><span data-stu-id="75655-469">NetX Secure TLS handles renegotiation automatically and uses the Secure Renegotiation Extension by default.</span></span> <span data-ttu-id="75655-470">Não é necessária qualquer interação de aplicação.</span><span class="sxs-lookup"><span data-stu-id="75655-470">No application interaction is required.</span></span>

### <a name="server-name-indication"></a><span data-ttu-id="75655-471">Indicação de nome do servidor</span><span class="sxs-lookup"><span data-stu-id="75655-471">Server Name Indication</span></span>

<span data-ttu-id="75655-472">Durante o aperto de mão TLS, um Cliente TLS espera que um servidor remoto forneça um certificado de identidade para que o cliente possa autenticar o servidor.</span><span class="sxs-lookup"><span data-stu-id="75655-472">During the TLS handshake, a TLS Client expects a remote server to provide an identity certificate so the client can authenticate the server.</span></span> <span data-ttu-id="75655-473">No entanto, pode haver alguns casos em que um servidor irá fornecer vários serviços diferentes com diferentes servidores "virtuais" cada um com identidades únicas.</span><span class="sxs-lookup"><span data-stu-id="75655-473">However, there may be some cases where a server will provide multiple different services with different "virtual" servers each having unique identities.</span></span> <span data-ttu-id="75655-474">No caso de um único servidor com múltiplas identidades, um cliente TLS pode fornecer um nome DNS específico que o servidor utilizará para selecionar as credenciais adequadas – o mecanismo para fornecer este nome é a extensão de Indicação de Nome do Servidor (SNI).</span><span class="sxs-lookup"><span data-stu-id="75655-474">In the case of a single server with multiple identities, a TLS client can supply a specific DNS name that the server will use to select the proper credentials – the mechanism for supplying this name is the Server Name Indication (SNI) extension.</span></span>

<span data-ttu-id="75655-475">Para uma aplicação utilizando a extensão SNI, é necessária alguma interação.</span><span class="sxs-lookup"><span data-stu-id="75655-475">For an application using the SNI extension, some interaction is required.</span></span> <span data-ttu-id="75655-476">Para os Clientes TLS, a aplicação deve fornecer um nome DNS para ser enviado para o servidor remoto.</span><span class="sxs-lookup"><span data-stu-id="75655-476">For TLS Clients, the application must supply a DNS name to be sent to the remote server.</span></span> <span data-ttu-id="75655-477">Para os Servidores TLS, a aplicação deve ler o nome DNS a partir da extensão e selecionar um certificado apropriado para enviar de volta para o cliente.</span><span class="sxs-lookup"><span data-stu-id="75655-477">For TLS Servers, the application must read the DNS name from the extension and select an appropriate certificate to send back to the client.</span></span>

<span data-ttu-id="75655-478">As seguintes secções fornecem mais detalhes sobre como utilizar a extensão SNI em NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-478">The following sections provide more detail on how to use the SNI extension in NetX Secure TLS.</span></span>

### <a name="sni-extension--tls-client"></a><span data-ttu-id="75655-479">Extensão SNI – Cliente TLS</span><span class="sxs-lookup"><span data-stu-id="75655-479">SNI Extension – TLS Client</span></span>

<span data-ttu-id="75655-480">Um Cliente NetX Secure TLS que pretenda utilizar a extensão SNI deve fornecer um nome DNS ao TLS para ser fornecido durante o aperto de mão.</span><span class="sxs-lookup"><span data-stu-id="75655-480">A NetX Secure TLS Client wishing to use the SNI extension must provide a DNS name to TLS to be supplied during the handshake.</span></span> <span data-ttu-id="75655-481">Este nome deve ser inicializado e fornecido antes de iniciar uma sessão de TLS uma vez que a extensão é enviada na mensagem ClientHello que inicia o processo de aperto de mão.</span><span class="sxs-lookup"><span data-stu-id="75655-481">This name must be initialized and supplied prior to starting a TLS session since the extension is sent in the ClientHello message which starts the handshake process.</span></span>

<span data-ttu-id="75655-482">O seguinte corte de código ilustra a utilização da extensão.</span><span class="sxs-lookup"><span data-stu-id="75655-482">The following code snippet illustrates the use of the extension.</span></span> <span data-ttu-id="75655-483">Primeiro, um objeto NX_SECURE_X509_DNS_NAME é inicializado com o nome do servidor pretendido.</span><span class="sxs-lookup"><span data-stu-id="75655-483">First, a NX_SECURE_X509_DNS_NAME object is initialized with the desired server name.</span></span> <span data-ttu-id="75655-484">Em seguida, antes de iniciar a sessão TLS, o nome é fornecido ao TLS usando a API de extensão SNI.</span><span class="sxs-lookup"><span data-stu-id="75655-484">Then, prior to starting the TLS session, the name is provided to TLS using the SNI extension API.</span></span> <span data-ttu-id="75655-485">Uma vez definido o nome, não é necessária mais nenhuma ação.</span><span class="sxs-lookup"><span data-stu-id="75655-485">Once the name is set, no further action is required.</span></span> <span data-ttu-id="75655-486">Consulte a referência da API no Capítulo 4</span><span class="sxs-lookup"><span data-stu-id="75655-486">See the API reference in Chapter 4</span></span>  
  
<span data-ttu-id="75655-487">Descrição dos Serviços De Segurança NetX para mais informações sobre as funções individuais.</span><span class="sxs-lookup"><span data-stu-id="75655-487">Description of NetX Secure Services for more information on the individual functions.</span></span>

```C
/* The dns_name variable will contain our desired server name. */
UINT status;
NX_SECURE_X509_DNS_NAME dns_name;

/* Initialize the server DNS name. */
status = nx_secure_x509_dns_name_initialize(&dns_name, "www.example.com", 
                                            strlen("www.example.com"));


/* Initialize SNI extension in previously-initialized TLS Session. */
status = nx_secure_tls_session_sni_extension_set(&client_tls_session, &dns_name);

/* Now start the TLS session, starting with establishing the TCP connection – if 
   TLS is started before initializing the SNI extension, the extension will not be 
   sent in the ClientHello message! */
status = nx_tcp_client_socket_connect(&client_socket, IP_ADDRESS(1, 2, 3, 4), 443, 
                                      5 * NX_IP_PERIODIC_RATE);

status = nx_secure_tls_session_start(&client_tls_session, &client_socket, 
                                     NX_WAIT_FOREVER);
```
### <a name="sni-extension--tls-server"></a><span data-ttu-id="75655-488">Extensão SNI – Servidor TLS</span><span class="sxs-lookup"><span data-stu-id="75655-488">SNI Extension – TLS Server</span></span>

<span data-ttu-id="75655-489">Do lado do Servidor TLS, a extensão SNI pode ser processada pela aplicação de forma a selecionar credenciais adequadas (por exemplo, certificado) para fornecer ao cliente remoto durante o aperto de mão.</span><span class="sxs-lookup"><span data-stu-id="75655-489">On the TLS Server side, the SNI extension may be processed by the application in order to select proper credentials (e.g. certificate) to provide to the remote client during the handshake.</span></span> <span data-ttu-id="75655-490">Para isso, a aplicação deve fornecer uma chamada de sessão que é invocada após a receção de uma mensagem ClientHello.</span><span class="sxs-lookup"><span data-stu-id="75655-490">To do this, the application must supply a session callback which is invoked following the receipt of a ClientHello message.</span></span>

<span data-ttu-id="75655-491">O código de exemplo para a API nx_secure_tls_session_server_callback_set (ver página 122) ilustra a análise de uma extensão SNI recebida utilizando uma chamada de servidor.</span><span class="sxs-lookup"><span data-stu-id="75655-491">The example code for the nx_secure_tls_session_server_callback_set API  (see page 122) illustrates the parsing of an incoming SNI extension using a server callback.</span></span> <span data-ttu-id="75655-492">Essencialmente, o Servidor TLS recebe um ClientHello e invoca a chamada.</span><span class="sxs-lookup"><span data-stu-id="75655-492">Essentially, the TLS Server receives a ClientHello and invokes the callback.</span></span> <span data-ttu-id="75655-493">Em seguida, a aplicação utiliza o *nx_secure_tls_session_sni_extension_parse* API para analisar os dados de extensão fornecidos à chamada para encontrar a extensão SNI e devolver o nome DNS fornecido (note que a extensão suporta apenas um único nome DNS).</span><span class="sxs-lookup"><span data-stu-id="75655-493">Then the application uses the *nx_secure_tls_session_sni_extension_parse* API to parse the extension data provided to the callback to find the SNI extension and return the supplied DNS name (note that the extension only supports a single DNS name).</span></span> <span data-ttu-id="75655-494">Uma vez obtido o nome, a aplicação utiliza-o para encontrar e enviar o certificado de identidade do servidor apropriado (e cadeia de emitentes, se aplicável).</span><span class="sxs-lookup"><span data-stu-id="75655-494">Once the name is obtained, the application uses it to find and send the appropriate server identity certificate (and issuer chain if applicable).</span></span>

### <a name="signature-algorithms-extension"></a><span data-ttu-id="75655-495">Extensão de algoritmos de assinatura</span><span class="sxs-lookup"><span data-stu-id="75655-495">Signature Algorithms Extension</span></span>

<span data-ttu-id="75655-496">Esta extensão é específica do TLS 1.2 e permite que um Cliente TLS forneça uma lista de pares de algoritmos de assinatura e haxixe aceitáveis que sejam aceitáveis para uso na geração e verificação de assinaturas digitais.</span><span class="sxs-lookup"><span data-stu-id="75655-496">This extension is specific to TLS 1.2 and allows a TLS Client to provide a list of acceptable signature and hash algorithm pairs that are acceptable for use in generating and verifying digital signatures.</span></span> <span data-ttu-id="75655-497">A lista é gerada automaticamente pelo NetX Secure TLS para clientes TLS utilizando a tabela de cifra fornecida à *nx_secure_tls_session_create*.</span><span class="sxs-lookup"><span data-stu-id="75655-497">The list is generated automatically by NetX Secure TLS for TLS Clients using the cipher table supplied to *nx_secure_tls_session_create*.</span></span> <span data-ttu-id="75655-498">Não é necessária qualquer interação de aplicação.</span><span class="sxs-lookup"><span data-stu-id="75655-498">No application interaction is required.</span></span>

## <a name="authentication-methods"></a><span data-ttu-id="75655-499">Métodos de Autenticação</span><span class="sxs-lookup"><span data-stu-id="75655-499">Authentication Methods</span></span>

<span data-ttu-id="75655-500">O TLS fornece o enquadramento para estabelecer uma ligação segura entre dois dispositivos através de uma rede insegura, mas parte do problema é saber a identidade do dispositivo na outra extremidade dessa ligação.</span><span class="sxs-lookup"><span data-stu-id="75655-500">TLS provides the framework for establishing a secure connection between two devices over an insecure network, but part of the problem is knowing the identity of the device on the other end of that connection.</span></span> <span data-ttu-id="75655-501">Sem um mecanismo para autenticar a identidade dos anfitriões remotos, torna-se uma operação trivial para um intruso fazer-se passar por um dispositivo de confiança.</span><span class="sxs-lookup"><span data-stu-id="75655-501">Without a mechanism for authenticating the identity of remote hosts, it becomes a trivial operation for an attacker to pose as a trusted device.</span></span>

<span data-ttu-id="75655-502">Inicialmente, pode parecer que a utilização de endereços IP, endereços MAC de hardware ou DNS forneceria um nível de confiança relativamente elevado para identificar os anfitriões numa rede, mas dada a natureza da tecnologia TCP/IP e a facilidade com que os endereços podem ser falsificados e as entradas de DNS corrompidas (por exemplo, através do envenenamento por cache DNS), torna-se claro que o TLS precisa de uma camada adicional de proteção contra identidades fraudulentas.</span><span class="sxs-lookup"><span data-stu-id="75655-502">Initially, it may seem that using IP addresses, hardware MAC addresses, or DNS would provide a relatively high level of confidence for identifying hosts on a network, but given the nature of TCP/IP technology and the ease with which addresses can be spoofed and DNS entries corrupted (e.g. through DNS cache poisoning), it becomes clear that TLS needs an additional layer of protection against fraudulent identities.</span></span>

<span data-ttu-id="75655-503">Existem vários mecanismos que podem fornecer esta camada extra de autenticação para TLS, mas o mais comum é o *certificado digital.*</span><span class="sxs-lookup"><span data-stu-id="75655-503">There are various mechanisms that can provide this extra layer of authentication for TLS, but the most common is the *digital certificate.*</span></span> <span data-ttu-id="75655-504">Outros mecanismos incluem chaves pré-partilhadas (PSK) e esquemas de senha.</span><span class="sxs-lookup"><span data-stu-id="75655-504">Other mechanisms include Pre-Shared Keys (PSK) and password schemes.</span></span>

### <a name="digital-cerificates"></a><span data-ttu-id="75655-505">Cerifas digitais</span><span class="sxs-lookup"><span data-stu-id="75655-505">Digital Cerificates</span></span>

<span data-ttu-id="75655-506">Os certificados digitais são o método mais comum para autenticar um hospedeiro remoto em TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-506">Digital certificates are the most common method for authenticating a remote host in TLS.</span></span> <span data-ttu-id="75655-507">Essencialmente, um certificado digital é um documento com formatação específica que fornece informações de identidade para um dispositivo numa rede de computador.</span><span class="sxs-lookup"><span data-stu-id="75655-507">Essentially, a digital certificate is a document with specific formatting that provides identity information for a device on a computer network.</span></span>

<span data-ttu-id="75655-508">O TLS normalmente usa um formato chamado X.509, uma norma desenvolvida pela União Internacional de Telecomunicações, embora outros formatos de certificados possam ser usados se os anfitriões TLS puderem concordar com o formato que está a ser utilizado.</span><span class="sxs-lookup"><span data-stu-id="75655-508">TLS normally uses a format called X.509, a standard developed by the International Telecommunication Union, though other formats of certificates may be used if the TLS hosts can agree on the format being used.</span></span> <span data-ttu-id="75655-509">X.509 define um formato específico para certificados e várias codificações que podem ser usadas para produzir um documento digital.</span><span class="sxs-lookup"><span data-stu-id="75655-509">X.509 defines a specific format for certificates and various encodings that can be used to produce a digital document.</span></span> <span data-ttu-id="75655-510">A maioria dos certificados X.509 utilizados com TLS são codificados usando uma variante de ASN.1, outra norma de telecomunicações.</span><span class="sxs-lookup"><span data-stu-id="75655-510">Most X.509 certificates used with TLS are encoded using a variant of ASN.1, another telecommunications standard.</span></span> <span data-ttu-id="75655-511">Dentro da ASN.1 existem várias codificações digitais, mas a codificação mais comum para certificados TLS é a norma de codificação distinguida (DER).</span><span class="sxs-lookup"><span data-stu-id="75655-511">Within ASN.1 there are various digital encodings, but the most common encoding for TLS certificates is the Distinguished Encoding Rules (DER) standard.</span></span> <span data-ttu-id="75655-512">O DER é um subconjunto simplificado das Regras Básicas de Codificação (BER) as ASN.1 que são concebidas para ser inequívocas, facilitando a análise.</span><span class="sxs-lookup"><span data-stu-id="75655-512">DER is a simplified subset of the ASN.1 Basic Encoding Rules (BER) that is designed to be unambiguous, making parsing easier.</span></span> <span data-ttu-id="75655-513">Por cima do fio, os certificados TLS são geralmente codificados em DER binário, e este é o formato que o NetX Secure espera para os certificados X.509.</span><span class="sxs-lookup"><span data-stu-id="75655-513">Over the wire, TLS certificates are usually encoded in binary DER, and this is the format that NetX Secure expects for X.509 certificates.</span></span>

<span data-ttu-id="75655-514">Embora os certificados binários formatados pelo DER sejam utilizados no protocolo TLS real, podem ser gerados e armazenados em várias codificações diferentes, com extensões de ficheiros tais como .pem, .crt e .p12.</span><span class="sxs-lookup"><span data-stu-id="75655-514">Though DER-formatted binary certificates are used in the actual TLS protocol, they may be generated and stored in a number of different encodings, with file extensions such as .pem, .crt, and .p12.</span></span> <span data-ttu-id="75655-515">As diferentes variantes são usadas por diferentes aplicações de diferentes fabricantes, mas geralmente todas podem ser convertidas em DER usando ferramentas amplamente disponíveis.</span><span class="sxs-lookup"><span data-stu-id="75655-515">The different variants are used by different applications from different manufacturers, but generally all can be converted into DER using widely available tools.</span></span>

<span data-ttu-id="75655-516">A mais comum das codificações de certificados alternativos é o PEM.</span><span class="sxs-lookup"><span data-stu-id="75655-516">The most common of the alternative certificate encodings is PEM.</span></span> <span data-ttu-id="75655-517">O formato PEM (a partir do Privacy-Enhanced Mail) é uma versão codificada base-64 da codificação DER que é frequentemente utilizada porque a codificação resulta em texto imprimível que pode ser facilmente enviado usando protocolos de e-mail ou web.</span><span class="sxs-lookup"><span data-stu-id="75655-517">The PEM format (from Privacy-Enhanced Mail) is a base-64 encoded version of the DER encoding that is often used because the encoding results in printable text that can be easily sent using email or web-based protocols.</span></span>

<span data-ttu-id="75655-518">Gerar um certificado para a sua aplicação NetX Secure está geralmente fora do âmbito deste manual, mas a ferramenta de linha de comando OpenSSL[(www.openssl.org)](http://www.openssl.org)está amplamente disponível e pode converter entre a maioria dos formatos.</span><span class="sxs-lookup"><span data-stu-id="75655-518">Generating a certificate for your NetX Secure application is generally outside the scope of this manual, but the OpenSSL command-line tool ([www.openssl.org](http://www.openssl.org)) is widely available and can convert between most formats.</span></span>

<span data-ttu-id="75655-519">Dependendo da sua aplicação, poderá gerar os seus próprios certificados, ser fornecido certificados por um fabricante ou organização governamental, ou adquirir certificados a uma autoridade de certificados comerciais.</span><span class="sxs-lookup"><span data-stu-id="75655-519">Depending on your application, you may generate your own certificates, be provided certificates by a  manufacturer or government organization, or purchase certificates from a commercial certificate authority.</span></span>

<span data-ttu-id="75655-520">Para utilizar um certificado digital na sua aplicação NetX Secure, tem primeiro de converter o seu certificado num formato binário DER e, opcionalmente, converter a chave privada associada (o "expoente privado" para rSA, por exemplo) num formato binário, tipicamente uma chave RSA codificada por PKCS#1 ou uma chave ECC codificada por DER.</span><span class="sxs-lookup"><span data-stu-id="75655-520">To use a digital certificate in your NetX Secure application, you must first convert your certificate into a binary DER format and, optionally, convert the associated private key (the "private exponent" for RSA, for example) into a binary format, typically a PKCS#1-formatted, DER-encoded RSA key or a DER-encoded ECC key.</span></span> <span data-ttu-id="75655-521">Uma vez concluída a conversão, cabe-lhe a si carregar o certificado e a chave privada no dispositivo.</span><span class="sxs-lookup"><span data-stu-id="75655-521">Once the conversion is complete, it is up to you to load the certificate and private key onto the device.</span></span> <span data-ttu-id="75655-522">As opções possíveis incluem a utilização de um sistema de ficheiros baseado em flash ou a geração de um conjunto C a partir dos dados (utilizando uma ferramenta como "xxd" do Linux) e a compilação do certificado e chave na sua aplicação como dados constantes.</span><span class="sxs-lookup"><span data-stu-id="75655-522">Possible options include using a flash-based file system or generating a C array from the data (using a tool such as "xxd" from Linux) and compiling the certificate and key into your application as constant data.</span></span>

<span data-ttu-id="75655-523">Uma vez que o seu certificado é carregado no dispositivo, a API TLS pode ser usada para associar o seu certificado a uma sessão de TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-523">Once your certificate is loaded onto the device, the TLS API can be used to associate your certificate with a TLS session.</span></span>

<span data-ttu-id="75655-524">Para mais detalhes e exemplos sobre como utilizar certificados X.509 com NetX Secure TLS, consulte a secção "Importar certificados X.509 em NetX Secure".</span><span class="sxs-lookup"><span data-stu-id="75655-524">For details and examples on how to use X.509 certificates with NetX Secure TLS, see the section "Importing X.509 certificates into NetX Secure".</span></span>

<span data-ttu-id="75655-525">Consulte os seguintes serviços TLS na referência API para obter mais informações:</span><span class="sxs-lookup"><span data-stu-id="75655-525">Refer to the following TLS services in the API reference for more information:</span></span>

- <span data-ttu-id="75655-526">nx_secure_x509_certificate_initialize</span><span class="sxs-lookup"><span data-stu-id="75655-526">nx_secure_x509_certificate_initialize</span></span>
- <span data-ttu-id="75655-527">nx_secure_tls_local_certificate_add</span><span class="sxs-lookup"><span data-stu-id="75655-527">nx_secure_tls_local_certificate_add</span></span>
- <span data-ttu-id="75655-528">nx_secure_tls_local_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="75655-528">nx_secure_tls_local_certificate_remove</span></span>
- <span data-ttu-id="75655-529">nx_secure_tls_remote_certificate_allocate</span><span class="sxs-lookup"><span data-stu-id="75655-529">nx_secure_tls_remote_certificate_allocate</span></span>
- <span data-ttu-id="75655-530">nx_secure_tls_trusted_certificate_add</span><span class="sxs-lookup"><span data-stu-id="75655-530">nx_secure_tls_trusted_certificate_add</span></span>
- <span data-ttu-id="75655-531">nx_secure_trusted_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="75655-531">nx_secure_trusted_certificate_remove</span></span>

### <a name="tls-client-certificate-specifics"></a><span data-ttu-id="75655-532">Especificidades do Certificado de Cliente TLS</span><span class="sxs-lookup"><span data-stu-id="75655-532">TLS Client Certificate Specifics</span></span>

<span data-ttu-id="75655-533">As implementações do Cliente TLS geralmente não requerem que um certificado "local"<sup>14</sup> seja carregado no dispositivo.</span><span class="sxs-lookup"><span data-stu-id="75655-533">TLS Client implementations generally do not require a "local" certificate<sup>14</sup> to be loaded onto the device.</span></span> <span data-ttu-id="75655-534">A exceção a isso é quando a Autenticação do Certificado de Cliente está ativada, mas isso é muito menos comum.</span><span class="sxs-lookup"><span data-stu-id="75655-534">The exception to this is when Client Certificate Authentication is enabled, but this is far less common.</span></span>

<span data-ttu-id="75655-535">Um Cliente TLS requer que seja carregado pelo menos um certificado "fidedigno"<sup>15</sup> (mais pode ser carregado se necessário) e espaço para a atribuição de um certificado "remoto"<sup>16.</sup></span><span class="sxs-lookup"><span data-stu-id="75655-535">A TLS Client requires at least one "trusted" certificate<sup>15</sup> to be loaded (more may be loaded if required), and space for a "remote" certificate<sup>16</sup> to be allocated.</span></span>

<span data-ttu-id="75655-536">Para obter mais informações sobre a adição de certificados fidedignos e a atribuição de espaço para certificados remotos, consulte a referência TLS API para os seguintes serviços: nx_secure_tls_remote_certificate_allocate, nx_secure_tls_trusted_certificate_add.</span><span class="sxs-lookup"><span data-stu-id="75655-536">For more information on adding trusted certificates and allocating space for remote certificates, see the TLS API reference for the following services: nx_secure_tls_remote_certificate_allocate, nx_secure_tls_trusted_certificate_add.</span></span>

14. <span data-ttu-id="75655-537">Um certificado "local" é um certificado que identifica o dispositivo local – ou seja, fornece informações de identidade para o dispositivo sobre o qual a aplicação TLS é carregada.</span><span class="sxs-lookup"><span data-stu-id="75655-537">A “local” certificate is a certificate that identifies the local device – that is, it provides identity information for the device upon which the TLS application is loaded.</span></span>

15. <span data-ttu-id="75655-538">Um certificado "fidedigno" é um certificado que fornece uma base de confiança e autenticação do dispositivo remoto, quer diretamente quer através de uma Infraestrutura de Chave Pública (PKI).</span><span class="sxs-lookup"><span data-stu-id="75655-538">A “trusted” certificate is a certificate that provides a basis for trust and authentication of the remote device, either directly or through a Public Key Infrastructure (PKI).</span></span> <span data-ttu-id="75655-539">A raiz da cadeia de confiança é geralmente chamada de "Autoridade de Certificação" ou certificado de CA.</span><span class="sxs-lookup"><span data-stu-id="75655-539">The root of the chain of trust is usually called a “Certification Authority” or CA certificate.</span></span>

16. <span data-ttu-id="75655-540">Um certificado "remoto" refere-se ao certificado enviado pelo anfitrião remoto durante o aperto de mão TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-540">A “remote” certificate refers to the certificate sent by the remote host during the TLS handshake.</span></span> <span data-ttu-id="75655-541">Fornece identidade para o hospedeiro remoto e é autenticado comparando-o com um certificado "fidedigno" no dispositivo local.</span><span class="sxs-lookup"><span data-stu-id="75655-541">It provides identity for that remote host and is authenticated by comparing it to a “trusted” certificate on the local device.</span></span>

### <a name="tls-server-certificate-specifics"></a><span data-ttu-id="75655-542">Especificidades do certificado do servidor TLS</span><span class="sxs-lookup"><span data-stu-id="75655-542">TLS Server Certificate Specifics</span></span>

<span data-ttu-id="75655-543">As implementações do Servidor TLS geralmente não requerem certificados "fidedignos" para serem carregados no dispositivo ou certificados remotos a serem atribuídos.</span><span class="sxs-lookup"><span data-stu-id="75655-543">TLS Server implementations generally do not require "trusted" certificates to be loaded onto the device or remote certificates to be allocated.</span></span> <span data-ttu-id="75655-544">A exceção a este ser quando a autenticação do Certificado de Cliente está ativada (isto é menos comum).</span><span class="sxs-lookup"><span data-stu-id="75655-544">The exception to this being when Client Certificate Authentication is enabled (this is less common).</span></span>

<span data-ttu-id="75655-545">Um Servidor TLS requer que seja carregado um certificado "local" para que o servidor o possa fornecer ao cliente remoto durante o aperto de mão TLS para autenticar o servidor ao cliente.</span><span class="sxs-lookup"><span data-stu-id="75655-545">A TLS Server requires a "local" certificate to be loaded so the server can provide it to the remote client during the TLS handshake to authenticate the server to the client.</span></span>

<span data-ttu-id="75655-546">Para obter mais informações sobre o carregamento de certificados locais para utilização com aplicações de servidor NetX TLS, consulte a referência API para os seguintes serviços:</span><span class="sxs-lookup"><span data-stu-id="75655-546">For more information about loading local certificates for use with NetX TLS server applications, see the API reference for the following services:</span></span> 
- <span data-ttu-id="75655-547">nx_secure_tls_local_certificate_add,</span><span class="sxs-lookup"><span data-stu-id="75655-547">nx_secure_tls_local_certificate_add,</span></span> 
- <span data-ttu-id="75655-548">nx_secure_tls_local_certificate_remove.</span><span class="sxs-lookup"><span data-stu-id="75655-548">nx_secure_tls_local_certificate_remove.</span></span>

### <a name="pre-shared-keys-psk"></a><span data-ttu-id="75655-549">Chaves pré-partilhadas (PSK)</span><span class="sxs-lookup"><span data-stu-id="75655-549">Pre-Shared Keys (PSK)</span></span>

<span data-ttu-id="75655-550">Um mecanismo alternativo para fornecer autenticação de identificação em TLS é a noção de Chaves Pré-Partilhadas (PSK).</span><span class="sxs-lookup"><span data-stu-id="75655-550">An alternative mechanism for providing identification authentication in TLS is the notion of Pre-Shared Keys (PSK).</span></span> <span data-ttu-id="75655-551">A utilização de um cifrasuite PSK remove a necessidade de fazer as operações de encriptação intensivas de chaves públicas do processador, um bónus para dispositivos incorporados com recursos limitados.</span><span class="sxs-lookup"><span data-stu-id="75655-551">Using a PSK ciphersuite removes the need to do the processor-intensive public-key encryption operations, a boon for resource-constrained embedded devices.</span></span> <span data-ttu-id="75655-552">O PSK substitui o certificado no aperto de mão TLS e é usado no lugar da geração de chave de sessão pré-master encriptada para a geração de chaves de sessão TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-552">The PSK replaces the certificate in the TLS handshake and is used in place of the encrypted Pre-Master Secret for TLS session key generation.</span></span>

<span data-ttu-id="75655-553">As cifrasuites psk são limitadas no sentido de que um segredo partilhado deve estar presente em ambos os dispositivos antes de uma sessão de TLS ser estabelecida.</span><span class="sxs-lookup"><span data-stu-id="75655-553">The PSK ciphersuites are limited in the sense that that a shared secret must be present on both devices before a TLS session can be established.</span></span> <span data-ttu-id="75655-554">Isto significa que os dispositivos devem ter sido carregados com esse segredo usando alguns meios seguros que não uma ligação PSK TLS - os PSKs podem ser atualizados através de uma ligação PSK TLS, mas o dispositivo deve necessariamente começar com uma PSK que é carregada através de algum outro mecanismo.</span><span class="sxs-lookup"><span data-stu-id="75655-554">This means that the devices must have been loaded with that secret using some secure means other than a TLS PSK connection - PSKs may be updated over a TLS PSK connection, but the device must necessarily start with a PSK that is loaded through some other mechanism.</span></span> <span data-ttu-id="75655-555">Por exemplo, um dispositivo sensor e o seu dispositivo gateway poderiam ser carregados com PSKs na fábrica antes do envio, ou uma ligação TLS padrão (com um certificado) poderia ser usada para carregar o PSK.</span><span class="sxs-lookup"><span data-stu-id="75655-555">For example, a sensor device and its gateway device could be loaded with PSKs in the factory before shipping, or a standard TLS connection (with a certificate) could be used to load the PSK.</span></span>

<span data-ttu-id="75655-556">Os cifrasuites PSK vêm em algumas formas, descritas no RFC 4279.</span><span class="sxs-lookup"><span data-stu-id="75655-556">PSK ciphersuites come in a couple of forms, described in RFC 4279.</span></span> <span data-ttu-id="75655-557">A primeira utiliza teclas RSA ou Diffie-Hellman que são utilizadas da mesma forma que as chaves públicas transmitidas no certificado nos apertos de mão TLS padrão.</span><span class="sxs-lookup"><span data-stu-id="75655-557">The first uses RSA or Diffie-Hellman keys which are used in the same manner as the public keys transmitted in the certificate in standard TLS handshakes.</span></span> <span data-ttu-id="75655-558">O segundo formulário, que é mais utilizado num ambiente restrito a recursos, utiliza uma PSK que é usada para gerar diretamente as teclas de sessão (para utilização pela AES, por exemplo), evitando a utilização das operações de RSA ou Diffie-Hellman caras.</span><span class="sxs-lookup"><span data-stu-id="75655-558">The second form, which is of more use in a resource-constrained environment, uses a PSK that is used to directly generate the session keys (for use by AES, for example), avoiding the use of the expensive RSA or Diffie-Hellman operations.</span></span>

<span data-ttu-id="75655-559">O NetX Secure suporta a segunda forma de cifrasuites PSK, permitindo que as aplicações removam todo o código de criptografia e utilização da memória de chaves públicas.</span><span class="sxs-lookup"><span data-stu-id="75655-559">NetX Secure supports the second form of PSK ciphersuites, enabling applications to remove all public-key cryptography code and memory usage.</span></span> <span data-ttu-id="75655-560">O PSK em si não é uma chave AES, mas pode ser considerado como sendo mais uma palavra-passe a partir da qual as chaves reais são geradas.</span><span class="sxs-lookup"><span data-stu-id="75655-560">The PSK itself is not an AES key, but can be considered as being more like a password from which the actual keys are generated.</span></span> <span data-ttu-id="75655-561">Existem poucas restrições sobre o valor psk, embora valores mais longos forneçam mais segurança (o mesmo que com as palavras-passe).</span><span class="sxs-lookup"><span data-stu-id="75655-561">There are few restrictions on what the PSK value can be, though longer values will provide more security (same as with passwords).</span></span>

<span data-ttu-id="75655-562">Para utilizar o PSK com a sua aplicação NetX Secure, tem primeiro de definir a macro global **NX_SECURE_ENABLE_PSK_CIPHERSUITES**.</span><span class="sxs-lookup"><span data-stu-id="75655-562">To use PSK with your NetX Secure application, you must first define the global macro **NX_SECURE_ENABLE_PSK_CIPHERSUITES**.</span></span> <span data-ttu-id="75655-563">Isto é geralmente feito através das definições do seu compilador, mas a definição também pode ser colocada no ficheiro de cabeçalho nx_secure_tls.h.</span><span class="sxs-lookup"><span data-stu-id="75655-563">This is usually done through your compiler settings, but the definition can also be placed in the nx_secure_tls.h header file.</span></span> <span data-ttu-id="75655-564">Com o suporte de cifrasumita PSK definido, o suporte cifrasuite PSK será compilado na sua aplicação NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-564">With the macro defined, PSK ciphersuite support will be compiled into your NetX Secure TLS application.</span></span>

<span data-ttu-id="75655-565">Com o suporte psk ativado, pode então utilizar a API TLS para configurar PSKs para a sua aplicação.</span><span class="sxs-lookup"><span data-stu-id="75655-565">With PSK support enabled, you can then use the TLS API to set up PSKs for your application.</span></span> <span data-ttu-id="75655-566">Cada PSK exigirá um valor PSK (a "chave" secreta real – mantenha este valor seguro), um valor de "identidade" usado para identificar o PSK específico, e uma "dica de identidade" que é usada por um servidor TLS para escolher um determinado valor PSK.</span><span class="sxs-lookup"><span data-stu-id="75655-566">Each PSK will require a PSK value (the actual secret "key" – keep this value safe), an "identity" value used to identify the specific PSK, and an "identity hint" that is used by a TLS server to choose a particular PSK value.</span></span>

<span data-ttu-id="75655-567">O próprio PSK pode ser qualquer valor binário, uma vez que nunca é enviado por uma ligação de rede.</span><span class="sxs-lookup"><span data-stu-id="75655-567">The PSK itself can be any binary value as it is never sent over a network connection.</span></span> <span data-ttu-id="75655-568">O PSK pode ter qualquer valor até 64 bytes de comprimento.</span><span class="sxs-lookup"><span data-stu-id="75655-568">The PSK can be any value up to 64 bytes in length.</span></span>

<span data-ttu-id="75655-569">A identidade e a sugestão devem ser cordas de caracteres imprimíveis formatadas usando UTF-8.</span><span class="sxs-lookup"><span data-stu-id="75655-569">The identity and hint must be printable character strings formatted using UTF-8.</span></span> <span data-ttu-id="75655-570">Os valores de identidade e sugestão podem ter até 128 bytes.</span><span class="sxs-lookup"><span data-stu-id="75655-570">The identity and hint values may be any length up to 128 bytes.</span></span>

<span data-ttu-id="75655-571">A identidade e o PSK formam um par único que é carregado em todos os dispositivos da rede que precisam de comunicar uns com os outros.</span><span class="sxs-lookup"><span data-stu-id="75655-571">The identity and PSK form a unique pair that is loaded onto every device in the network that need to communicate with one another.</span></span>

<span data-ttu-id="75655-572">A "dica" é usada principalmente para definir perfis de aplicação específicos para grupo de PSKs por função ou serviço.</span><span class="sxs-lookup"><span data-stu-id="75655-572">The "hint" is primarily used for defining specific application profiles to group PSKs by function or service.</span></span> <span data-ttu-id="75655-573">Estes valores devem ser acordados antecipadamente e dependem da aplicação.</span><span class="sxs-lookup"><span data-stu-id="75655-573">These values must be agreed upon in advance and are application dependent.</span></span> <span data-ttu-id="75655-574">Como exemplo, a aplicação do servidor da linha de comando OpenSSL (com o PSK ativado) utiliza a cadeia padrão "Client_identity", que deve ser fornecida por um cliente TLS para continuar com o aperto de mão TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-574">As an example, the OpenSSL command-line server application (with PSK enabled) uses the default string "Client_identity", which must be provided by a TLS client in order to continue with the TLS handshake.</span></span>

<span data-ttu-id="75655-575">Para obter mais informações sobre psks, consulte a referência NetX Secure API para os seguintes serviços: nx_secure_tls_client_psk_set, nx_secure_tls_psk_add.</span><span class="sxs-lookup"><span data-stu-id="75655-575">For more information on PSKs, see the NetX Secure API reference for the following services: nx_secure_tls_client_psk_set, nx_secure_tls_psk_add.</span></span>

## <a name="importing-x509-certificates-into-netx-secure"></a><span data-ttu-id="75655-576">Importar certificados X.509 para o NetX Secure</span><span class="sxs-lookup"><span data-stu-id="75655-576">Importing X.509 certificates into NetX Secure</span></span>

<span data-ttu-id="75655-577">São necessários certificados digitais para a maioria das ligações TLS na Internet.</span><span class="sxs-lookup"><span data-stu-id="75655-577">Digital certificates are required for most TLS connections on the Internet.</span></span> <span data-ttu-id="75655-578">Os certificados fornecem um método para autenticar anfitriões anteriormente desconhecidos através da Internet através da utilização de intermediários de confiança, normalmente *chamados Autoridades de Certificados* ou CAs.</span><span class="sxs-lookup"><span data-stu-id="75655-578">Certificates provide a method for authenticating previously unknown hosts over the Internet through the use of trusted intermediaries, usually called *Certificate Authorities* or CAs.</span></span> <span data-ttu-id="75655-579">Para ligar o seu dispositivo NetX Secure a um serviço de nuvem comercial (como a Amazon Web Services), terá de importar certificados para a sua aplicação carregando-os no seu dispositivo.</span><span class="sxs-lookup"><span data-stu-id="75655-579">To connect your NetX Secure device with a commercial cloud service (such as Amazon Web Services), you will need to import certificates into your application by loading them onto your device.</span></span>

<span data-ttu-id="75655-580">Juntamente com os certificados, você também vai precisar de uma *chave privada* que está associada ao seu certificado.</span><span class="sxs-lookup"><span data-stu-id="75655-580">Along with certificates, you will also sometimes need a *private key* that is associated with your certificate.</span></span> <span data-ttu-id="75655-581">Em algumas aplicações (como o Cliente TLS quando a Autenticação do Certificado de Cliente não estiver a ser utilizada) o certificado por si só será suficiente, mas se o seu certificado estiver a ser utilizado para identificar o seu dispositivo, necessitará de uma chave privada.</span><span class="sxs-lookup"><span data-stu-id="75655-581">In some applications (such as TLS Client when Client Certificate Authentication is not being used) the certificate alone will be sufficient, but if your certificate is being used to identify your device you will need a private key.</span></span> <span data-ttu-id="75655-582">As chaves privadas são normalmente geradas quando cria o seu certificado e são armazenadas num ficheiro separado, muitas vezes encriptado com uma palavra-passe.</span><span class="sxs-lookup"><span data-stu-id="75655-582">Private keys are typically generated when you create your certificate and are stored in a separate file, often encrypted with a password.</span></span>

### <a name="certificate-types"></a><span data-ttu-id="75655-583">Tipos de Certificado</span><span class="sxs-lookup"><span data-stu-id="75655-583">Certificate Types</span></span>

<span data-ttu-id="75655-584">Os certificados digitais são geralmente utilizados para identificar entidades numa rede, mas dependendo da sua aplicação terão propriedades ligeiramente diferentes.</span><span class="sxs-lookup"><span data-stu-id="75655-584">Digital certificates are generally used to identify entities on a network, but depending on what their application they will have slightly different properties.</span></span>

### <a name="local-certificates"></a><span data-ttu-id="75655-585">Certificados Locais</span><span class="sxs-lookup"><span data-stu-id="75655-585">Local Certificates</span></span>

<span data-ttu-id="75655-586">Para efeitos desta documentação, referir-nos-emos aos "certificados locais" como os certificados que fornecem uma identidade para o nosso dispositivo local (outro nome possível poderia ser "certificado de dispositivo").</span><span class="sxs-lookup"><span data-stu-id="75655-586">For the purposes of this documentation, we will refer to "local certificates" as those certificates which provide an identity for our local device (another possible name could be "device certificate").</span></span> <span data-ttu-id="75655-587">Estes certificados serão fornecidos a um anfitrião remoto quando o anfitrião remoto desejar autenticar o dispositivo local.</span><span class="sxs-lookup"><span data-stu-id="75655-587">These certificates will be provided to a remote host when the remote host desires to authenticate the local device.</span></span>

### <a name="remote-certificates"></a><span data-ttu-id="75655-588">Certificados Remotos</span><span class="sxs-lookup"><span data-stu-id="75655-588">Remote Certificates</span></span>

<span data-ttu-id="75655-589">Nesta documentação, "certificados remotos" refere-se aos certificados fornecidos por um anfitrião remoto durante o aperto de mão TLS quando aplicável.</span><span class="sxs-lookup"><span data-stu-id="75655-589">In this documentation, "remote certificates" refers to those certificates provided by a remote host during the TLS handshake when applicable.</span></span> <span data-ttu-id="75655-590">O espaço para estes certificados deve ser atribuído ou o NetX Secure não poderá analisá-los e completar o aperto de mão TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-590">Space for these certificates must be allocated or NetX Secure will not be able to parse them and complete the TLS handshake.</span></span>

### <a name="signing-certificates"></a><span data-ttu-id="75655-591">Certificados de Assinatura</span><span class="sxs-lookup"><span data-stu-id="75655-591">Signing Certificates</span></span>

<span data-ttu-id="75655-592">Um "certificado de assinatura" é utilizado para assinar digitalmente outros certificados ou dados para efeitos de autenticação.</span><span class="sxs-lookup"><span data-stu-id="75655-592">A "signing certificate" is used to digitally sign other certificates or data for the purpose of authentication.</span></span> <span data-ttu-id="75655-593">Estes certificados podem ser certificados intermédios ou de raiz dentro de uma Infraestrutura de Chave Pública (PKI) e geralmente não são utilizados para identificar dispositivos ou hospedeiros individuais.</span><span class="sxs-lookup"><span data-stu-id="75655-593">These certificates may be either intermediate or root certificates within a Public Key Infrastructure (PKI) and are generally not used to identify individual devices or hosts.</span></span>

### <a name="root-ca-certificates"></a><span data-ttu-id="75655-594">Certificados Root CA</span><span class="sxs-lookup"><span data-stu-id="75655-594">Root CA Certificates</span></span>

<span data-ttu-id="75655-595">Os "certificados Root CA" são certificados de assinatura que fornecem a base de um PKI e são auto-assinados, em vez de serem assinados por outro certificado de assinatura.</span><span class="sxs-lookup"><span data-stu-id="75655-595">"Root CA certificates" are signing certificates that provide the basis of a PKI and are self-signed, rather than being signed by another signing certificate.</span></span> <span data-ttu-id="75655-596">Normalmente, pelo menos um certificado Root CA é normalmente necessário para que um Cliente TLS verifique servidores remotos.</span><span class="sxs-lookup"><span data-stu-id="75655-596">At least one Root CA certificate is typically required for a TLS Client to verify remote servers.</span></span>

### <a name="certificate-formats"></a><span data-ttu-id="75655-597">Formatos de certificado</span><span class="sxs-lookup"><span data-stu-id="75655-597">Certificate formats</span></span>

<span data-ttu-id="75655-598">Os certificados digitais são simplesmente ficheiros que contêm dados estruturados codificados utilizando a sintaxe ASN.1.</span><span class="sxs-lookup"><span data-stu-id="75655-598">Digital certificates are simply files containing structured data encoded using the ASN.1 syntax.</span></span> <span data-ttu-id="75655-599">No entanto, existem vários formatos em que os certificados podem ser armazenados e é importante ter o formato certo antes de carregar um certificado numa aplicação NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="75655-599">However, there are various formats in which certificates may be stored and it is important to have the right format before loading a certificate into a NetX Secure application.</span></span>

<span data-ttu-id="75655-600">Os formatos mais comuns para certificados são DER e PEM.</span><span class="sxs-lookup"><span data-stu-id="75655-600">The most common formats for certificates are DER and PEM.</span></span> <span data-ttu-id="75655-601">DER (para *Regras de Codificação Distintas*, um formato ASN.1) é o formato binário utilizado pela TLS na realização do aperto de mão inicial.</span><span class="sxs-lookup"><span data-stu-id="75655-601">DER (for *Distinguished Encoding Rules*, an ASN.1 format) is the binary format used by TLS when performing the initial handshake.</span></span> <span data-ttu-id="75655-602">PEM (do *Privacy Enhanced Mail)* é uma versão codificada base-64 do formato DER que é adequada para enviar e-mail ou enviar HTTP na web.</span><span class="sxs-lookup"><span data-stu-id="75655-602">PEM (from *Privacy Enhanced Mail*) is a base-64 encoded version of the DER format which is suitable for emailing or sending over HTTP on the web.</span></span> <span data-ttu-id="75655-603">Diferentes fornecedores utilizam diferentes extensões de nome de ficheiros para certificados, tais como ".pem" ou ".crt" para certificados PEM, e ".der" para certificados DER.</span><span class="sxs-lookup"><span data-stu-id="75655-603">Different vendors use different filename extensions for certificates, such as ".pem" or ".crt" for PEM certificates, and ".der" for DER certificates.</span></span> <span data-ttu-id="75655-604">Se tiver um certificado e não for claro qual o formato utilizado, a abertura do ficheiro num editor de texto permitir-lhe-á determinar o tipo uma vez que os ficheiros DER são binários codificados, e os ficheiros PEM são texto ASCII regular que começam com o cabeçalho "-----BEGIN CERTIFICATE-----".</span><span class="sxs-lookup"><span data-stu-id="75655-604">If you have a certificate and it is not clear what format is used, opening the file in a text editor will allow you to determine the type since DER files are encoded  binary, and PEM files are regular ASCII text that start with the header "-----BEGIN CERTIFICATE-----".</span></span>

<span data-ttu-id="75655-605">O NetX Secure requer que o seu certificado esteja em formato DER binário, pelo que terá de converter o seu certificado em formato DER antes de importar.</span><span class="sxs-lookup"><span data-stu-id="75655-605">NetX Secure requires that your certificate be in binary DER format, so you will need to convert your certificate into DER format before importing.</span></span> <span data-ttu-id="75655-606">Isto pode ser feito com ferramentas prontamente disponíveis, como o OpenSSL.</span><span class="sxs-lookup"><span data-stu-id="75655-606">This can be done with readily available tools such as OpenSSL.</span></span>

<span data-ttu-id="75655-607">Se necessitar de uma chave privada para a sua aplicação, o ficheiro chave será codificado utilizando PEM ou DER num formato específico (PKCS#1 para RSA, RFC 5915 para ECC).</span><span class="sxs-lookup"><span data-stu-id="75655-607">If you need a private key for your application, the key file will be encoded using PEM or DER in a specific format (PKCS#1 for RSA, RFC 5915 for ECC).</span></span> <span data-ttu-id="75655-608">O ficheiro chave privado terá de ser convertido em DER antes de ser importado.</span><span class="sxs-lookup"><span data-stu-id="75655-608">The private key file will need to be converted into DER before being imported.</span></span>

<span data-ttu-id="75655-609">Os seguintes comandos OpenSSL são dados como exemplo para converter certificados e ficheiros de chaves RSA no formato DER exigido pelo NetX Secure (ECC é semelhante – consulte a documentação OpenSSL).</span><span class="sxs-lookup"><span data-stu-id="75655-609">The following OpenSSL commands are given as an example for converting certificates and RSA key files into the DER format required by NetX Secure (ECC is similar – refer to the OpenSSL documentation).</span></span>

```C
openssl x509 -inform PEM -in <certificate> -outform DER -out cert.der
openssl x509 -inform PEM -in <root CA cert> -outform DER -out CA_cert.der
openssl rsa -inform PEM -in <private key> -outform DER -out private.key
```
### <a name="private-keys-and-certificates"></a><span data-ttu-id="75655-610">Chaves e Certificados Privados</span><span class="sxs-lookup"><span data-stu-id="75655-610">Private Keys and Certificates</span></span>

<span data-ttu-id="75655-611">Para os certificados que identifiquem um dispositivo, a chave privada associada deve ser carregada juntamente com o certificado.</span><span class="sxs-lookup"><span data-stu-id="75655-611">For certificates that identify a device, the associated private key must be loaded along with the certificate.</span></span> <span data-ttu-id="75655-612">A chave privada (que pode ser para um dos algoritmos de chave pública como RSA, Diffie-Hellman ou Elliptic-Curve Cryptography) é usada por um servidor TLS para desencriptar o material chave de entrada (o "segredo pré-mestre") de um cliente TLS, autenticando-se assim ao cliente.</span><span class="sxs-lookup"><span data-stu-id="75655-612">The private key (which may be for one of the public-key algorithms such as RSA, Diffie-Hellman, or Elliptic-Curve Cryptography) is used by a TLS server to decrypt the incoming key material (the "pre-master secret") from a TLS client, thereby authenticating itself to the client.</span></span> <span data-ttu-id="75655-613">Para um Cliente TLS, se for fornecido um certificado de identidade (um certificado com a sua chave privada associada) e um servidor solicitar um certificado de cliente, a chave privada é utilizada para autenticar o cliente – no caso da RSA o cliente encripta um símbolo utilizando a chave privada que o servidor então desencripta utilizando a chave pública do cliente, fornecida no certificado de cliente (Diffie-Hellman e ECC</span><span class="sxs-lookup"><span data-stu-id="75655-613">For a TLS Client, if an identity certificate (a certificate with its associated private key) is provided and a server requests a client certificate, the private key is used to authenticate the client – in the case of RSA the client  encrypts a token using the private key which the server then decrypts using the client's public key, provided in the client certificate (Diffie-Hellman and ECC authentication happens in a similar fashion but the details are a bit different).</span></span>

<span data-ttu-id="75655-614">Na Segurança NetX, o *nx_secure_x509_certificate_initialize* de serviço é utilizado para rubricar um certificado X.509 (ver secção "Carregar certificados no seu dispositivo" para obter mais informações) e associar opcionalmente uma chave privada a esse certificado.</span><span class="sxs-lookup"><span data-stu-id="75655-614">In NetX secure, the service *nx_secure_x509_certificate_initialize* is used to initialize an X.509 certificate (see section "Loading certificates onto your device" for more information) and optionally associate a private key with that certificate.</span></span>

<span data-ttu-id="75655-615">Se for fornecida uma chave privada, o certificado é marcado como sendo o certificado de "identidade" utilizado para identificar o dispositivo.</span><span class="sxs-lookup"><span data-stu-id="75655-615">If a private key is supplied, the certificate is marked as being the "identity" certificate used to identify the device.</span></span> <span data-ttu-id="75655-616">A chave é passada como uma bolha binária contígua e um comprimento, com um tipo de chave associado.</span><span class="sxs-lookup"><span data-stu-id="75655-616">The key is passed as a contiguous binary blob and a length, with an associated key type.</span></span> <span data-ttu-id="75655-617">O tipo de chave depende do tipo de chave (por exemplo, RSA, ECC, etc.) e do formato (por exemplo, PKCS#1 DER).</span><span class="sxs-lookup"><span data-stu-id="75655-617">The key type depends on the type of key (e.g. RSA, ECC, etc.) and the format (e.g. PKCS#1 DER).</span></span> <span data-ttu-id="75655-618">Se não for fornecida nenhuma chave, o valor NX_SECURE_X509_KEY_TYPE_NONE (valor 0x0) pode ser passado para indicar que não está a ser fornecida nenhuma chave (um comprimento de 0 e um ponteiro NX_NULL para o parâmetro de dados obterá o mesmo efeito).</span><span class="sxs-lookup"><span data-stu-id="75655-618">If no key is supplied, the value NX_SECURE_X509_KEY_TYPE_NONE (value 0x0) can be passed to indicate no key is being supplied (a length of 0 and a NX_NULL pointer for the data parameter will achieve the same effect).</span></span>

<span data-ttu-id="75655-619">A tabela seguinte mostra os tipos-chave conhecidos pelo NetX Secure e o identificador de tipo associado a ser passado para *nx_secure_x509_certificate_initialize*.</span><span class="sxs-lookup"><span data-stu-id="75655-619">The following table shows the key types known to NetX Secure and the associated type identifier to be passed into *nx_secure_x509_certificate_initialize*.</span></span> <span data-ttu-id="75655-620">Serão adicionados tipos de chaves adicionais à medida que mais algoritmos de encriptação forem adicionados ao NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="75655-620">Additional key types will be added as more encryption algorithms are added to NetX Secure.</span></span>

| <span data-ttu-id="75655-621">Identificador</span><span class="sxs-lookup"><span data-stu-id="75655-621">Identifier</span></span>                              | <span data-ttu-id="75655-622">Algoritmo</span><span class="sxs-lookup"><span data-stu-id="75655-622">Algorithm</span></span> | <span data-ttu-id="75655-623">Formato</span><span class="sxs-lookup"><span data-stu-id="75655-623">Format</span></span>   | <span data-ttu-id="75655-624">Encoding</span><span class="sxs-lookup"><span data-stu-id="75655-624">Encoding</span></span> | <span data-ttu-id="75655-625">Valor</span><span class="sxs-lookup"><span data-stu-id="75655-625">Value</span></span> |
| --------------------------------------- | --------- | -------- | -------- | ----- |
| <span data-ttu-id="75655-626">NX_SECURE_X509_KEY_TYPE_NONE</span><span class="sxs-lookup"><span data-stu-id="75655-626">NX_SECURE_X509_KEY_TYPE_NONE</span></span>            | <span data-ttu-id="75655-627">Nenhum</span><span class="sxs-lookup"><span data-stu-id="75655-627">None</span></span>      | <span data-ttu-id="75655-628">N/D</span><span class="sxs-lookup"><span data-stu-id="75655-628">N/A</span></span>      | <span data-ttu-id="75655-629">N/D</span><span class="sxs-lookup"><span data-stu-id="75655-629">N/A</span></span>      | <span data-ttu-id="75655-630">0x0</span><span class="sxs-lookup"><span data-stu-id="75655-630">0x0</span></span>   |
| <span data-ttu-id="75655-631">NX_SECURE_X509_KEY_TYPE_RSA_PKCS1_DER</span><span class="sxs-lookup"><span data-stu-id="75655-631">NX_SECURE_X509_KEY_TYPE_RSA_PKCS1_DER</span></span>   | <span data-ttu-id="75655-632">RSA</span><span class="sxs-lookup"><span data-stu-id="75655-632">RSA</span></span>       | <span data-ttu-id="75655-633">PKCs #1</span><span class="sxs-lookup"><span data-stu-id="75655-633">PKCS#1</span></span>   | <span data-ttu-id="75655-634">DER</span><span class="sxs-lookup"><span data-stu-id="75655-634">DER</span></span>      | <span data-ttu-id="75655-635">0x1</span><span class="sxs-lookup"><span data-stu-id="75655-635">0x1</span></span>   |
| <span data-ttu-id="75655-636">NX_SECURE_X509_KEY_TYPE_EC_DER</span><span class="sxs-lookup"><span data-stu-id="75655-636">NX_SECURE_X509_KEY_TYPE_EC_DER</span></span>          | <span data-ttu-id="75655-637">ECDSA</span><span class="sxs-lookup"><span data-stu-id="75655-637">ECDSA</span></span>     | <span data-ttu-id="75655-638">RFC 5915</span><span class="sxs-lookup"><span data-stu-id="75655-638">RFC 5915</span></span> | <span data-ttu-id="75655-639">DER</span><span class="sxs-lookup"><span data-stu-id="75655-639">DER</span></span>      | <span data-ttu-id="75655-640">0x2</span><span class="sxs-lookup"><span data-stu-id="75655-640">0x2</span></span>   |

### <a name="user-defined-private-key-types"></a><span data-ttu-id="75655-641">Tipos de chaves privadas definidos pelo utilizador</span><span class="sxs-lookup"><span data-stu-id="75655-641">User-defined private key types</span></span>

<span data-ttu-id="75655-642">Os valores dos identificadores-chave para o serviço *nx_secure_x509_certificate_initialize* regem as ações tomadas quando a chave privada é fornecida.</span><span class="sxs-lookup"><span data-stu-id="75655-642">The values of the key type identifiers for the *nx_secure_x509_certificate_initialize* service govern the actions taken when the private key is supplied.</span></span> <span data-ttu-id="75655-643">Para tipos conhecidos, os valores estão na gama 0x0000 0000 – 0x0000 FFFF (16 bits inferiores de um inteiro não assinado de 32 bits).</span><span class="sxs-lookup"><span data-stu-id="75655-643">For known types, the values are in the range 0x0000 0000 – 0x0000 FFFF (bottom 16 bits of a 32-bit unsigned integer).</span></span> <span data-ttu-id="75655-644">Para plataformas com tipos de chave personalizados<sup>17</sup> (como é o caso de alguns motores de encriptação baseados em hardware), um tipo de chave definido pelo utilizador na gama 0x0000 FF FF 1000-0xFFFF (top 16 bits não zero) pode ser passado como o tipo chave.</span><span class="sxs-lookup"><span data-stu-id="75655-644">For platforms with custom key types<sup>17</sup> (as is the case for some hardware-based encryption engines), a user-defined key type in the range 0x0000 1000-0xFFFF FFFF (top 16 bits non-zero) may be passed as the key type.</span></span> <span data-ttu-id="75655-645">Se alguma das 16 bits superiores do tipo chave estiver definida, os dados da chave privada são transmitidos diretamente para a rotina criptográfica adequada (por exemplo, RSA) fornecida na tabela de cifrasumita TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-645">If any of the top 16 bits of the key type are set, then the private key data is passed directly to the appropriate cryptographic routine (e.g. RSA) supplied in the TLS ciphersuite table.</span></span> <span data-ttu-id="75655-646">Os tipos de chaves definidos pelo utilizador não são analisados ou processados de outra forma antes de serem passados para a rotina criptográfica.</span><span class="sxs-lookup"><span data-stu-id="75655-646">User-defined key types are not parsed or otherwise processed before being passed to the cryptographic routine.</span></span> <span data-ttu-id="75655-647">Além disso, o tipo de chave definida pelo utilizador também será passado para a rotina criptográfica para que qualquer processamento adequado possa ser manuseado a esse nível.</span><span class="sxs-lookup"><span data-stu-id="75655-647">In addition, the user-defined key type will also be passed to the cryptographic routine so that any appropriate processing can be handled at that level.</span></span>

<span data-ttu-id="75655-648">Note que os tipos de chaves definidos pelo utilizador são geralmente utilizados para plataformas de hardware específicas que utilizam dados de chaves personalizados (possivelmente encriptados).</span><span class="sxs-lookup"><span data-stu-id="75655-648">Note that user-defined key types are generally used for specific hardware platforms that utilize custom (possibly encrypted) key data.</span></span> <span data-ttu-id="75655-649">Geralmente, isto implica que os dados-chave são gerados ou codificados usando um mecanismo específico desse fornecedor de hardware (ou no caso de um padrão como PKCS#11, uma padrão específica).</span><span class="sxs-lookup"><span data-stu-id="75655-649">Generally this implies that the key data is generated or encoded using a mechanism specific to that hardware vendor (or in the case of a standard like PKCS#11, a specific standard).</span></span> <span data-ttu-id="75655-650">Consulte a documentação da sua plataforma de hardware para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="75655-650">Consult your hardware platform documentation for more information.</span></span>

17. <span data-ttu-id="75655-651">Os tipos de chaves definidos pelo utilizador requerem uma rotina criptográfica personalizada correspondente para lidar com o formato de chave personalizada.</span><span class="sxs-lookup"><span data-stu-id="75655-651">User-defined key types require a corresponding custom cryptographic routine to handle the custom key format.</span></span> <span data-ttu-id="75655-652">A rotina criptográfica deve ter um algoritmo correspondente (por exemplo, RSA) e ser transmitida para TLS na tabela cifrasuite.</span><span class="sxs-lookup"><span data-stu-id="75655-652">The cryptographic routine must have a matching algorithm (e.g. RSA) and be passed into TLS in the ciphersuite table.</span></span> 

### <a name="loading-certificates-onto-your-device"></a><span data-ttu-id="75655-653">A carregar certificados no seu dispositivo</span><span class="sxs-lookup"><span data-stu-id="75655-653">Loading certificates onto your device</span></span>

<span data-ttu-id="75655-654">Qualquer método para carregar um ficheiro no seu dispositivo será suficiente para importar os seus certificados.</span><span class="sxs-lookup"><span data-stu-id="75655-654">Any method for loading a file onto your device will be sufficient to import your certificates.</span></span>

<span data-ttu-id="75655-655">O método mais simples para carregar um certificado é converter os dados binários codificados pelo DER numa matriz C e compilá-lo na sua aplicação como uma constante.</span><span class="sxs-lookup"><span data-stu-id="75655-655">The simplest method for loading a certificate is to convert the binary DER-encoded data into a C array and compile it into your application as a constant.</span></span> <span data-ttu-id="75655-656">Isto pode ser facilmente feito com ferramentas como "xxd" em Linux (com a opção "-i").</span><span class="sxs-lookup"><span data-stu-id="75655-656">This can be easily done with tools such as "xxd" in Linux (with the "-i" option).</span></span>

<span data-ttu-id="75655-657">Em alternativa, pode carregar o seu certificado num sistema de ficheiros flash ou outras opções de armazenamento, desde que possa passar um ponteiro para os dados do certificado na API NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="75655-657">Alternatively, you can load your certificate into a flash filesystem or other storage options as long as you can pass a pointer to the certificate data into the NetX Secure API.</span></span>

### <a name="certificate-files-needed-for-netx-secure"></a><span data-ttu-id="75655-658">Ficheiros de certificados necessários para o NetX Secure</span><span class="sxs-lookup"><span data-stu-id="75655-658">Certificate files needed for NetX Secure</span></span>

<span data-ttu-id="75655-659">Os ficheiros de certificado que terá de importar dependem da sua aplicação.</span><span class="sxs-lookup"><span data-stu-id="75655-659">The certificate files you will need to import depends on your application.</span></span> <span data-ttu-id="75655-660">Em geral, os Servidores TLS requerem um certificado para identificar o dispositivo, e os Clientes TLS exigem um ou mais *Certificados Fidedignos* para autenticar servidores remotos.</span><span class="sxs-lookup"><span data-stu-id="75655-660">In general, TLS Servers require a certificate to identify the device, and TLS Clients require one or more *Trusted Certificates* to authenticate remote servers.</span></span> <span data-ttu-id="75655-661">A tabela a seguir ilustra os certificados necessários para algumas aplicações TLS diferentes.</span><span class="sxs-lookup"><span data-stu-id="75655-661">The following table illustrates certificates needed for some different TLS applications.</span></span>

| <span data-ttu-id="75655-662">**Funcionalidade/opções TLS**</span><span class="sxs-lookup"><span data-stu-id="75655-662">**TLS functionality/options**</span></span>                     | <span data-ttu-id="75655-663">**Certificados/chaves necessários (mínimo)**</span><span class="sxs-lookup"><span data-stu-id="75655-663">**Certificates/keys needed (minimum)**</span></span>              |
| ------------------------------------------------- | --------------------------------------------------- |
| <span data-ttu-id="75655-664">Cliente TLS</span><span class="sxs-lookup"><span data-stu-id="75655-664">TLS Client</span></span>                                        | <span data-ttu-id="75655-665">Certificado root CA</span><span class="sxs-lookup"><span data-stu-id="75655-665">Root CA certificate</span></span>                                 |
| <span data-ttu-id="75655-666">Servidor TLS</span><span class="sxs-lookup"><span data-stu-id="75655-666">TLS Server</span></span>                                        | <span data-ttu-id="75655-667">Certificado local, chave privada para esse certificado</span><span class="sxs-lookup"><span data-stu-id="75655-667">Local certificate, private key for that certificate</span></span> |
| <span data-ttu-id="75655-668">Servidor TLS com autenticação de certificado de cliente</span><span class="sxs-lookup"><span data-stu-id="75655-668">TLS Server with Client Certificate Authentication</span></span> | <span data-ttu-id="75655-669">Certificado local, chave privada, Root CA</span><span class="sxs-lookup"><span data-stu-id="75655-669">Local certificate, private key, Root CA</span></span>             |
| <span data-ttu-id="75655-670">Cliente TLS com Autenticação de Certificado de Cliente</span><span class="sxs-lookup"><span data-stu-id="75655-670">TLS Client with Client Certificate Authentication</span></span> | <span data-ttu-id="75655-671">Certificado local, chave privada, Root CA</span><span class="sxs-lookup"><span data-stu-id="75655-671">Local certificate, private key, Root CA</span></span>             |
| <span data-ttu-id="75655-672">Cliente ou Servidor TLS apenas com chaves pré-partilhadas</span><span class="sxs-lookup"><span data-stu-id="75655-672">TLS Client or Server with Pre-Shared Keys only</span></span>    | <span data-ttu-id="75655-673">Nenhum (PSK utilizado em vez de certificados)</span><span class="sxs-lookup"><span data-stu-id="75655-673">None (PSK used instead of certificates)</span></span>             |

<span data-ttu-id="75655-674">Os serviços relevantes para os certificados de carregamento são os seguintes:</span><span class="sxs-lookup"><span data-stu-id="75655-674">The relevant services for loading certificates are as follows:</span></span>

| <span data-ttu-id="75655-675">**Nome API**</span><span class="sxs-lookup"><span data-stu-id="75655-675">**API Name**</span></span>                                   | <span data-ttu-id="75655-676">**Objetivo**</span><span class="sxs-lookup"><span data-stu-id="75655-676">**Purpose**</span></span>                                            |
| ---------------------------------------------- |------------------------------------------------------- |
| <span data-ttu-id="75655-677">nx_secure_x509_certificate_initialize</span><span class="sxs-lookup"><span data-stu-id="75655-677">nx_secure_x509_certificate_initialize</span></span>      | <span data-ttu-id="75655-678">Deve ser solicitado que todos os certificados povoem a estrutura NX_SECURE_X509_CERT com os seus dados de certificado e chave privada.</span><span class="sxs-lookup"><span data-stu-id="75655-678">Must be called for all certificates to populate the NX_SECURE_X509_CERT structure with your certificate data and private key.</span></span> |
| <span data-ttu-id="75655-679">nx_secure_tls_local_certificate_add</span><span class="sxs-lookup"><span data-stu-id="75655-679">nx_secure_tls_local_certificate_add</span></span>       | <span data-ttu-id="75655-680">Adicione um certificado local a uma sessão de TLS para identificar o seu dispositivo.</span><span class="sxs-lookup"><span data-stu-id="75655-680">Add a local certificate to a TLS session to identify your device.</span></span>                                                                |
| <span data-ttu-id="75655-681">nx_secure_tls_local_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="75655-681">nx_secure_tls_local_certificate_remove</span></span>    | <span data-ttu-id="75655-682">Remova um certificado local de uma sessão de TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-682">Remove a local certificate from a TLS session.</span></span>                                                                                   |
| <span data-ttu-id="75655-683">nx_secure_tls_remote_certificate_allocate</span><span class="sxs-lookup"><span data-stu-id="75655-683">nx_secure_tls_remote_certificate_allocate</span></span> | <span data-ttu-id="75655-684">Alocar espaço para um certificado remoto (chamado com um NX_SECURE_X509_CERT não-iniciado).</span><span class="sxs-lookup"><span data-stu-id="75655-684">Allocate space for a remote certificate (called with an uninitialized NX_SECURE_X509_CERT).</span></span>                                   |
| <span data-ttu-id="75655-685">nx_secure_tls_trusted_certificate_add</span><span class="sxs-lookup"><span data-stu-id="75655-685">nx_secure_tls_trusted_certificate_add</span></span>     | <span data-ttu-id="75655-686">Adicione um certificado a uma Sessão TLS como um Certificado fidedigno para autenticar anfitriões remotos.</span><span class="sxs-lookup"><span data-stu-id="75655-686">Add a certificate to a TLS Session as a Trusted Certificate for authenticating remote hosts.</span></span>                                     |
| <span data-ttu-id="75655-687">nx_secure_tls_trusted_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="75655-687">nx_secure_tls_trusted_certificate_remove</span></span>  | <span data-ttu-id="75655-688">Remova um certificado de confiança de uma Sessão TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-688">Remove a trusted certificate from a TLS Session.</span></span>                                                                                 |

### <a name="working-with-aws-iot-certificates"></a><span data-ttu-id="75655-689">Trabalhar com certificados AWS IoT</span><span class="sxs-lookup"><span data-stu-id="75655-689">Working with AWS IoT Certificates</span></span>

<span data-ttu-id="75655-690">Na interface IoT da Amazon Web Services, selecione "Security" no menu da barra lateral e selecione "Certificados".</span><span class="sxs-lookup"><span data-stu-id="75655-690">In the Amazon Web Services IoT interface, select "Security" from the sidebar menu and select "Certificates".</span></span> <span data-ttu-id="75655-691">Crie um novo certificado e siga as instruções para descarregar o seu novo certificado de dispositivo.</span><span class="sxs-lookup"><span data-stu-id="75655-691">Create a new certificate and follow the instructions to download your new device certificate.</span></span>

<span data-ttu-id="75655-692">Uma vez descarregado os seus certificados, terá de os converter em formato DER utilizando o OpenSSL ou um utilitário similar.</span><span class="sxs-lookup"><span data-stu-id="75655-692">Once you have downloaded your certificates, you will need to convert them into DER format using OpenSSL or a similar utility.</span></span>

<span data-ttu-id="75655-693">NOTA: A AWS também fornecerá um ficheiro de chave pública.</span><span class="sxs-lookup"><span data-stu-id="75655-693">NOTE: AWS will also provide a public key file.</span></span> <span data-ttu-id="75655-694">A chave pública está contida no certificado de dispositivo local, pelo que não precisa de ser importada para a sua aplicação.</span><span class="sxs-lookup"><span data-stu-id="75655-694">The public key is contained within the local device certificate so it does not need to be imported into your application.</span></span>

<span data-ttu-id="75655-695">Como exemplo, aqui estão os comandos para converter o certificado de dispositivo local e a sua chave privada em formato DER para utilização com NetX Secure:</span><span class="sxs-lookup"><span data-stu-id="75655-695">As an example, here are the commands to convert the local device certificate and its private key into DER format for use with NetX Secure:</span></span>

```C
openssl x509 -inform PEM -in <certificate> -outform DER -out cert.der
openssl x509 -inform PEM -in <root CA cert> -outform DER -out CA_cert.der
openssl rsa -inform PEM -in <private key> -outform DER -out private.key
```
<span data-ttu-id="75655-696">Os ficheiros convertidos podem ser importados para a sua aplicação seguindo as instruções acima.</span><span class="sxs-lookup"><span data-stu-id="75655-696">The converted files can be imported into your application following the above instructions.</span></span>

## <a name="x509-certificate-validation-in-netx-secure"></a><span data-ttu-id="75655-697">Validação de certificado X.509 em NetX Secure</span><span class="sxs-lookup"><span data-stu-id="75655-697">X.509 Certificate Validation in NetX Secure</span></span> 

<span data-ttu-id="75655-698">Ao utilizar o TLS com certificados X.509 para identificação e verificação do anfitrião, é importante entender como esses certificados são realmente validados.</span><span class="sxs-lookup"><span data-stu-id="75655-698">When using TLS with X.509 certificates for host identification and verification, it is important to understand how those certificates are actually validated.</span></span> <span data-ttu-id="75655-699">Embora a especificação TLS não forneça instruções detalhadas sobre como validar um certificado, refere-se à especificação X.509 (RFC 5280).</span><span class="sxs-lookup"><span data-stu-id="75655-699">While the TLS specification does not provide detailed instructions on how to validate a certificate, it does refer to the X.509 specification (RFC 5280).</span></span> <span data-ttu-id="75655-700">Em geral, espera-se que o TLS efetue pelo menos uma validação básica nos certificados de entrada (os certificados fornecidos pelo anfitrião remoto durante o aperto de mão TLS) e o NetX Secure TLS não é diferente.</span><span class="sxs-lookup"><span data-stu-id="75655-700">In general, it is expected that TLS will perform at least basic validation on incoming certificates (those certificates supplied by the remote host during the TLS handshake), and NetX Secure TLS is no different.</span></span>

### <a name="basic-x509-validation"></a><span data-ttu-id="75655-701">Validação Básica X.509</span><span class="sxs-lookup"><span data-stu-id="75655-701">Basic X.509 Validation</span></span>

<span data-ttu-id="75655-702">Para qualquer certificado de entrada, o NetX Secure TLS realizará a validação básica do caminho X.509.</span><span class="sxs-lookup"><span data-stu-id="75655-702">For any incoming certificate, NetX Secure TLS will perform basic X.509 path validation.</span></span> <span data-ttu-id="75655-703">O processo consiste em verificar a assinatura digital de cada certificado com o seu certificado emitente, que pode ser fornecido pelo anfitrião remoto ou estar localizado na loja de certificados fidedignas (ver secção "Importar certificados X.509 no NetX Secure" para obter mais informações sobre a importação de certificados fidedignos).</span><span class="sxs-lookup"><span data-stu-id="75655-703">The process involves checking each certificate's digital signature against its issuer certificate, which may be provided by the remote host or be located in the trusted certificate store (see the section "Importing X.509 certificates into NetX Secure" for more information on importing trusted certificates).</span></span> <span data-ttu-id="75655-704">O processo de validação é repetido repetidamente nos certificados emitentes até que um certificado de confiança seja atingido ou o fim da cadeia (com um certificado auto-assinado ou um certificado emitente em falta).</span><span class="sxs-lookup"><span data-stu-id="75655-704">The validation process is recursively repeated on the issuer certificates until a trusted certificate is reached or the chain ends (with a self-signed certificate or a missing issuer certificate).</span></span> <span data-ttu-id="75655-705">Se for alcançado um certificado de confiança, o certificado é verificado, caso contrário será rejeitado.</span><span class="sxs-lookup"><span data-stu-id="75655-705">If a trusted certificate is reached, the certificate is verified, otherwise it is rejected.</span></span> <span data-ttu-id="75655-706">Adicionalmente, em cada fase do processo de verificação, a data de validade de cada certificado é verificada em função do tempo de envio da aplicação (consulte o serviço "nx_secure_tls_session_time_function_set" para obter mais informações).</span><span class="sxs-lookup"><span data-stu-id="75655-706">Additionally, at each stage in the verification process the expiration date of each certificate is checked against the time provided by the application timestamp function (see the service "nx_secure_tls_session_time_function_set" for more information).</span></span>

<span data-ttu-id="75655-707">A especificação X.509 também fornece um algoritmo para apoiar "políticas", que são identificadores que estão presentes numa extensão X.509 que pode ser verificada durante a validação do caminho.</span><span class="sxs-lookup"><span data-stu-id="75655-707">The X.509 specification also provides an algorithm for supporting "policies", which are identifiers that are present in an X.509 extension that can be checked during path validation.</span></span> <span data-ttu-id="75655-708">O NetX Secure trata atualmente os certificados X.509 como se a opção "anyPolicy" fosse definida – ou seja, todas as políticas são aceitáveis e a verificação de políticas opcional não é realizada.</span><span class="sxs-lookup"><span data-stu-id="75655-708">NetX Secure currently treats X.509 certificates as though the "anyPolicy" option is defined – that is, all policies are acceptable and the optional policy checking is not performed.</span></span> <span data-ttu-id="75655-709">A implementação NetX Secure X.509 pode ser aumentada com esta funcionalidade numa futura versão.</span><span class="sxs-lookup"><span data-stu-id="75655-709">The NetX Secure X.509 implementation may be augmented with this feature in a future release.</span></span> <span data-ttu-id="75655-710">Por enquanto, a extensão da apólice pode ser obtida a partir de um certificado utilizando a *API nx_secure_x509_extension_find.*</span><span class="sxs-lookup"><span data-stu-id="75655-710">For now, the policy extension may be obtained from a certificate using the *nx_secure_x509_extension_find* API.</span></span>

<span data-ttu-id="75655-711">Uma vez concluída a validação do percurso básico, a TLS invocará a chamada de verificação do certificado fornecida pela aplicação utilizando a API *nx_secure_tls_session_certificate_callback_set.*</span><span class="sxs-lookup"><span data-stu-id="75655-711">Once the basic path validation is complete, TLS will invoke the certificate verification callback supplied by the application using the *nx_secure_tls_session_certificate_callback_set* API.</span></span> <span data-ttu-id="75655-712">Se não for fornecida nenhuma chamada, considera-se que o certificado é de confiança na sequência de uma validação bem sucedida do caminho.</span><span class="sxs-lookup"><span data-stu-id="75655-712">If no callback is supplied, the certificate is considered to be trusted following successful path validation.</span></span> <span data-ttu-id="75655-713">Se for fornecida uma chamada, a chamada realizará qualquer validação adicional do certificado exigido pelo pedido.</span><span class="sxs-lookup"><span data-stu-id="75655-713">If a callback is supplied, the callback will perform any additional validation of the certificate required by the application.</span></span> <span data-ttu-id="75655-714">O valor de retorno da chamada é usado para determinar se continua com o aperto de mão TLS ou abortar o aperto de mão devido a uma falha de validação.</span><span class="sxs-lookup"><span data-stu-id="75655-714">The return value from the callback is used to determine whether to continue with the TLS handshake or to abort the handshake due to a validation failure.</span></span>

<span data-ttu-id="75655-715">A chamada é invocada com um ponteiro para a sessão TLS relevante e um ponteiro NX_SECURE_X509_CERT para o certificado a validar.</span><span class="sxs-lookup"><span data-stu-id="75655-715">The callback is invoked with a pointer to the relevant TLS session and an NX_SECURE_X509_CERT pointer to the certificate to be validated.</span></span> <span data-ttu-id="75655-716">Entre a sessão TLS e o certificado, o pedido tem todos os dados de que necessita da TLS para efetuar verificações adicionais de verificação.</span><span class="sxs-lookup"><span data-stu-id="75655-716">Between the TLS session and the certificate, the application has all of the data it needs from TLS to perform additional verification checks.</span></span>

<span data-ttu-id="75655-717">Para ajudar na validação adicional, o NetX Secure fornece rotinas X.509 para algumas operações de validação comuns, incluindo validação de DNS e verificação da Lista de Revogação de Certificados.</span><span class="sxs-lookup"><span data-stu-id="75655-717">To help with the additional validation, NetX Secure provides X.509 routines for some common validation operations, including DNS validation and Certificate Revocation List checking.</span></span> <span data-ttu-id="75655-718">Todas estas rotinas são adequadas para utilização dentro da chamada de verificação do certificado, mas também podem ser usadas para efetuar a verificação off-line dos certificados X.509.</span><span class="sxs-lookup"><span data-stu-id="75655-718">All of these routines are suitable for use within the certificate verification callback but may also be used to perform off-line checking of X.509 certificates.</span></span>

<span data-ttu-id="75655-719">A tabela seguinte resume as funções de ajudante disponíveis para o processamento de certificados X.509.</span><span class="sxs-lookup"><span data-stu-id="75655-719">The following table summarizes the available helper functions for X.509 certificate processing.</span></span> <span data-ttu-id="75655-720">Explicações mais pormenorizadas para as operações podem ser encontradas nas secções seguintes e na referência da API no capítulo 4</span><span class="sxs-lookup"><span data-stu-id="75655-720">More detailed explanations for the operations can be found in the following sections and the API reference in Chapter 4</span></span>  
  
<span data-ttu-id="75655-721">A descrição dos Serviços Seguros NetX fornece detalhes adicionais sobre as rotinas específicas.</span><span class="sxs-lookup"><span data-stu-id="75655-721">Description of NetX Secure Services provides additional details on the specific routines.</span></span>

| <span data-ttu-id="75655-722">**Nome API**</span><span class="sxs-lookup"><span data-stu-id="75655-722">**API Name**</span></span>                             | <span data-ttu-id="75655-723">**Descrição**</span><span class="sxs-lookup"><span data-stu-id="75655-723">**Description**</span></span>                               |
| ---------------------------------------- | -------------------------------------- |
| <span data-ttu-id="75655-724">nx_secure_x509_common_name_dns_check</span><span class="sxs-lookup"><span data-stu-id="75655-724">nx_secure_x509_common_name_dns_check</span></span>               | <span data-ttu-id="75655-725">Verifique o nome comum e o nome de assunto X.509 com o nome de DNS esperados</span><span class="sxs-lookup"><span data-stu-id="75655-725">Check the X.509 subject Common Name and SubjectAltName against an expected DNS name</span></span> |
| <span data-ttu-id="75655-726">nx_secure_x509_crl_revocation_check</span><span class="sxs-lookup"><span data-stu-id="75655-726">nx_secure_x509_crl_revocation_check</span></span>                 | <span data-ttu-id="75655-727">Verifique se há um certificado revogado numa Lista de Revogação de Certificados X.509 (CRL)</span><span class="sxs-lookup"><span data-stu-id="75655-727">Check for a revoked certificate in an X.509 Certificate Revocation List (CRL)</span></span>       |
| <span data-ttu-id="75655-728">nx_secure_x509_extended_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="75655-728">nx_secure_x509_extended_key_usage_extension_parse</span></span> | <span data-ttu-id="75655-729">Parse e encontre um OID específico de chave estendida num certificado</span><span class="sxs-lookup"><span data-stu-id="75655-729">Parse and find a specific extended key usage OID in a certificate</span></span>                   |
| <span data-ttu-id="75655-730">nx_secure_x509_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="75655-730">nx_secure_x509_key_usage_extension_parse</span></span>           | <span data-ttu-id="75655-731">Parse e devolva o bitfield de utilização chave em um certificado</span><span class="sxs-lookup"><span data-stu-id="75655-731">Parse and return the key usage bitfield in a certificate</span></span>                            |
| <span data-ttu-id="75655-732">nx_secure_x509_extension_find</span><span class="sxs-lookup"><span data-stu-id="75655-732">nx_secure_x509_extension_find</span></span>                        | <span data-ttu-id="75655-733">Encontre e devolva os dados ASN.1 codificados em bruto para uma extensão específica.</span><span class="sxs-lookup"><span data-stu-id="75655-733">Find and return the raw DER-encoded ASN.1 data for a specific extension.</span></span>            |

<span data-ttu-id="75655-734">Funções de ajudante X.509 para utilização na chamada de verificação de certificados</span><span class="sxs-lookup"><span data-stu-id="75655-734">X.509 helper functions for use in the certificate verification callback</span></span>

### <a name="x509-extensions"></a><span data-ttu-id="75655-735">Extensões X.509</span><span class="sxs-lookup"><span data-stu-id="75655-735">X.509 Extensions</span></span>

<span data-ttu-id="75655-736">A especificação X.509 descreve uma série de "extensões" que podem ser usadas para fornecer informações adicionais que podem ser utilizadas na verificação de certificados.</span><span class="sxs-lookup"><span data-stu-id="75655-736">The X.509 specification describes a number of "extensions" that can be used to supply additional information that can be utilized in the verification of certificates.</span></span> <span data-ttu-id="75655-737">Na maior parte das vezes, estas extensões são opcionais e não são necessárias para validação segura de um certificado digital contra um certificado de raiz fidedigno.</span><span class="sxs-lookup"><span data-stu-id="75655-737">For the most part, these extensions are optional and are not required for secure validation of a digital certificate against a trusted root certificate.</span></span> <span data-ttu-id="75655-738">No entanto, o NetX Secure suporta algumas extensões básicas.</span><span class="sxs-lookup"><span data-stu-id="75655-738">However, NetX Secure does support some basic extensions.</span></span> <span data-ttu-id="75655-739">O suporte a extensões adicionais pode ser adicionado em futuras versões.</span><span class="sxs-lookup"><span data-stu-id="75655-739">Support for additional extensions may be added in future releases.</span></span>

<span data-ttu-id="75655-740">As extensões atualmente suportadas estão listadas no quadro seguinte:</span><span class="sxs-lookup"><span data-stu-id="75655-740">The currently supported extensions are listed in the following table:</span></span>

| <span data-ttu-id="75655-741">Nome de extensão</span><span class="sxs-lookup"><span data-stu-id="75655-741">Extension Name</span></span>           | <span data-ttu-id="75655-742">Descrição</span><span class="sxs-lookup"><span data-stu-id="75655-742">Description</span></span>                                                                   | <span data-ttu-id="75655-743">API relevante</span><span class="sxs-lookup"><span data-stu-id="75655-743">Relevant API</span></span>                                             |
| ------------------------ | ----------------------------------------------------------------------------- | -------------------------------------------------------- |
| <span data-ttu-id="75655-744">Utilização de Chaves</span><span class="sxs-lookup"><span data-stu-id="75655-744">Key Usage</span></span>                | <span data-ttu-id="75655-745">Fornece usos aceitáveis para a chave pública de um certificado em um campo de bits</span><span class="sxs-lookup"><span data-stu-id="75655-745">Provides acceptable uses for a certificate's public key in a bitfield</span></span>         | <span data-ttu-id="75655-746">nx_secure_x509_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="75655-746">nx_secure_x509_key_usage_extension_parse</span></span>           |
| <span data-ttu-id="75655-747">Utilização Alargada da Chave</span><span class="sxs-lookup"><span data-stu-id="75655-747">Extended Key Usage</span></span>       | <span data-ttu-id="75655-748">Fornece utilizações aceitáveis adicionais para a chave pública de um certificado utilizando OIDs</span><span class="sxs-lookup"><span data-stu-id="75655-748">Provides additional acceptable uses for a certificate's public key using OIDs</span></span> | <span data-ttu-id="75655-749">nx_secure_x509_extended_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="75655-749">nx_secure_x509_extended_key_usage_extension_parse</span></span> |
| <span data-ttu-id="75655-750">Nome Alternativo do Requerente</span><span class="sxs-lookup"><span data-stu-id="75655-750">Subject Alternative Name</span></span> | <span data-ttu-id="75655-751">Fornece nomes DNS alternativos que também são representados pelo certificado</span><span class="sxs-lookup"><span data-stu-id="75655-751">Provides alternative DNS names that are also represented by the certificate</span></span>   | <span data-ttu-id="75655-752">nx_secure_x509_common_name_dns_check</span><span class="sxs-lookup"><span data-stu-id="75655-752">nx_secure_x509_common_name_dns_check</span></span>               |

### <a name="unsupported-x509-extensions"></a><span data-ttu-id="75655-753">Extensões X.509 não suportadas</span><span class="sxs-lookup"><span data-stu-id="75655-753">Unsupported X.509 Extensions</span></span>

<span data-ttu-id="75655-754">A implemenação X.509 da NetX Secure fornece um serviço para extrair extensões não apoiadas também: *nx_secure_x509_extension_find*.</span><span class="sxs-lookup"><span data-stu-id="75655-754">NetX Secure's X.509 implemenation does provide a service to extract unsupported extensions as well: *nx_secure_x509_extension_find*.</span></span> <span data-ttu-id="75655-755">Esta API destina-se a utilizadores avançados, uma vez que requer conhecimentos de ASN.1 codificados pelo DER, a fim de analisar os dados devolvidos.</span><span class="sxs-lookup"><span data-stu-id="75655-755">This API is intended for advanced users as it requires knowledge of DER-encoded ASN.1 in order to parse the data returned.</span></span> <span data-ttu-id="75655-756">Utilizou-se internamente para extrair extensões suportadas, mas é fornecido por conveniência no desenvolvimento de suporte personalizado para extensões X.509.</span><span class="sxs-lookup"><span data-stu-id="75655-756">It it used internally to extract supported extensions but is supplied for convenience in developing customized support for X.509 extensions.</span></span>

<span data-ttu-id="75655-757">Para utilizar nx_secure_x509_extension_find, é passado um NX_SECURE_X509_EXTENSION, juntamente com o certificado e um ID de extensão, que é uma representação mais longa da cadeia OID de comprimento variável para um tipo de extensão conhecido.</span><span class="sxs-lookup"><span data-stu-id="75655-757">To use nx_secure_x509_extension_find, a NX_SECURE_X509_EXTENSION is passed in, along with the certificate and an extension ID, which is an integer representation of the variable-length OID string for a known extension type.</span></span> <span data-ttu-id="75655-758">Uma lista completa de OIDs suportados para extensões X.509 está fornecida na referência API para nx_secure_x509_extension_find na página 178.</span><span class="sxs-lookup"><span data-stu-id="75655-758">A complete list of supported OIDs for X.509 extensions is provided in the API reference for nx_secure_x509_extension_find on page 178.</span></span>

<span data-ttu-id="75655-759">A estrutura NX_SECURE_X509_EXTENSION é definida da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="75655-759">The NX_SECURE_X509_EXTENSION structure is defined as follows:</span></span>

```C
typedef struct NX_SECURE_X509_EXTENSION_STRUCT
{
    /* Identifier (maps to OID) for this extension. */
    USHORT nx_secure_x509_extension_id;

    /* Critical flag - boolean value. */
    USHORT nx_secure_x509_extension_critical;

    /* Pointer to DER-encoded extension data. */
    const UCHAR *nx_secure_x509_extension_data;
    ULONG        nx_secure_x509_extension_data_length;
} NX_SECURE_X509_EXTENSION;
```
<span data-ttu-id="75655-760">Quando o serviço regressar com sucesso, a estrutura será povoada com os dados relevantes do certificado.</span><span class="sxs-lookup"><span data-stu-id="75655-760">When the service returns successfully, the structure will be populated with the relevant data from the certificate.</span></span> <span data-ttu-id="75655-761">O campo nx_secure_x509_extension_id é geralmente utilizado para fins internos, mas será povoado com a representação de inteiros OID relevante.</span><span class="sxs-lookup"><span data-stu-id="75655-761">The nx_secure_x509_extension_id field is generally used for internal purposes but will be populated with the relevant OID integer representation.</span></span> <span data-ttu-id="75655-762">O campo nx_secure_x509_extension_critical expõe o valor crítico da bandeira de extensão X.509 (Boolean).</span><span class="sxs-lookup"><span data-stu-id="75655-762">The nx_secure_x509_extension_critical field exposes the X.509 critical extension flag value (Boolean).</span></span> <span data-ttu-id="75655-763">Os campos nx_secure_x509_extension_data e nx_secure_x509_extension_data_length contêm um ponteiro para os dados ASN.1 codificados pelo DER para a extensão e o comprimento desses dados, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="75655-763">The nx_secure_x509_extension_data and nx_secure_x509_extension_data_length fields contain a pointer to the DER-encoded ASN.1 data for the extension, and the length of that data, respectively.</span></span>

<span data-ttu-id="75655-764">A análise real dos dados da extensão ASN.1 está fora do âmbito deste documento, mas se tiver acesso à fonte NetX Secure TLS pode ver como a análise é feita onde quer que nx_secure_x509_extension_find seja chamada para extensões apoiadas.</span><span class="sxs-lookup"><span data-stu-id="75655-764">Actual parsing of the extension ASN.1 data is beyond the scope of this document, but if you have access to the NetX Secure TLS source you can see how the parsing is done wherever nx_secure_x509_extension_find is called for supported extensions.</span></span>

### <a name="x509-dns-validation"></a><span data-ttu-id="75655-765">Validação de DNS X.509</span><span class="sxs-lookup"><span data-stu-id="75655-765">X.509 DNS Validation</span></span>

<span data-ttu-id="75655-766">Uma operação comum de validação de certificados em TLS envolve verificar o nome Top-Level Domínio (TLD) de um hospedeiro remoto contra o certificado X.509 fornecido por esse anfitrião durante o aperto de mão TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-766">A common certificate validation operation in TLS involves checking the Top-Level Domain (TLD) name of a remote host against the X.509 certificate provided by that host during the TLS handshake.</span></span> <span data-ttu-id="75655-767">Esta operação ajuda a garantir que o certificado corresponde de facto ao servidor anfitrião que o forneceu, assumindo que a procura de DNS é de confiança.</span><span class="sxs-lookup"><span data-stu-id="75655-767">This operation helps to ensure that the certificate does indeed match the host server that provided it, assuming the DNS lookup can be trusted.</span></span> <span data-ttu-id="75655-768">No NetX Secure TLS, esta funcionalidade é fornecida pelo **nx_secure_x509_common_name_dns_check** de serviço , que recebe o certificado e uma cadeia contendo a parte TLD do URL utilizado para aceder ao anfitrião.</span><span class="sxs-lookup"><span data-stu-id="75655-768">In NetX Secure TLS, this functionality is provided by the service **nx_secure_x509_common_name_dns_check**, which takes the certificate and a string containing the TLD portion of the URL used to access the host.</span></span> <span data-ttu-id="75655-769">O TLD é comparado com o campo nome comum do certificado e, se corresponder, NX_SUCCESS é devolvido.</span><span class="sxs-lookup"><span data-stu-id="75655-769">The TLD is compared to the certificate's Common Name field and if it matches, NX_SUCCESS is returned.</span></span> <span data-ttu-id="75655-770">Se o Nome Comum não corresponder, a rotina também verificará a existência do *sujeito* de extensão de certificado X.509AltName .</span><span class="sxs-lookup"><span data-stu-id="75655-770">If the Common Name does not match, the routine will also check for the existence of the X.509 certificate extension *subjectAltName*.</span></span> <span data-ttu-id="75655-771">Se estiver presente um assuntoAltName, quaisquer entradas dnsname na extensão também são verificadas contra o TLD fornecido.</span><span class="sxs-lookup"><span data-stu-id="75655-771">If a subjectAltName is present, any DNSName entries in the extension are also checked against the provided TLD.</span></span> <span data-ttu-id="75655-772">Mais uma vez, se houver qualquer jogo, NX_SUCCESS é devolvido.</span><span class="sxs-lookup"><span data-stu-id="75655-772">Again, if any match, NX_SUCCESS is returned.</span></span> <span data-ttu-id="75655-773">Se não for encontrado qualquer correspondência, é devolvido um erro adequado para a devolução da chamada de validação do certificado.</span><span class="sxs-lookup"><span data-stu-id="75655-773">If no match is found, an error suitable for returning from the certificate validation callback is returned.</span></span>

### <a name="x509-key-usage-and-extended-key-usage-extensions"></a><span data-ttu-id="75655-774">Utilização da chave X.509 e extensões de utilização de chaves estendidas</span><span class="sxs-lookup"><span data-stu-id="75655-774">X.509 Key Usage and Extended Key Usage Extensions</span></span>

<span data-ttu-id="75655-775">As extensões de utilização da chave X.509 e extensões de utilização de chaves estendidas fornecem informações sobre como a chave pública de um certificado pode ser usada ao autenticar esse certificado.</span><span class="sxs-lookup"><span data-stu-id="75655-775">The X.509 Key Usage and Extended Key Usage extensions provide information on how a certificate's public key may be used when authenticating that certificate.</span></span> <span data-ttu-id="75655-776">A utilização da chave é fornecida pelo emitente do certificado quando o certificado é assinado e emitido.</span><span class="sxs-lookup"><span data-stu-id="75655-776">The key usage is supplied by the certificate's issuer when the certificate is signed and issued.</span></span> <span data-ttu-id="75655-777">A utilização da chave pode ser utilizada por um anfitrião TLS para verificar se o certificado está autorizado a ser utilizado para autenticar um anfitrião TLS remoto e realizar outras operações.</span><span class="sxs-lookup"><span data-stu-id="75655-777">The key usage may be used by a TLS host to check that the certificate is authorized to be used to authenticate a remote TLS host and perform other operations.</span></span>

<span data-ttu-id="75655-778">A extensão de utilização da chave consiste num simples bitfield onde cada um dos bits representa uma utilização específica da chave.</span><span class="sxs-lookup"><span data-stu-id="75655-778">The Key Usage extension consists of a simple bitfield where each of the bits represents a specific key usage.</span></span> <span data-ttu-id="75655-779">Uma lista completa destes valores é fornecida na referência da API para *nx_secure_x509_key_usage_extension_parse* na página 183.</span><span class="sxs-lookup"><span data-stu-id="75655-779">A complete list of these values is provided in the API reference for *nx_secure_x509_key_usage_extension_parse* on page 183.</span></span> <span data-ttu-id="75655-780">Para uma descrição mais completa das partes-chave de utilização e dos seus significados, consulte o RFC 5280, secção 4.2.1.3.</span><span class="sxs-lookup"><span data-stu-id="75655-780">For a more complete description of the key usage bits and their meanings, refer to RFC 5280, section 4.2.1.3.</span></span>

<span data-ttu-id="75655-781">A extensão de utilização da chave estendida, tal como a extensão de utilização da chave, fornece informações aceitáveis sobre o uso da chave.</span><span class="sxs-lookup"><span data-stu-id="75655-781">The Extended Key Usage extension, like the Key Usage extension, provides acceptable key use information.</span></span> <span data-ttu-id="75655-782">No entanto, para suportar utilizações arbitrárias, a extensão de utilização da chave estendida utiliza OIDs em vez de um bitfield.</span><span class="sxs-lookup"><span data-stu-id="75655-782">However, in order to support arbitrary usages, the Extended Key Usage extension utilizes OIDs instead of a bitfield.</span></span> <span data-ttu-id="75655-783">Ao analisar uma extensão de Utilização de Chave Estendida no NetX Secure X.509, um inteiro que representa o OID é fornecido pela aplicação – o serviço *nx_secure_x509_extended_key_usage_extension_parse* irá então devolver se o OID está presente.</span><span class="sxs-lookup"><span data-stu-id="75655-783">When parsing an Extended Key Usage extension in NetX Secure X.509, an integer representing the OID is supplied by the application – the *nx_secure_x509_extended_key_usage_extension_parse* service will then return whether that OID is present.</span></span> <span data-ttu-id="75655-784">Uma lista completa de OIDs suportados para utilização de chave estendida é fornecida na referência API para *nx_secure_x509_extended_key_usage_extension_parse* na página 175.</span><span class="sxs-lookup"><span data-stu-id="75655-784">A complete list of supported OIDs for Extended Key usage is provided in the API reference for *nx_secure_x509_extended_key_usage_extension_parse* on page 175.</span></span> <span data-ttu-id="75655-785">Para uma descrição mais completa dos OIDs e seus significados, consulte RFC 5280, secção 4.2.1.12.</span><span class="sxs-lookup"><span data-stu-id="75655-785">For a more complete description of the OIDs and their meanings, refer to RFC 5280, section 4.2.1.12.</span></span>

### <a name="x509-crl-revocation-status-checking"></a><span data-ttu-id="75655-786">Verificação do estado de revogação de X.509 CRL</span><span class="sxs-lookup"><span data-stu-id="75655-786">X.509 CRL Revocation Status Checking</span></span>

<span data-ttu-id="75655-787">A X.509 fornece um mecanismo chamado *Lista de Revogação* de Certificados (CRL) que permite a uma autoridade de assinatura de certificado digital revogar a validade dos certificados que assinou.</span><span class="sxs-lookup"><span data-stu-id="75655-787">X.509 provides a mechanism called the *Certificate Revocation List* (CRL) that allows a digital certificate signing authority to revoke the validity of certificates it has signed.</span></span> <span data-ttu-id="75655-788">Qualquer pedido que precise de verificar os certificados de uma autoridade de assinatura pode obter um CRL e comparar quaisquer certificados assinados por essa autoridade (emitente) contra o CRL para ver se tiveram o seu estatuto revogado por alguma razão (como chave privada comprometida).</span><span class="sxs-lookup"><span data-stu-id="75655-788">Any application that needs to verify certificates from a signing authority can obtain a CRL and compare any certificates signed by that authority (issuer) against the CRL to see if they have had their status revoked for some reason (such as compromised private key).</span></span> <span data-ttu-id="75655-789">Desta forma, o pedido pode evitar a utilização de certificados potencialmente perigosos que passam outros controlos de validação de certificados.</span><span class="sxs-lookup"><span data-stu-id="75655-789">In this way, the application can avoid using potentially dangerous certificates that pass other certificate validation checks.</span></span>

<span data-ttu-id="75655-790">A obtenção de um CRL é feita através de uma aplicação, descarregando a lista codificada de DER a partir de um servidor pré-definido ou através de outros meios.</span><span class="sxs-lookup"><span data-stu-id="75655-790">Obtaining a CRL is done by an application by downloading the DER-encoded list from a pre-defined server or through some other means.</span></span> <span data-ttu-id="75655-791">A configuração real varia de emitente para emitente, pelo que o NetX Secure não fornece um mecanismo para a obtenção de CRLs, mas fornece uma rotina para verificar um certificado contra um CRL, **nx_secure_x509_crl_revocation_check**.</span><span class="sxs-lookup"><span data-stu-id="75655-791">The actual setup varies from issuer to issuer so NetX Secure does not provide a mechanism for obtaining CRLs, but it does provide a routine to check a certificate against a CRL, **nx_secure_x509_crl_revocation_check**.</span></span>

<span data-ttu-id="75655-792">A API leva um CRL codificado pelo DER, uma loja de certificados (como a de uma sessão de TLS) para verificar e o certificado a ser verificado.</span><span class="sxs-lookup"><span data-stu-id="75655-792">The API takes a DER-encoded CRL, a certificate store (such as the one in a TLS session) to check against, and the certificate to be checked.</span></span> <span data-ttu-id="75655-793">A rotina primeiro valida o próprio CRL contra a loja fidedigna (parte da loja de certificados fornecida pela aplicação).</span><span class="sxs-lookup"><span data-stu-id="75655-793">The routine first validates the CRL itself against the trusted store (part of the certificate store provided by the application).</span></span> <span data-ttu-id="75655-794">Isto é importante para proteger contra os CRLs fraudulentos que estão a ser utilizados para ataques de negação de serviço e estabelece que o CRL é, na verdade, do emitente adequado.</span><span class="sxs-lookup"><span data-stu-id="75655-794">This is important to protect against fraudulent CRLs being used for Denial-of-Service attacks and establishes that the CRL is actually from the proper issuer.</span></span> <span data-ttu-id="75655-795">Após a validação do CRL, o emitente é verificado – se o emitente do CRL não corresponder ao emitente do certificado, então o CRL não é válido para esse certificado e um erro é devolvido.</span><span class="sxs-lookup"><span data-stu-id="75655-795">Following the CRL validation, the issuer is checked – if the issuer of the CRL does not match the issuer of the certificate, then the CRL is not valid for that certificate and an error is returned.</span></span> <span data-ttu-id="75655-796">Cabe à aplicação determinar se o aperto de mão TLS pode continuar neste momento.</span><span class="sxs-lookup"><span data-stu-id="75655-796">It is up to the application to determine whether the TLS handshake can continue at this point.</span></span> <span data-ttu-id="75655-797">Se os emitentes corresponderem, então o CRL é procurado pelo número de série do certificado que está a ser validado.</span><span class="sxs-lookup"><span data-stu-id="75655-797">If the issuers do match, then the CRL is searched for the serial number of the certificate being validated.</span></span> <span data-ttu-id="75655-798">Se o número de série estiver presente na lista, é devolvido um erro que indique que o certificado foi revogado.</span><span class="sxs-lookup"><span data-stu-id="75655-798">If the serial number is present in the list, an error indicating that the certificate has been revoked is returned.</span></span> <span data-ttu-id="75655-799">Se não for encontrado fósforo, NX_SUCCESS é devolvido.</span><span class="sxs-lookup"><span data-stu-id="75655-799">If no match is found, NX_SUCCESS is returned.</span></span>

## <a name="client-certificate-authentication-in-netx-secure-tls"></a><span data-ttu-id="75655-800">Autenticação de Certificado de Cliente em NetX Secure TLS</span><span class="sxs-lookup"><span data-stu-id="75655-800">Client Certificate Authentication in NetX Secure TLS</span></span>

<span data-ttu-id="75655-801">Ao utilizar a autenticação do certificado X.509, o protocolo TLS exige que a instância do Servidor TLS forneça um certificado de identificação, mas por padrão a instância do Cliente TLS não necessita de fornecer um certificado de autenticação, utilizando outra forma de autenticação em vez disso (por exemplo, um nome de utilizador/combinação de palavra-passe).</span><span class="sxs-lookup"><span data-stu-id="75655-801">When using X.509 certificate authentication, the TLS protocol requires that the TLS Server instance provide a certificate for identification, but by default the TLS Client instance does not need to provide a certificate for authentication, using another form of authentication instead (e.g. a username/password combination).</span></span> <span data-ttu-id="75655-802">Isto corresponde ao uso mais comum de TLS na Internet para web sites.</span><span class="sxs-lookup"><span data-stu-id="75655-802">This matches the most common use of TLS on the Internet for Web sites.</span></span> <span data-ttu-id="75655-803">Por exemplo, um site de retalho online deve provar a um potencial cliente usando um navegador web que o servidor é legítimo, mas o utilizador usará um login/senha para aceder a uma conta específica.</span><span class="sxs-lookup"><span data-stu-id="75655-803">For example, an online retail site must prove to a potential customer using a web browser that the server is legitimate, but the user will use a login/password to access a specific account.</span></span>

<span data-ttu-id="75655-804">No entanto, o caso padrão nem sempre é desejável, pelo que o TLS permite opcionalmente que a instância do Servidor TLS solicite um certificado ao Cliente remoto.</span><span class="sxs-lookup"><span data-stu-id="75655-804">However, the default case is not always desirable, so TLS optionally allows for the TLS Server instance to request a certificate from the remote Client.</span></span> <span data-ttu-id="75655-805">Quando esta funcionalidade estiver ativada, o Servidor TLS enviará uma mensagem CertificateRequest ao Cliente TLS durante o aperto de mão.</span><span class="sxs-lookup"><span data-stu-id="75655-805">When this feature is enabled, the TLS Server will send a CertificateRequest message to the TLS Client during the handshake.</span></span> <span data-ttu-id="75655-806">O Cliente deve responder com um certificado próprio e uma mensagem CertificateVerify que contenha um símbolo criptográfico que comprove que o Cliente é dono da chave privada correspondente associada a esse certificado.</span><span class="sxs-lookup"><span data-stu-id="75655-806">The Client must respond with a certificate of its own and a CertificateVerify message which contains a cryptographic token proving that the Client owns the matching private key associated with that certificate.</span></span> <span data-ttu-id="75655-807">Se a verificação falhar ou o certificado não estiver ligado a um certificado de confiança no Servidor, o aperto de mão TLS falha.</span><span class="sxs-lookup"><span data-stu-id="75655-807">If the verification fails or the certificate is not connected to a trusted certificate on the Server, the TLS handshake fails.</span></span>

<span data-ttu-id="75655-808">Existem dois casos distintos de Autenticação de Certificado de Cliente em TLS – as seguintes secções cobrem ambos os casos.</span><span class="sxs-lookup"><span data-stu-id="75655-808">There are two separate cases for Client Certificate Authentication in TLS – the following sections cover both cases.</span></span>

### <a name="client-certificate-authentication-for-tls-clients"></a><span data-ttu-id="75655-809">Autenticação de Certificado de Cliente para Clientes TLS</span><span class="sxs-lookup"><span data-stu-id="75655-809">Client Certificate Authentication for TLS Clients</span></span>

<span data-ttu-id="75655-810">Um Cliente TLS pode tentar uma ligação a um servidor que solicite um certificado para autenticação do cliente.</span><span class="sxs-lookup"><span data-stu-id="75655-810">A TLS Client may attempt a connection to a server that requests a certificate for client authentication.</span></span> <span data-ttu-id="75655-811">Neste caso, o Cliente deve fornecer um certificado ao servidor e verificar se é dono da chave privada correspondente ou o Servidor terminará o aperto de mão TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-811">In this case the Client must provide a certificate to the server and verify that it owns the matching private key or the Server will terminate the TLS handshake.</span></span>

<span data-ttu-id="75655-812">No NetX Secure TLS, não existe uma configuração especial para suportar esta funcionalidade, mas a aplicação terá de fornecer um certificado de identificação local para a instância do Cliente TLS utilizando o serviço *nx_secure_tls_local_certificate_add.*</span><span class="sxs-lookup"><span data-stu-id="75655-812">In NetX Secure TLS, there is no special configuration to support this feature but the application will have to provide a local identification certificate for the TLS Client instance using the *nx_secure_tls_local_certificate_add* service.</span></span> <span data-ttu-id="75655-813">Se nenhum certificado for fornecido pela aplicação, mas o servidor remoto estiver a utilizar a Autenticação do Certificado de Cliente e solicitar um certificado, o aperto de mão TLS falhará.</span><span class="sxs-lookup"><span data-stu-id="75655-813">If no certificate is provided by the application but the remote server is using Client Certificate Authentication and requests a certificate, the TLS handshake will fail.</span></span> <span data-ttu-id="75655-814">O certificado fornecido à Sessão TLS com *nx_secure_tls_local_certificate_add* deve ser reconhecido pelo servidor remoto para completar o aperto de mão TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-814">The certificate provided to the TLS Session with *nx_secure_tls_local_certificate_add* must be recognized by the remote server in order to complete the TLS handshake.</span></span>

### <a name="client-certificate-authentication-for-tls-servers"></a><span data-ttu-id="75655-815">Autenticação de Certificado de Cliente para Servidores TLS</span><span class="sxs-lookup"><span data-stu-id="75655-815">Client Certificate Authentication for TLS Servers</span></span>

<span data-ttu-id="75655-816">O caso do Servidor TLS para autenticação de certificado de cliente é ligeiramente mais complexo do que o caso do Cliente TLS devido à funcionalidade ser opcional.</span><span class="sxs-lookup"><span data-stu-id="75655-816">The TLS Server case for Client Certificate Authentication is slightly more complex than the TLS Client case due to the feature being optional.</span></span> <span data-ttu-id="75655-817">Neste caso, o Servidor TLS precisa de solicitar especificamente um certificado ao cliente TLS remoto, em seguida, processar a mensagem CertificateVerify para verificar se o Cliente remoto possui a chave privada correspondente, e então o Servidor deve verificar se o certificado fornecido pelo Cliente pode ser rastreado a um certificado na loja de certificados de confiança local.</span><span class="sxs-lookup"><span data-stu-id="75655-817">In this case, the TLS Server needs to specifically request a certificate from the remote TLS Client, then process the CertificateVerify message to verify that the remote Client owns the matching private key, and then the Server must check that the certificate provided by the Client can be traced to a certificate in the local trusted certificate store.</span></span>

<span data-ttu-id="75655-818">Nas instâncias do Servidor NetX Secure TLS, a autenticação do certificado de cliente é controlada por</span><span class="sxs-lookup"><span data-stu-id="75655-818">In NetX Secure TLS Server instances, Client Certificate Authentication is controlled by</span></span> <br>
<span data-ttu-id="75655-819">o *cliente de sessão de <span class="underline"> _</span> sessão <span class="underline">_</span><span class="underline"> _</span> nx secure <span class="underline">_</span>tls <span class="underline"> _</span> verificar <span class="underline">_</span>ativar* e</span><span class="sxs-lookup"><span data-stu-id="75655-819">the *nx <span class="underline">_</span>secure <span class="underline">_</span>tls <span class="underline">_</span>session <span class="underline">_</span>client <span class="underline">_</span>verify<span class="underline">_</span>enable* and</span></span><br>
<span data-ttu-id="75655-820">*nx <span class="underline"> _</span> <span class="underline">_ secure</span>tls <span class="underline"> _</span> cliente <span class="underline">_</span><span class="underline"> _</span> verificar <span class="underline">_</span>serviços de desativação.*</span><span class="sxs-lookup"><span data-stu-id="75655-820">*nx <span class="underline">_</span>secure <span class="underline">_</span>tls <span class="underline">_</span>session <span class="underline">_</span>client <span class="underline">_</span>verify<span class="underline">_</span>disable* services.</span></span>

<span data-ttu-id="75655-821">Para ativar a Autenticação do Certificado de Cliente, uma aplicação deve ligar</span><span class="sxs-lookup"><span data-stu-id="75655-821">To enable Client Certificate Authentication, an application must call</span></span><br>
<span data-ttu-id="75655-822">*NX <span class="underline"> _</span> <span class="underline">_ secure</span>tls <span class="underline"> _</span> cliente <span class="underline">_</span><span class="underline"> _</span> verifique <span class="underline">_</span>ativar* com a instância de sessão do TLS Server antes de ligar *nx_secure_tls_session_start*.</span><span class="sxs-lookup"><span data-stu-id="75655-822">*nx <span class="underline">_</span>secure <span class="underline">_</span>tls <span class="underline">_</span>session <span class="underline">_</span>client <span class="underline">_</span>verify <span class="underline">_</span>enable* with the TLS Server session instance before calling *nx_secure_tls_session_start*.</span></span> <span data-ttu-id="75655-823">Note que ligar para este serviço numa Sessão TLS que é usada para ligações ao cliente TLS não terá qualquer efeito.</span><span class="sxs-lookup"><span data-stu-id="75655-823">Note that calling this service on a TLS Session that is used for TLS Client connections will have no effect.</span></span>

<span data-ttu-id="75655-824">Quando a autenticação do Certificado de Cliente estiver ativada, o Servidor TLS solicitará um certificado ao cliente TLS remoto durante o aperto de mão TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-824">When Client Certificate Authentication is enabled, the TLS Server will request a certificate from the remote TLS Client during the TLS handshake.</span></span> <span data-ttu-id="75655-825">No NetX Secure TLS Server, o certificado Cliente é verificado contra a loja de certificados fidedignos criados com *nx <span class="underline"> _</span> secure_tls <span class="underline">_</span><span class="underline"> _</span> adicionar certificado <span class="underline">_</span>fidedignos* após a cadeia de emitentes X.509.</span><span class="sxs-lookup"><span data-stu-id="75655-825">In NetX Secure TLS Server, the Client certificate is checked against the store of trusted certificates created with *nx <span class="underline">_</span>secure_tls <span class="underline">_</span>trusted <span class="underline">_</span>certificate<span class="underline">_</span>add* following the X.509 issuer chain.</span></span> <span data-ttu-id="75655-826">O Cliente remoto deve fornecer uma cadeia que ligue o seu certificado de identidade a um certificado na loja fidedigna ou o aperto de mão TLS falhará.</span><span class="sxs-lookup"><span data-stu-id="75655-826">The remote Client must provide a chain that connects its identity certificate to a certificate in the trusted store or the TLS handshake will fail.</span></span> <span data-ttu-id="75655-827">Além disso, se o processamento de mensagem CertificateVerify falhar, o aperto de mão TLS também falhará.</span><span class="sxs-lookup"><span data-stu-id="75655-827">Additionally, if the CertificateVerify message processing fails, the TLS handshake will also fail.</span></span>

<span data-ttu-id="75655-828">Os métodos de assinatura utilizados para o método CertificadoVerify são fixados para a versão 1.0 e TLS da versão 1.1 e são especificados pelo Servidor TLS na versão 1.2 do TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-828">The signature methods used for the CertificateVerify method are fixed for TLS version 1.0 and TLS version 1.1, and are specified by the TLS Server in TLS version 1.2.</span></span> <span data-ttu-id="75655-829">Para o TLS 1.2, os métodos de assinatura suportados geralmente seguem os métodos relevantes fornecidos na tabela do método criptográfico, mas tipicamente RSA com SHA-256 (ver a secção "Criptografia em NetX Secure TLS" para obter mais informações sobre a inicialização de TLS com métodos criptográficos).</span><span class="sxs-lookup"><span data-stu-id="75655-829">For TLS 1.2, the signature methods supported generally follow the relevant methods supplied in the cryptographic method table, but typically RSA with SHA-256 (see the section "Cryptography in NetX Secure TLS" for more information on initializing TLS with cryptographic methods).</span></span>

## <a name="cryptography-in-netx-secure-tls"></a><span data-ttu-id="75655-830">Criptografia em NetX Secure TLS</span><span class="sxs-lookup"><span data-stu-id="75655-830">Cryptography in NetX Secure TLS</span></span>

<span data-ttu-id="75655-831">O TLS define um protocolo no qual a criptografia pode ser usada para garantir comunicações de rede.</span><span class="sxs-lookup"><span data-stu-id="75655-831">TLS defines a protocol in which cryptography can be used to secure network communications.</span></span> <span data-ttu-id="75655-832">Como tal, deixa a criptografia real a ser usada bastante aberta para os utilizadores de TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-832">As such, it leaves the actual cryptography to be used fairly wide open for TLS users.</span></span> <span data-ttu-id="75655-833">A especificação requer apenas uma única cifrasuita a ser implementada – no caso do TLS 1.2, essa cifrasuite é TLS_RSA_WITH_AES_128_CBC_SHA, indicando a utilização de RSA para operações de chave pública, AES no modo CBC com teclas de 128 bits para encriptação de sessão, e SHA-1 para a autenticação de mensagens.</span><span class="sxs-lookup"><span data-stu-id="75655-833">The specification only requires a single ciphersuite to be implemented – in the case of TLS 1.2, that ciphersuite is TLS_RSA_WITH_AES_128_CBC_SHA, indicating the use of RSA for public-key operations, AES in CBC mode with 128-bit keys for session encryption, and SHA-1 for message authentication hashes.</span></span>

<span data-ttu-id="75655-834">Sendo TLS 1.2 conforme, o NetX Secure permite a TLS_RSA_WITH_AES_128_CBC_SHA cifra por padrão, mas dado o número de possíveis implementações para cada um dos métodos criptográficos devido a capacidades de hardware e outras considerações, o NetX Secure fornece uma API criptográfica genérica que permite ao utilizador especificar quais os métodos criptográficos a utilizar com TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-834">Being TLS 1.2-compliant, NetX Secure enables the mandatory TLS_RSA_WITH_AES_128_CBC_SHA ciphersuite by default, but given the number of possible implementations for each of the cryptographic methods due to hardware capabilities and other considerations, NetX Secure provides a generic cryptographic API that allows a user to specify which cryptographic methods to use with TLS.</span></span>

<span data-ttu-id="75655-835">NOTA: O mecanismo genérico de API criptográfico também permite que os utilizadores implementem os seus próprios cifrasuites, mas isso é recomendado para utilizadores avançados que estejam familiarizados com os cifrasuites e extensões TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-835">NOTE: The generic cryptographic API mechanism also allows users to implement their own ciphersuites, but this is recommended for advanced users who are familiar with the TLS ciphersuites and extensions.</span></span> <span data-ttu-id="75655-836">Por favor contacte o seu representante da Express Logic se estiver interessado em apoiar os seus próprios cifrasuites.</span><span class="sxs-lookup"><span data-stu-id="75655-836">Please contact your Express Logic representative if you are interested in supporting your own ciphersuites.</span></span>

### <a name="cryptographic-methods"></a><span data-ttu-id="75655-837">Métodos Criptográficos</span><span class="sxs-lookup"><span data-stu-id="75655-837">Cryptographic Methods</span></span>

<span data-ttu-id="75655-838">NetX Secure TLS implementa DES, 3DES, AES, MD5, HMAC-MD5, SHA-1, HMAC-SHA1, SHA-256, HMAC-SHA256, RSA e ECC (curvas selecionadas) em software com controladores de hardware para determinadas plataformas de hardware.</span><span class="sxs-lookup"><span data-stu-id="75655-838">NetX Secure TLS implements DES, 3DES, AES, MD5, HMAC-MD5, SHA-1, HMAC-SHA1, SHA-256, HMAC-SHA256, RSA, and ECC (selected curves) in software with hardware drivers for certain hardware platforms.</span></span> <span data-ttu-id="75655-839">Uma aplicação pode utilizar as rotinas criptográficas fornecidas com o NetX Secure, ou utilizar rotinas personalizadas fornecidas pelo utilizador final ou terceiros.</span><span class="sxs-lookup"><span data-stu-id="75655-839">An application may use the cryptographic routines provided with NetX Secure, or use custom routines provided by the end user or third parties.</span></span>

<span data-ttu-id="75655-840">O *NX_CRYPTO_METHOD* é um bloco de controlo projetado para uma aplicação para descrever uma implementação particular de um algoritmo criptográfico a ser usado com NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-840">The *NX_CRYPTO_METHOD* is a control block designed for an application to describe a particular implementation of a cryptographic algorithm to be used with NetX Secure TLS.</span></span> <span data-ttu-id="75655-841">Com o *NX_CRYPTO_METHOD,* uma aplicação pode facilmente integrar a sua própria implementação de cripto no NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="75655-841">With the *NX_CRYPTO_METHOD,* an application can easily integrate their own crypto implementation into NetX Secure.</span></span> <span data-ttu-id="75655-842">A estrutura *NX_CRYPTO_METHOD* é declarada como:</span><span class="sxs-lookup"><span data-stu-id="75655-842">The *NX_CRYPTO_METHOD* structure is declared as:</span></span>

```C
typedef struct NX_CRYPTO_METHOD_STRUCT
{
    /* Symbolic name of the algorithm. */
    USHORT nx_crypto_algorithm;

    /* Size of the key, in bits. */
    USHORT nx_crypto_key_size_in_bits;

    /* Size of the IV block, in bits, used for encryption. */
    USHORT nx_crypto_IV_size_in_bits;

    /* Size of the ICV block, in bits, used for authentication. */
    USHORT nx_crypto_ICV_size_in_bits;

    /* Size of the crypto block, in bytes. */
    ULONG nx_crypto_block_size_in_bytes;

    /* Size of the metadata area. */
    ULONG nx_crypto_metadata_size;

    /* nx_crypto_init function initializes the crypto method with the
        "secret key" or other state  information. The initialization 
        routine should return a handle to the caller.  This handle is 
        used in subsequent crypto operations to identify the session.  
        */

    UINT (*nx_crypto_init) (NX_CRYPTO_METHOD     *method,
                            UCHAR               *key, 
                            NX_CRYPTO_KEY_SIZE   key_size_in_bits,
                            VOID               **handler,
                            VOID                *crypto_metadata,
                            VOID                 crypto_metadata_size);

    /* NetX Secure calls the nx_crypto_cleanup routine when a TLS
       session is to be deleted (or updated).  Resources allocated 
       during the crypto operation should be released in this routine.  
       */
    UINT (*nx_crypto_cleanup) (VOID *handler);

    /* nx_crypto_operation is the actual crypto or hash operation. Note 
       that both input and output buffers are prepared by the caller. 
       For encryption or decryption operations, the crypto operation 
       routine uses the output buffer for encrypted or decrypted data. 
       For authentication operations, the authentication routine shall 
       use the output buffer for the digest. */
    UINT (*nx_crypto_operation)(UINT  op, 
                  VOID              *handler, 
                  NX_CRYPTO_METHOD  *method,
                  UCHAR             *key,
                  NX_CRYPTO_KEY_SIZE key_size_in_bits,
                  UCHAR             *input,
                  ULONG              input_length_in_byte,
                  UCHAR             *iv_ptr,
                  UCHAR             *output,
                  ULONG              output_length_in_byte,
                  VOID              *crypto_metadata,
                  VOID               crypto_metadata_size,
                  NX_PACKET*         packet_ptr,
                  VOID (*nx_crypto_hw_process_callback(NX_PACKET 
                                                       *packet_ptr, 
                                                        UINT status);
} NX_CRYPTO_METHOD;
```

<span data-ttu-id="75655-843">Abaixo está a descrição de cada elemento na estrutura *NX_CRYPTO_METHOD:*</span><span class="sxs-lookup"><span data-stu-id="75655-843">Below is the description of each element in the *NX_CRYPTO_METHOD* structure:</span></span>

- <span data-ttu-id="75655-844">nx_crypto_algorithm: Este campo identifica o algoritmo descrito no *método* variável Alguns valores válidos para NetX Secure TLS são os seguintes (consulte nx_crypto_const.h para valores específicos):</span><span class="sxs-lookup"><span data-stu-id="75655-844">nx_crypto_algorithm: This field identifies the algorithm described in the variable *method* Some valid values for NetX Secure TLS are as follows (refer to nx_crypto_const.h for specific values):</span></span>
    
  - <span data-ttu-id="75655-845">NX_CRYPTO_NONE</span><span class="sxs-lookup"><span data-stu-id="75655-845">NX_CRYPTO_NONE</span></span>    
  - <span data-ttu-id="75655-846">NX_CRYPTO_ENCRYPTION_NULL</span><span class="sxs-lookup"><span data-stu-id="75655-846">NX_CRYPTO_ENCRYPTION_NULL</span></span>    
  - <span data-ttu-id="75655-847">NX_CRYPTO_ENCRYPTION_AES_CBC</span><span class="sxs-lookup"><span data-stu-id="75655-847">NX_CRYPTO_ENCRYPTION_AES_CBC</span></span>    
  - <span data-ttu-id="75655-848">NX_CRYPTO_AUTHENTICATION_NONE</span><span class="sxs-lookup"><span data-stu-id="75655-848">NX_CRYPTO_AUTHENTICATION_NONE</span></span>    
  - <span data-ttu-id="75655-849">TLS_HASH_SHA_1</span><span class="sxs-lookup"><span data-stu-id="75655-849">TLS_HASH_SHA_1</span></span>    
  - <span data-ttu-id="75655-850">TLS_HASH_SHA_256</span><span class="sxs-lookup"><span data-stu-id="75655-850">TLS_HASH_SHA_256</span></span>    
  - <span data-ttu-id="75655-851">TLS_HASH_MD5</span><span class="sxs-lookup"><span data-stu-id="75655-851">TLS_HASH_MD5</span></span>    
  - <span data-ttu-id="75655-852">TLS_CIPHER_RSA</span><span class="sxs-lookup"><span data-stu-id="75655-852">TLS_CIPHER_RSA</span></span>    
  - <span data-ttu-id="75655-853">TLS_CIPHER_NULL</span><span class="sxs-lookup"><span data-stu-id="75655-853">TLS_CIPHER_NULL</span></span>

- <span data-ttu-id="75655-854">nx_crypto_key_size_in_bits: este campo especifica o tamanho da chave secreta utilizada pelo método.</span><span class="sxs-lookup"><span data-stu-id="75655-854">nx_crypto_key_size_in_bits: this field specifies the size of the secret key used by the method.</span></span>

- <span data-ttu-id="75655-855">nx_crypto_IV_size_in_bits: este campo especifica o tamanho do Vetor de Inicialização (IV).</span><span class="sxs-lookup"><span data-stu-id="75655-855">nx_crypto_IV_size_in_bits: this field specifies the size of the Initialization Vector (IV).</span></span> <span data-ttu-id="75655-856">Note que na maioria dos casos o bloco IV é usado apenas para algoritmos de encriptação/desencriptação.</span><span class="sxs-lookup"><span data-stu-id="75655-856">Note that in most cases the IV block is only used for encryption/decryption algorithms.</span></span> <span data-ttu-id="75655-857">Os algoritmos de autenticação e verificação raramente utilizam este campo.</span><span class="sxs-lookup"><span data-stu-id="75655-857">Authentication and verification algorithms rarely use this field.</span></span>

- <span data-ttu-id="75655-858">nx_crypto_ICV_size_in_bits: este campo especifica o tamanho do bloco Integrity Check Value (ICV).</span><span class="sxs-lookup"><span data-stu-id="75655-858">nx_crypto_ICV_size_in_bits: this field specifies the size of the Integrity Check Value (ICV) block.</span></span> <span data-ttu-id="75655-859">NOTA: Este bloco destina-se à utilização do IPsec e não é utilizado em TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-859">NOTE: This block is for IPsec usage and is unused in TLS.</span></span> <span data-ttu-id="75655-860">Consulte o NetX Duo IPsec para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="75655-860">See NetX Duo IPsec for more information.</span></span>

- <span data-ttu-id="75655-861">nx_crypto_block_size_in_bytes: este campo especifica o tamanho do bloco de algoritmo criptográfico para cifras baseadas em blocos, em bytes.</span><span class="sxs-lookup"><span data-stu-id="75655-861">nx_crypto_block_size_in_bytes: this field specifies the size of the cryptographic algorithm block for block-based ciphers, in bytes.</span></span> <span data-ttu-id="75655-862">Na maioria dos casos, este é usado por rotinas de encriptação e raramente por rotinas de autenticação.</span><span class="sxs-lookup"><span data-stu-id="75655-862">In most cases this is used by encryption routines and rarely by authentication routines.</span></span>

- <span data-ttu-id="75655-863">nx_crypto_metadata_area_size: este campo especifica o tamanho da área de metadados que este método requer.</span><span class="sxs-lookup"><span data-stu-id="75655-863">nx_crypto_metadata_area_size: this field specifies the size of the metadata area this method requires.</span></span> <span data-ttu-id="75655-864">Cada implementação pode exigir que determinada memória armazene as suas informações estatais, ou para armazenar dados intermédios (como material de transformação chave), ou para usar como uma área de risco.</span><span class="sxs-lookup"><span data-stu-id="75655-864">Each implementation may require certain memory to store its state information, or to store intermediate data (such as key transformation material), or to use as a scratch area.</span></span> <span data-ttu-id="75655-865">A quantidade de espaço exigida por uma implementação é especificada neste campo.</span><span class="sxs-lookup"><span data-stu-id="75655-865">The amount of space required by an implementation is specified in this field.</span></span> <span data-ttu-id="75655-866">A aplicação fornece o espaço de memória ao criar uma sessão TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-866">The application provides the memory space when creating a TLS session.</span></span> <span data-ttu-id="75655-867">A função criptográfica é responsável pela gestão desta área de metadados.</span><span class="sxs-lookup"><span data-stu-id="75655-867">The cryptographic function is responsible for managing this metadata area.</span></span>

- <span data-ttu-id="75655-868">nx_crypto_init: Esta é a função de inicialização para o algoritmo criptográfico.</span><span class="sxs-lookup"><span data-stu-id="75655-868">nx_crypto_init: This is the initialization function for the cryptographic algorithm.</span></span> <span data-ttu-id="75655-869">Para uma implementação que não necessita de uma rotina de inicialização, este campo pode ser definido para NX_NULL.</span><span class="sxs-lookup"><span data-stu-id="75655-869">For an implementation that does not need an initialization routine, this field may be set to NX_NULL.</span></span> <span data-ttu-id="75655-870">Um uso típico de uma função de inicialização é inicializar a estrutura interna de dados para o algoritmo.</span><span class="sxs-lookup"><span data-stu-id="75655-870">A typical use of an initialization function is to initialize the internal data structure for the algorithm.</span></span> <span data-ttu-id="75655-871">O NetX Secure TLS lidará com a inicialização da rotina criptográfica, chamando esta função internamente.</span><span class="sxs-lookup"><span data-stu-id="75655-871">NetX Secure TLS will handle initialization of the cryptographic routine by calling this function internally.</span></span>

<span data-ttu-id="75655-872">O protótipo para a função de inicialização é:</span><span class="sxs-lookup"><span data-stu-id="75655-872">The prototype for the initialization function is:</span></span>

```C
UINT crypto_init_function(NX_CRYPTO_METHOD *method, 
                          UCHAR *key, 
                          UINT  key_size_in_bits, 
                          VOID  **handle, 
                          VOID  *crypto_metadata_area, 
                          ULONG crypto_metadata_area_size);
```

  - <span data-ttu-id="75655-873">método é um ponteiro para o bloco de controlo do método cripto.</span><span class="sxs-lookup"><span data-stu-id="75655-873">method is a pointer to the crypto method control block.</span></span>

  - <span data-ttu-id="75655-874">chave é a chave secreta para o processamento dos pacotes de dados.</span><span class="sxs-lookup"><span data-stu-id="75655-874">key is the secret key string for processing the data packets.</span></span>

  - <span data-ttu-id="75655-875">key_size_in_bits define o tamanho da chave secreta, em pedaços.</span><span class="sxs-lookup"><span data-stu-id="75655-875">key_size_in_bits defines the size of the secret key, in bits.</span></span>

  - <span data-ttu-id="75655-876">handle é um item definido pela implementação que identifica uma sessão de cripto particular.</span><span class="sxs-lookup"><span data-stu-id="75655-876">handle is an implementation-defined item that identifies a particular crypto session.</span></span> <span data-ttu-id="75655-877">O valor é gerado pela rotina de inicialização, e é passado de volta para o chamador.</span><span class="sxs-lookup"><span data-stu-id="75655-877">The value is generated by the initialization routine, and is passed back to the caller.</span></span> <span data-ttu-id="75655-878">A operação de cripto subsequente ou a limpeza da rotina utilizam esta pega para identificar a sessão.</span><span class="sxs-lookup"><span data-stu-id="75655-878">The subsequent crypto operation or clean up routine use this handle to identify the session.</span></span>

  - <span data-ttu-id="75655-879">crypto_metadata é um ponteiro para a área de metadados necessária pela implementação deste algoritmo.</span><span class="sxs-lookup"><span data-stu-id="75655-879">crypto_metadata is a pointer to the metadata area required by the implementation of this algorithm.</span></span> <span data-ttu-id="75655-880">Para algoritmos que não necessitam de uma área de metadados, este campo está definido para NX_NULL e a rotina de inicialização não deve aceder à área dos metadados.</span><span class="sxs-lookup"><span data-stu-id="75655-880">For algorithms that do not need a metadata area this field is set to NX_NULL and the initialization routine must not access the metadata area.</span></span>

  - <span data-ttu-id="75655-881">crypto_metadata_size especifica o tamanho da área dos metadados.</span><span class="sxs-lookup"><span data-stu-id="75655-881">crypto_metadata_size specifies the size of the metadata area.</span></span> <span data-ttu-id="75655-882">Para sas criados sem área de metadados, este campo está definido para zero, e a rotina de inicialização não deve aceder à área dos metadados.</span><span class="sxs-lookup"><span data-stu-id="75655-882">For SAs created without metadata area, this field is set to zero, and the initialization routine must not access the metadata area.</span></span>

  - <span data-ttu-id="75655-883">Esta rotina regressará *NX_SUCCESS* se o processo de inicialização for bem sucedido.</span><span class="sxs-lookup"><span data-stu-id="75655-883">This routine shall return *NX_SUCCESS* if the initialization process is successful.</span></span> <span data-ttu-id="75655-884">O chamador trata qualquer outro valor de retorno como falha.</span><span class="sxs-lookup"><span data-stu-id="75655-884">The caller treats any other return value as failure.</span></span>

- <span data-ttu-id="75655-885">nx_crypto_cleanup: Esta é a rotina de limpeza definida para a implementação de um algoritmo cripto.</span><span class="sxs-lookup"><span data-stu-id="75655-885">nx_crypto_cleanup: This is the cleanup routine defined for the implementation of a crypto algorithm.</span></span> <span data-ttu-id="75655-886">É invocado quando uma sessão de TLS é eliminada ou reiniciada.</span><span class="sxs-lookup"><span data-stu-id="75655-886">It is invoked when a TLS session is deleted or restarted.</span></span>

<span data-ttu-id="75655-887">O protótipo para a função de limpeza é:</span><span class="sxs-lookup"><span data-stu-id="75655-887">The prototype for the cleanup function is:</span></span>

```C
UINT crypto_cleanup_function(VOID *handle);
```
- <span data-ttu-id="75655-888">o cabo é passado para a função de limpeza pelo chamador.</span><span class="sxs-lookup"><span data-stu-id="75655-888">handle is passed to the cleanup function by the caller.</span></span> <span data-ttu-id="75655-889">O cabo é inicializado pela rotina de inicialização criptográfica e usado para identificar o estado do algoritmo criptográfico.</span><span class="sxs-lookup"><span data-stu-id="75655-889">The handle is initialized by the crypto initialization routine and used to identify cryptographic algorithm state.</span></span>

- <span data-ttu-id="75655-890">Esta rotina deve voltar *NX_SUCCESS* se o processo de limpeza for bem sucedido.</span><span class="sxs-lookup"><span data-stu-id="75655-890">This routine shall return *NX_SUCCESS* if the cleanup process is successful.</span></span> <span data-ttu-id="75655-891">O chamador trata qualquer outro valor de retorno como falha.</span><span class="sxs-lookup"><span data-stu-id="75655-891">The caller treats any other return value as failure.</span></span>

- <span data-ttu-id="75655-892">nx_crypto_operation: Esta é a rotina que executa os serviços reais de encriptação, desencriptação e autenticação.</span><span class="sxs-lookup"><span data-stu-id="75655-892">nx_crypto_operation: This is the routine that performs the actual encryption, decryption, and authentication services.</span></span> <span data-ttu-id="75655-893">O protótipo de função da rotina de funcionamento é:</span><span class="sxs-lookup"><span data-stu-id="75655-893">The function prototype of the operation routine is:</span></span>

```C
UINT crypto_operation_function(UINT   op,
          VOID  *handle,  
          NX_CRYPTO_METHOD* method,
          UCHAR *key,
          UCHAR  key_size_in_bits,
          UCHAR* input,
          ULONG  input_length_in_byte,
          UCHAR* iv_ptr,
          UCHAR* output,
          ULONG  output_length_in_byte,
          VOID *crypto_metadata,
          ULONG crypto_metadata_size,
          NX_PACKET *packet_ptr,
          VOID (*nx_crypto_hw_process_callback)(NX_PACKET 
                          *packet_ptr, UINT status));
```

- <span data-ttu-id="75655-894">op indica o tipo de operação que esta rotina deve ser realizada. Valores válidos são:</span><span class="sxs-lookup"><span data-stu-id="75655-894">op indicates the type of operation this routine is expected to carry out. Valid values are:</span></span>
    
    - <span data-ttu-id="75655-895">NX_CRYPTO_ENCRYPT</span><span class="sxs-lookup"><span data-stu-id="75655-895">NX_CRYPTO_ENCRYPT</span></span>
    - <span data-ttu-id="75655-896">NX_CRYPTO_DECRYPT</span><span class="sxs-lookup"><span data-stu-id="75655-896">NX_CRYPTO_DECRYPT</span></span>
    - <span data-ttu-id="75655-897">NX_CRYPTO_AUTHENTICATE</span><span class="sxs-lookup"><span data-stu-id="75655-897">NX_CRYPTO_AUTHENTICATE</span></span>
    - <span data-ttu-id="75655-898">NX_CRYPTO_VERIFY</span><span class="sxs-lookup"><span data-stu-id="75655-898">NX_CRYPTO_VERIFY</span></span>

- <span data-ttu-id="75655-899">a pega é passada para a função de funcionamento pelo chamador.</span><span class="sxs-lookup"><span data-stu-id="75655-899">handle is passed to the operation function by the caller.</span></span> <span data-ttu-id="75655-900">É gerado pela rotina de inicialização cripto.</span><span class="sxs-lookup"><span data-stu-id="75655-900">It is generated by the crypto initialization routine.</span></span>
- <span data-ttu-id="75655-901">método aponta para o bloco de controlo do método cripto</span><span class="sxs-lookup"><span data-stu-id="75655-901">method points to the crypto method control block</span></span>
- <span data-ttu-id="75655-902">pontos-chave para a chave secreta usada para esta operação</span><span class="sxs-lookup"><span data-stu-id="75655-902">key points to the secret key used for this operation</span></span>
- <span data-ttu-id="75655-903">key_size_in_bits é o tamanho da chave secreta em pedaços</span><span class="sxs-lookup"><span data-stu-id="75655-903">key_size_in_bits is the size of the secret key in bits</span></span>
- <span data-ttu-id="75655-904">a entrada é um ponteiro para o início da mensagem a operar.</span><span class="sxs-lookup"><span data-stu-id="75655-904">input is a pointer to the beginning of the message to be operated on.</span></span>
- <span data-ttu-id="75655-905">input_length_in_byte é passado pelo chamador para indicar o tamanho da mensagem a ser operada.</span><span class="sxs-lookup"><span data-stu-id="75655-905">input_length_in_byte is passed by the caller to indicate the size of the message to be operated on.</span></span>
- <span data-ttu-id="75655-906">iv_ptr é configurado pelo chamador para apontar para o início de um bloco IV.</span><span class="sxs-lookup"><span data-stu-id="75655-906">iv_ptr is setup by the caller to point to the beginning of an IV block.</span></span> <span data-ttu-id="75655-907">Note que a memória do bloco IV é fornecida pelo autor da chamada.</span><span class="sxs-lookup"><span data-stu-id="75655-907">Note that the memory for the IV block is provided by the caller.</span></span> <span data-ttu-id="75655-908">Para encriptação, a função de funcionamento deve escrever as informações IV neste bloco de memória; para a desencriptação, a função de funcionamento deve recuperar a informação IV deste bloco de memória.</span><span class="sxs-lookup"><span data-stu-id="75655-908">For encryption, the operation function should write the IV information into this memory block; for decryption, the operation function should retrieve the IV information from this memory block.</span></span> <span data-ttu-id="75655-909">Os algoritmos para a operação de autenticação e verificação normalmente não utilizam o vetor de inicialização.</span><span class="sxs-lookup"><span data-stu-id="75655-909">Algorithms for authentication and verification operation typically do not use the initialization vector.</span></span>
- <span data-ttu-id="75655-910">a saída é configurada pelo chamador para apontar para um tampão de saída.</span><span class="sxs-lookup"><span data-stu-id="75655-910">output is setup by the caller to point to an output buffer.</span></span> <span data-ttu-id="75655-911">Note que a memória do tampão de saída é fornecida pelo autor da chamada.</span><span class="sxs-lookup"><span data-stu-id="75655-911">Note that the memory for the output buffer is provided by the caller.</span></span> <span data-ttu-id="75655-912">Para encriptação, a função de funcionamento deve escrever o texto da cifra no tampão de saída; para a desencriptação, a operação deve escrever o texto decifrado (texto claro) para o tampão de saída; para a autenticação, o valor do haxixe deve ser escrito ao tampão de saída.</span><span class="sxs-lookup"><span data-stu-id="75655-912">For encryption, the operation function should write the cipher text to the output buffer; for decryption, the operation should write the deciphered text (clear text) to the output buffer; for authentication, the hash value shall be written to the output buffer.</span></span> <span data-ttu-id="75655-913">Para verificação, o tampão de saída é utilizado para armazenar informações sobre haxixe.</span><span class="sxs-lookup"><span data-stu-id="75655-913">For verification, the output buffer is used to store hash information.</span></span>
- <span data-ttu-id="75655-914">output_length_in_byte indica o tamanho do tampão de saída</span><span class="sxs-lookup"><span data-stu-id="75655-914">output_length_in_byte indicates the size of the output buffer</span></span>
- <span data-ttu-id="75655-915">crypto_metadata aponta para a área de metadados a utilizar por esta operação cripto.</span><span class="sxs-lookup"><span data-stu-id="75655-915">crypto_metadata points to the metadata area to be used by this crypto operation.</span></span> <span data-ttu-id="75655-916">A área dos metodos criptografados é tipicamente inicializada por crypto_init_function.</span><span class="sxs-lookup"><span data-stu-id="75655-916">The crypto metadata area is typically initialized by crypto_init_function.</span></span>
- <span data-ttu-id="75655-917">crypto_metadata_size indica o tamanho da área dos metadados.</span><span class="sxs-lookup"><span data-stu-id="75655-917">crypto_metadata_size indicates the size of the metadata area.</span></span>
- <span data-ttu-id="75655-918">Esta rotina deve voltar *NX_SUCCESS* se o processo de funcionamento for bem sucedido.</span><span class="sxs-lookup"><span data-stu-id="75655-918">This routine shall return *NX_SUCCESS* if the operation process is successful.</span></span> <span data-ttu-id="75655-919">O chamador trata qualquer outro valor de retorno como falha.</span><span class="sxs-lookup"><span data-stu-id="75655-919">The caller treats any other return value as failure.</span></span>
- <span data-ttu-id="75655-920">packet_ptr: O pacote que contém os dados que estão a ser tratados.</span><span class="sxs-lookup"><span data-stu-id="75655-920">packet_ptr: The packet that contains the data being processed.</span></span> <span data-ttu-id="75655-921">NOTA: Este parâmetro não é utilizado pelo TLS e deve ser definido para NX_NULL.</span><span class="sxs-lookup"><span data-stu-id="75655-921">NOTE: This parameter is unused by TLS and should be set to NX_NULL.</span></span>
- <span data-ttu-id="75655-922">nx_crypto_hw_process_callback: Uma função de retorno fornecida pelo método de encriptação.</span><span class="sxs-lookup"><span data-stu-id="75655-922">nx_crypto_hw_process_callback: A callback function provided by the encryption method.</span></span> <span data-ttu-id="75655-923">Isto é usado se a função cripto é fornecida por hardware e requer uma rotina de retorno.</span><span class="sxs-lookup"><span data-stu-id="75655-923">This is used if the crypto function is provided by hardware and requires a callback routine.</span></span>

<span data-ttu-id="75655-924">O NetX Secure TLS fornece os seguintes métodos de encriptação:</span><span class="sxs-lookup"><span data-stu-id="75655-924">NetX Secure TLS provides the following encryption methods:</span></span>

- <span data-ttu-id="75655-925">*AES*</span><span class="sxs-lookup"><span data-stu-id="75655-925">*AES*</span></span>  
- <span data-ttu-id="75655-926">*RSA*</span><span class="sxs-lookup"><span data-stu-id="75655-926">*RSA*</span></span>  
- <span data-ttu-id="75655-927">*NULO*</span><span class="sxs-lookup"><span data-stu-id="75655-927">*NULL*</span></span>

<span data-ttu-id="75655-928">NetX Secure TLS fornece os seguintes métodos de autenticação:</span><span class="sxs-lookup"><span data-stu-id="75655-928">NetX Secure TLS provides the following authentication methods:</span></span>

- <span data-ttu-id="75655-929">*HMAC-MD5*</span><span class="sxs-lookup"><span data-stu-id="75655-929">*HMAC-MD5*</span></span>  
- <span data-ttu-id="75655-930">*HMAC-SHA1*</span><span class="sxs-lookup"><span data-stu-id="75655-930">*HMAC-SHA1*</span></span>  
- <span data-ttu-id="75655-931">*HMAC-SHA256*</span><span class="sxs-lookup"><span data-stu-id="75655-931">*HMAC-SHA256*</span></span>

<span data-ttu-id="75655-932">Os exemplos a seguir ilustram como configurar a estrutura *NX_CRYPTO_METHOD* para utilizar os métodos de encriptação e autenticação fornecidos pelo NetX Duo IPsec.</span><span class="sxs-lookup"><span data-stu-id="75655-932">The following examples illustrate how to configure the *NX_CRYPTO_METHOD* structure to use the encryption and authentication methods provided by NetX Duo IPsec.</span></span>

<span data-ttu-id="75655-933">***AES:***</span><span class="sxs-lookup"><span data-stu-id="75655-933">***AES:***</span></span>

```C
/* AES-CBC 128. */
NX_CRYPTO_METHOD crypto_method_aes_cbc_128 = 
{
    /* AES crypto algorithm                             */
    NX_CRYPTO_ENCRYPTION_AES_CBC,                       

    /* Key size in bits. For AES-128 this value is 128  */
    NX_CRYPTO_AES_128_KEY_LEN_IN_BITS,              
   
    /* IV size in bits.  For AES-128 this value is 128  */
    NX_CRYPTO_AES_IV_LEN_IN_BITS,

    /* ICV size in bits, not used.                      */
    0,                                              

    /* Block size in bytes.  For AES this value is 16   */
    (NX_CRYPTO_AES_BLOCK_SIZE_IN_BITS >> 3),        

    /* Metadata size in bytes, for AES this value is 262*/
    sizeof(NX_CRYPTO_AES),              

    /* AES-CBC initialization routine.                  */
    _nx_secure_crypto_method_aes_init,               

    /* AES-CBC cleanup routine, not used.               */
    NX_NULL,                                        

    /* AES-CBC operation                                */
    _nx_secure_crypto_method_aes_operation           
};

/* RSA. */
NX_CRYPTO_METHOD crypto_method_rsa = 
{
    /* RSA crypto algorithm                             */
    TLS_CIPHER_RSA,                       

    /* Key size. RSA key sizes vary, so set to 0.         */
    0,              
   
    /* IV size in bits.  RSA does not use an IV.         */
    0,

    /* ICV size in bits, not used.                      */
    0,                                              

    /* Block size in bytes.  RSA does not have a block size. */
    0,        

    /* Metadata size in bytes, for RSA use the control block. */
    sizeof(NX_CRYPTO_RSA),              

    /* RSA initialization routine.                  */
    _nx_secure_crypto_method_rsa_init,               

    /* Cleanup routine, not used.                    */
    NX_NULL,                                        

    /* RSA operation                                */
    _nx_secure_crypto_method_rsa_operation           

};
```
<span data-ttu-id="75655-934">***NULO***</span><span class="sxs-lookup"><span data-stu-id="75655-934">***NULL***</span></span>

```C
/* NULL encryption method. */
NX_CRYPTO_METHOD crypto_method_null = 
{
    NX_CRYPTO_ENCRYPTION_NULL,/* Name of the crypto algorithm  */
    0,                        /* Key size in bits, not used    */
    0,                        /* IV size in bits, not used     */
    0,                        /* ICV size in bits, not used    */
    4,                        /* Block size in bytes           */
    0,                        /* Metadata size in bytes        */
    NX_NULL,                  /* Initialization routine,unused */
    NX_NULL,                  /* Cleanup routine, not used     */
    _nx_secure_crypto_method_null_operation  /* NULL operation  
*/
}; 
```
<span data-ttu-id="75655-935">***HMAC-SHA1***</span><span class="sxs-lookup"><span data-stu-id="75655-935">***HMAC-SHA1***</span></span>
```C
NX_CRYPTO_METHOD crypto_method_hmac_sha1 = 
{
    /* HMAC SHA1 algorithm                               */
    TLS_HASH_SHA1,            


    /* Key size in bits. For HMAC-SHA1 this value is 160 */ 
    NX_CRYPTO_HMAC_SHA1_KEY_LEN_IN_BITS,              

    /* IV size in bits, not used                         */
    0,                                            

    /* Transmitted ICV size in bits. Unused.             */
    0, 

    /* Block size in bytes, not used                     */
    0,                                            

    /* Metadata size in bytes                            */
    sizeof(NX_SHA1_HMAC),                                            

    /* Initialization routine, not used                  */
    NX_NULL,                                      

    /* Cleanup routine, not used                         */
    NX_NULL,                                          

    /* HMAC SHA1 operation                               */
    _nx_secure_crypto_method_hmac_sha1_operation   
};
```
<span data-ttu-id="75655-936">***NENHUMA***</span><span class="sxs-lookup"><span data-stu-id="75655-936">***NONE***</span></span>

<span data-ttu-id="75655-937">Um método especial **NX_CRYPTO_NONE** é utilizado para sinalizar o módulo IPsec de que a encriptação ou o serviço de autenticação não são necessários.</span><span class="sxs-lookup"><span data-stu-id="75655-937">A special method **NX_CRYPTO_NONE** is used to signal the IPsec module that the encryption or the authentication service is not required.</span></span> <span data-ttu-id="75655-938">Está configurado da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="75655-938">It is configured as follows:</span></span>

```C
/* NX_CRYPTO_NONE means encryption or authentication
   method is not needed.  */
NX_CRYPTO_METHOD crypto_method_none = 
{
    NX_CRYPTO_NONE,       /* Name of the crypto algorithm */
    0,                    /* Key size in bits, not used   */
    0,                    /* IV size in bits, not used    */
    0,                    /* ICV size in bits, not used   */
    0,                    /* Block size in bytes          */
    0,                    /* Metadata size in bytes       */
    NX_NULL,              /* Initialization routine, not used */
    NX_NULL,              /* Cleanup routine, not used    */
    NX_NULL               /* NULL operation               */
};                                               
```
### <a name="initializing-tls-with-cryptographic-methods"></a><span data-ttu-id="75655-939">Inicialização de TLS com Métodos Criptográficos</span><span class="sxs-lookup"><span data-stu-id="75655-939">Initializing TLS with Cryptographic Methods</span></span>

<span data-ttu-id="75655-940">Depois de ter criado as suas rotinas criptográficas em conformidade com as assinaturas do método criptográfico descritas na secção anterior, terá de as passar para o TLS quando rubricar um NX_SECURE_TLS_SESSION bloco de controlo.</span><span class="sxs-lookup"><span data-stu-id="75655-940">Once you have created your cryptographic routines conforming to the cryptographic method signatures described in the previous section, you will need to pass them into TLS when you initialize an NX_SECURE_TLS_SESSION control block.</span></span> <span data-ttu-id="75655-941">Isto é feito no serviço TLS nx_secure_tls_session_create:</span><span class="sxs-lookup"><span data-stu-id="75655-941">This is done in the TLS service nx_secure_tls_session_create:</span></span>

```C
UINT  nx_secure_tls_session_create(
              NX_SECURE_TLS_SESSION*     session_ptr,
              const NX_SECURE_TLS_CRYPTO*    tls_cipher_table,
              VOID*                encryption_metadata_area,
              ULONG                 encryption_metadata_size
);
```
- <span data-ttu-id="75655-942">session_pointer é um ponteiro para o seu NX_SECURE_TLS_SESSION bloco de controlo.</span><span class="sxs-lookup"><span data-stu-id="75655-942">session_pointer is a pointer to your NX_SECURE_TLS_SESSION control block.</span></span>
- <span data-ttu-id="75655-943">tls_cipher_table é um ponteiro para um bloco de controlo NX_SECURE_TLS_CRYPTO, descrito abaixo.</span><span class="sxs-lookup"><span data-stu-id="75655-943">tls_cipher_table is a pointer to an NX_SECURE_TLS_CRYPTO control block, described below.</span></span>
- <span data-ttu-id="75655-944">encryption_metadata_area aponta para o espaço utilizado pelas rotinas criptográficas em TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-944">encryption_metadata_area points to space used by cryptographic routines in TLS.</span></span>
- <span data-ttu-id="75655-945">encryption_metadata_size é o tamanho da área de metadados em bytes.</span><span class="sxs-lookup"><span data-stu-id="75655-945">encryption_metadata_size is the size of the metadata area in bytes.</span></span>

### <a name="elliptic-curve-cryptography-ecc-in-netx-secure-tls"></a><span data-ttu-id="75655-946">Criptografia da curva elíptica (ECC) em NetX Secure TLS</span><span class="sxs-lookup"><span data-stu-id="75655-946">Elliptic Curve Cryptography (ECC) in NetX Secure TLS</span></span>

<span data-ttu-id="75655-947">A Criptografia da Curva Elíptica (ECC) fornece um esquema de criptografia de chave pública que pode ser usado em vez de RSA.</span><span class="sxs-lookup"><span data-stu-id="75655-947">Elliptic Curve Cryptography (ECC) provides a public-key cryptography scheme that can be used instead of RSA.</span></span> <span data-ttu-id="75655-948">O ECC é tipicamente mais rápido e utiliza chaves menores do que a RSA para que possa ser uma opção valiosa para TLS incorporado.</span><span class="sxs-lookup"><span data-stu-id="75655-948">ECC is typically faster and uses smaller keys than RSA so it can be a valuable option for embedded TLS.</span></span> <span data-ttu-id="75655-949">Nas versões X-Ware antes do Azure RTOS 6.0, o ECC foi enviado como um complemento, exigindo a instalação do código fonte ECC no seu projeto.</span><span class="sxs-lookup"><span data-stu-id="75655-949">In X-Ware versions prior to Azure RTOS 6.0, ECC was shipped as an add-on, requiring installation of the ECC source code into your project.</span></span> <span data-ttu-id="75655-950">Azure RTOS 6.0 integrado ECC na base de código principal para que a instalação dos ficheiros ECC não seja mais necessária.</span><span class="sxs-lookup"><span data-stu-id="75655-950">Azure RTOS 6.0 integrated ECC into the mainline codebase so installation of the ECC files is no longer necessary.</span></span> <span data-ttu-id="75655-951">No entanto, o ECC ainda requer a mesma inicialização que as versões anteriores.</span><span class="sxs-lookup"><span data-stu-id="75655-951">However, ECC still requires the same initialization as those previous versions.</span></span>

### <a name="supported-ecc-curves"></a><span data-ttu-id="75655-952">Curvas ECC suportadas</span><span class="sxs-lookup"><span data-stu-id="75655-952">Supported ECC curves</span></span>

<span data-ttu-id="75655-953">O NetX Secure implementa partes das curvas de acordo com <http://www.secg.org/sec2-v2.pdf> .</span><span class="sxs-lookup"><span data-stu-id="75655-953">NetX Secure implements parts of the curves as per <http://www.secg.org/sec2-v2.pdf>.</span></span> <span data-ttu-id="75655-954">As curvas de acontenção são suportadas<sup>18</sup>:</span><span class="sxs-lookup"><span data-stu-id="75655-954">Thefollowing curves are supported<sup>18</sup>:</span></span>

  - <span data-ttu-id="75655-955">secp256r1</span><span class="sxs-lookup"><span data-stu-id="75655-955">secp256r1</span></span> 
  - <span data-ttu-id="75655-956">secp384r1</span><span class="sxs-lookup"><span data-stu-id="75655-956">secp384r1</span></span> 
  - <span data-ttu-id="75655-957">secp521r1</span><span class="sxs-lookup"><span data-stu-id="75655-957">secp521r1</span></span> 

<span data-ttu-id="75655-958">Se forem utilizadas outras curvas ECC, a rotina *de nx_secure_tls_session_start()* devolverá o erro NX_SECURE_TLS_NO_SUPPORTED_CIPHERS indicando que foram utilizadas curvas não apoiadas.</span><span class="sxs-lookup"><span data-stu-id="75655-958">If other ECC curves are used, the *nx_secure_tls_session_start()* routine will return the error NX_SECURE_TLS_NO_SUPPORTED_CIPHERS indicating that unsupported curves were used.</span></span>

<span data-ttu-id="75655-959">Note que a cadeia de certificados TLS também pode ser encriptada por algoritmos ECC.</span><span class="sxs-lookup"><span data-stu-id="75655-959">Note that TLS certificate chain may be encrypted by ECC-algorithms as well.</span></span> <span data-ttu-id="75655-960">Mesmo que as curvas fornecidas pelo Cliente TLS sejam suportadas, é possível que a curva ECC utilizada na cadeia de certificados não seja suportada.</span><span class="sxs-lookup"><span data-stu-id="75655-960">Even though the curves provided by the TLS Client are supported, it is possible that the ECC curve used in the certificate chain is not supported.</span></span> <span data-ttu-id="75655-961">Neste caso, *nx_secure_tls_session_start* rotina regressa NX_SECURE_TLS_UNSUPPORTED_PUBLIC_CIPHER.</span><span class="sxs-lookup"><span data-stu-id="75655-961">In this case, *nx_secure_tls_session_start* routine returns NX_SECURE_TLS_UNSUPPORTED_PUBLIC_CIPHER.</span></span>

<span data-ttu-id="75655-962">Um exemplo de tabela cifrassuita padrão para ECC é fornecido em nx_crypto_generic_ciphersuites.c.</span><span class="sxs-lookup"><span data-stu-id="75655-962">A default ciphersuite table example for ECC is provided in nx_crypto_generic_ciphersuites.c.</span></span> <span data-ttu-id="75655-963">Consulte a secção "Tabela de Cifra Criptográfica TLS" para obter mais informações sobre tabelas de cifrasuite.</span><span class="sxs-lookup"><span data-stu-id="75655-963">See section "TLS Cryptographic Cipher Table" for more information on ciphersuite tables.</span></span>

18. <span data-ttu-id="75655-964">Note-se que as implementações para as curvas secp192r1 e secp224r1 também estão previstas para aplicações antigas.</span><span class="sxs-lookup"><span data-stu-id="75655-964">Note that implementations for the curves secp192r1 and secp224r1are also provided for legacy applications.</span></span> <span data-ttu-id="75655-965">No entanto, estas curvas são agora consideradas fracas e NÃO DEVEM ser utilizadas para o desenvolvimento de novas aplicações.</span><span class="sxs-lookup"><span data-stu-id="75655-965">However these curves are now considered weak and SHOULD NOT be used for new application development.</span></span>

### <a name="crypto-methods-for-ecc"></a><span data-ttu-id="75655-966">Métodos Cripto para ECC</span><span class="sxs-lookup"><span data-stu-id="75655-966">Crypto Methods for ECC</span></span>

<span data-ttu-id="75655-967">Métodos cripto para grupos de curvas elípticas:</span><span class="sxs-lookup"><span data-stu-id="75655-967">Crypto methods for Elliptic Curve groups:</span></span>

- <span data-ttu-id="75655-968">NX_CRYPTO_METHOD crypto_method_ec_secp192<sup>15;</sup></span><span class="sxs-lookup"><span data-stu-id="75655-968">NX_CRYPTO_METHOD crypto_method_ec_secp192<sup>15</sup>;</span></span>  
- <span data-ttu-id="75655-969">NX_CRYPTO_METHOD crypto_method_ec_secp224<sup>15;</sup></span><span class="sxs-lookup"><span data-stu-id="75655-969">NX_CRYPTO_METHOD crypto_method_ec_secp224<sup>15</sup>;</span></span>  
- <span data-ttu-id="75655-970">NX_CRYPTO_METHOD crypto_method_ec_secp256;</span><span class="sxs-lookup"><span data-stu-id="75655-970">NX_CRYPTO_METHOD crypto_method_ec_secp256;</span></span>  
- <span data-ttu-id="75655-971">NX_CRYPTO_METHOD crypto_method_ec_secp384;</span><span class="sxs-lookup"><span data-stu-id="75655-971">NX_CRYPTO_METHOD crypto_method_ec_secp384;</span></span>  
- <span data-ttu-id="75655-972">NX_CRYPTO_METHOD crypto_method_ec_secp521;</span><span class="sxs-lookup"><span data-stu-id="75655-972">NX_CRYPTO_METHOD crypto_method_ec_secp521;</span></span>

<span data-ttu-id="75655-973">Os métodos cripto para curvas ECC são definidos em nx_crypto_generic_ciphersuites.c.</span><span class="sxs-lookup"><span data-stu-id="75655-973">The crypto methods for ECC curves are defined in nx_crypto_generic_ciphersuites.c.</span></span>

<span data-ttu-id="75655-974">Método cripto para ECDHE:</span><span class="sxs-lookup"><span data-stu-id="75655-974">Crypto method for ECDHE:</span></span>

- <span data-ttu-id="75655-975">NX_CRYPTO_METHOD crypto_method_ecdhe;</span><span class="sxs-lookup"><span data-stu-id="75655-975">NX_CRYPTO_METHOD crypto_method_ecdhe;</span></span>

<span data-ttu-id="75655-976">Método cripto para ECDSA:</span><span class="sxs-lookup"><span data-stu-id="75655-976">Crypto method for ECDSA:</span></span>

- <span data-ttu-id="75655-977">NX_CRYPTO_METHOD crypto_method_ecdsa;</span><span class="sxs-lookup"><span data-stu-id="75655-977">NX_CRYPTO_METHOD crypto_method_ecdsa;</span></span>

<span data-ttu-id="75655-978">Os métodos cripto ECDSA e ECDHE são definidos em nx_crypto_generic_ciphersuites.c.</span><span class="sxs-lookup"><span data-stu-id="75655-978">ECDSA and ECDHE crypto methods are defined in nx_crypto_generic_ciphersuites.c.</span></span>

<span data-ttu-id="75655-979">Combinados com outros métodos cripto como RSA, SHA, AES, podem ser usados como blocos de construção para a mesa de procuração cifrasuite.</span><span class="sxs-lookup"><span data-stu-id="75655-979">Combined with other crypto methods such as RSA, SHA, AES, they can be used as building blocks for the ciphersuite lookup table.</span></span>

### <a name="enabling-ecc-support-for-tls"></a><span data-ttu-id="75655-980">Habilitar o suporte do ECC para o TLS</span><span class="sxs-lookup"><span data-stu-id="75655-980">Enabling ECC Support for TLS</span></span>

<span data-ttu-id="75655-981">O ECC é ativado por padrão para TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-981">ECC is enabled by default for TLS.</span></span> <span data-ttu-id="75655-982">Para desativar o suporte do ECC, o símbolo NX_SECURE_DISABLE_ECC_CIPHERSUITE deve ser definido.</span><span class="sxs-lookup"><span data-stu-id="75655-982">To disable ECC support, the symbol NX_SECURE_DISABLE_ECC_CIPHERSUITE must be defined.</span></span>

<span data-ttu-id="75655-983">Para que a alteração produza efeitos, terá de reconstruir a Biblioteca NetX Secure e todas as aplicações que utilizem essa biblioteca.</span><span class="sxs-lookup"><span data-stu-id="75655-983">For the change to take effect, you will need to rebuild the NetX Secure Library and all applications that use that library.</span></span>

<span data-ttu-id="75655-984">No código de aplicação, a API n *x_secure_tls_ecc_initialize()* deve ser chamada após a criação da sessão TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-984">In the application code, the API n *x_secure_tls_ecc_initialize()* must be called after the TLS session is created.</span></span> <span data-ttu-id="75655-985">Esta API notifica a sessão TLS do tipo de curvas a utilizar para operações de troca de chaves TLS e verificação de certificados.</span><span class="sxs-lookup"><span data-stu-id="75655-985">This API notifies the TLS session of the type of curves to be used for TLS key exchange operations and certificate verification.</span></span> <span data-ttu-id="75655-986">Durante a fase de aperto de mão TLS, se um algoritmo ECC for selecionado, o cliente e o servidor trocam parâmetros relacionados com a curva ECC para decidir qual a curva a utilizar.</span><span class="sxs-lookup"><span data-stu-id="75655-986">During the TLS handshake phase, if an ECC algorithm is selected the client and server exchange ECC curve-related parameters to decide which curve to use.</span></span>

<span data-ttu-id="75655-987">O seguinte segmento de código ilustra como utilizar a API.</span><span class="sxs-lookup"><span data-stu-id="75655-987">The following code segment illustrates how to use the API.</span></span> <span data-ttu-id="75655-988">Note que os argumentos *(nx_crypto_ecc_supported_groups, nx_crypto_ecc_supported_groups_size e nx_crypto_ecc_curves)* são todos definidos em *nx_crypto_generic_ciphersuites.c*.</span><span class="sxs-lookup"><span data-stu-id="75655-988">Note that the arguments (*nx_crypto_ecc_supported_groups, nx_crypto_ecc_supported_groups_size, and nx_crypto_ecc_curves)* are all defined in *nx_crypto_generic_ciphersuites.c*.</span></span> <span data-ttu-id="75655-989">Portanto, estes símbolos podem ser utilizados diretamente.</span><span class="sxs-lookup"><span data-stu-id="75655-989">Therefore these symbols can be used directly.</span></span>

```C
status = nx_secure_tls_ecc_initialize(&tls_session,     
                    nx_crypto_ecc_supported_groups,      
                    nx_crypto_ecc_supported_groups_size,     
                    nx_crypto_ecc_curves);
```
<span data-ttu-id="75655-990">A configuração do exemplo no nx_crypto_generic_ciphersuites.c contém uma tabela de procuração cifrasuita ECC que é usada quando o ECC está ativado.</span><span class="sxs-lookup"><span data-stu-id="75655-990">The example configuration in nx_crypto_generic_ciphersuites.c contains an ECC ciphersuite lookup table that is used when ECC is enabled.</span></span> <span data-ttu-id="75655-991">Para utilizar o ECC, basta passar nx_crypto_tls_ciphers_ecc como parâmetro de tabela cifrasuite ao criar sessões de TLS com nx_secure_tls_session_create.</span><span class="sxs-lookup"><span data-stu-id="75655-991">To use ECC, simply pass nx_crypto_tls_ciphers_ecc as the ciphersuite table parameter when creating TLS sessions with nx_secure_tls_session_create.</span></span> <span data-ttu-id="75655-992">A tabela de exemplos contém cifrasuites ECC e não-ECC.</span><span class="sxs-lookup"><span data-stu-id="75655-992">The example table contains both ECC and non-ECC ciphersuites.</span></span>

### <a name="tls-cryptographic-cipher-table"></a><span data-ttu-id="75655-993">TLS Tabela de Cifra Criptográfica</span><span class="sxs-lookup"><span data-stu-id="75655-993">TLS Cryptographic Cipher Table</span></span>

<span data-ttu-id="75655-994">A estrutura NX_SECURE_TLS_CRYPTO é definida como:</span><span class="sxs-lookup"><span data-stu-id="75655-994">The NX_SECURE_TLS_CRYPTO structure is defined as:</span></span>

```C
typedef struct NX_SECURE_METHODS_STRUCT
{
    /* Table that maps ciphersuites to crypto methods. */
    NX_SECURE_TLS_CIPHERSUITE_INFO* nx_secure_tls_ciphersuite_lookup_table;
    USHORT nx_secure_tls_ciphersuite_lookup_table_size;

    /* Table that maps X.509 cipher identifiers to crypto methods. */
    NX_SECURE_X509_CRYPTO *nx_secure_tls_x509_cipher_table;
    USHORT nx_secure_tls_x509_cipher_table_size;

    /* Specific routines needed for specific TLS versions. */
#if (NX_SECURE_TLS_TLS_1_0_ENABLED || NX_SECURE_TLS_TLS_1_1_ENABLED)
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_md5_method;
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_sha1_method;
    NX_CRYPTO_METHOD *nx_secure_tls_prf_1_method;
#endif

#if (NX_SECURE_TLS_TLS_1_2_ENABLED)
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_sha256_method;
    NX_CRYPTO_METHOD *nx_secure_tls_prf_sha256_method;
#endif

#if (NX_SECURE_TLS_TLS_1_3_ENABLED)
    const NX_CRYPTO_METHOD *nx_secure_tls_hkdf_method;
    const NX_CRYPTO_METHOD *nx_secure_tls_hmac_method;
    const NX_CRYPTO_METHOD *nx_secure_tls_ecdhe_method;
#endif

} NX_SECURE_TLS_CRYPTO;
```
<span data-ttu-id="75655-995">A tabela é criada preenchendo as entradas para esta estrutura numa constante estática localizada dentro do projeto NetX Secure TLS, normalmente localizado com as rotinas criptográficas e módulos.</span><span class="sxs-lookup"><span data-stu-id="75655-995">The table is created by filling in the entries for this structure in a static constant located within the NetX Secure TLS project, usually located with the cryptographic routines and modules.</span></span>

<span data-ttu-id="75655-996">Como exemplo, a biblioteca criptográfica apenas de software ("genérico") fornecida com NetX Secure contém a seguinte definição de tabela (para suporte cifrasuita não-ECC<sup>19</sup>):</span><span class="sxs-lookup"><span data-stu-id="75655-996">As an example, the software-only ("generic") cryptographic library provided with NetX Secure contains the following table definition (for non-ECC ciphersuite support<sup>19</sup>):</span></span>

```C
/* Define the cipher table object we can pass into TLS. */
const NX_SECURE_TLS_CRYPTO nx_crypto_tls_ciphers =
{
    /* TLS Ciphersuite lookup table and size. */
    _nx_crypto_ciphersuite_lookup_table,
    sizeof(_nx_crypto_ciphersuite_lookup_table) / 
    sizeof(NX_SECURE_TLS_CIPHERSUITE_INFO),

    /* X.509 certificate cipher table and size. */
    _nx_crypto_x509_cipher_lookup_table,
    sizeof(_nx_crypto_x509_cipher_lookup_table) / sizeof(NX_SECURE_X509_CRYPTO),

    /* TLS version-specific methods. */
#if (NX_SECURE_TLS_TLS_1_0_ENABLED || NX_SECURE_TLS_TLS_1_1_ENABLED)
    &crypto_method_md5,
    &crypto_method_sha1,
    &crypto_method_tls_prf_1,
#endif

#if (NX_SECURE_TLS_TLS_1_2_ENABLED)
    &crypto_method_sha256,
    &crypto_method_tls_prf_sha_256
#endif

#if (NX_SECURE_TLS_TLS_1_3_ENABLED)
    &crypto_method_hkdf,
    &crypto_method_hmac,
    &crypto_method_ecdhe,
#endif
};
```
<span data-ttu-id="75655-997">Na estrutura, a primeira entrada é a tabela cifrasumita TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-997">In the structure, the first entry is the TLS ciphersuite table.</span></span> <span data-ttu-id="75655-998">A estrutura NX_SECURE_TLS_CIPHERSUITE_INFO mapeia rotinas criptográficas (sob a forma de ponteiros de NX_CRYPTO_METHOD) a cifrasuites específicos, tal como definidos nas especificações do TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-998">The NX_SECURE_TLS_CIPHERSUITE_INFO structure maps cryptographic routines (in the form of NX_CRYPTO_METHOD pointers) to specific ciphersuites as defined in the TLS specifications.</span></span> <span data-ttu-id="75655-999">O segundo valor é o número de entradas na tabela apontadas para o primeiro campo.</span><span class="sxs-lookup"><span data-stu-id="75655-999">The second value is the number of entries in the table pointed to by the first field.</span></span>

<span data-ttu-id="75655-1000">O campo seguinte aponta para uma tabela de rotinas usadas por X.509 ao processar certificados digitais e a estrutura NX_SECURE_X509_CRYPTO é semelhante em forma a NX_SECURE_TLS_CIPHERSUITE_INFO.</span><span class="sxs-lookup"><span data-stu-id="75655-1000">The next field points to a table of routines used by X.509 when processing digital certificates and the structure NX_SECURE_X509_CRYPTO is similar in form to NX_SECURE_TLS_CIPHERSUITE_INFO.</span></span> <span data-ttu-id="75655-1001">O seguinte campo é o número de entradas na tabela.</span><span class="sxs-lookup"><span data-stu-id="75655-1001">The following field is the number of entries in the table.</span></span>

<span data-ttu-id="75655-1002">Após a tabela de procura são várias rotinas necessárias para versões específicas de TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-1002">Following the lookup table are a number of routines needed for specific versions of TLS.</span></span> <span data-ttu-id="75655-1003">Por exemplo, antes da versão 1.2 do TLS, as rotinas de geração chave e de hashing do aperto de mão foram fixadas para utilizar uma combinação de SHA-1 e MD5 – os métodos para estas rotinas são chamados especificamente na estrutura da cifra, uma vez que não estão ligados a cifrasuites específicas.</span><span class="sxs-lookup"><span data-stu-id="75655-1003">For example, prior to TLS version 1.2, the key generation and handshake hashing routines were fixed to use a combination of SHA-1 and MD5 – the methods for these routines are called out specifically in the cipher structure since they are not tied to specific ciphersuites.</span></span> <span data-ttu-id="75655-1004">Na versão TLS 1.2, as rotinas de geração chave e hashing são escolhidas pela cifrasuite, mas para cifrasuites que não especificam as rotinas a utilizar, o método de haxixe SHA-256 é usado, e a estrutura da cifra chama essa rotina especificamente.</span><span class="sxs-lookup"><span data-stu-id="75655-1004">In TLS version 1.2, the key generation and hashing routines are chosen by the ciphersuite, but for ciphersuites which do not specify the routines to use, the SHA-256 hash method is used, and the cipher structure calls out that routine specifically.</span></span>

<span data-ttu-id="75655-1005">TLS 1.3 requer algumas cifras específicas extra para várias operações.</span><span class="sxs-lookup"><span data-stu-id="75655-1005">TLS 1.3 requires a few extra specific ciphers for various operations.</span></span>

19. <span data-ttu-id="75655-1006">Note que o suporte TLS 1.3 requer ECC – utilize nx_crypto_tls_ciphers_ecc se o TLS 1.3 estiver ativado.</span><span class="sxs-lookup"><span data-stu-id="75655-1006">Note that TLS 1.3 support requires ECC – use nx_crypto_tls_ciphers_ecc if TLS 1.3 is enabled.</span></span>

### <a name="tls-ciphersuite-lookup-table"></a><span data-ttu-id="75655-1007">Tabela de olhar cifrasumita TLS</span><span class="sxs-lookup"><span data-stu-id="75655-1007">TLS Ciphersuite Lookup Table</span></span>

<span data-ttu-id="75655-1008">Para preencher a tabela de cifras para TLS, também terá de criar uma tabela de procuração cifrasuita que mapeia rotinas criptográficas para identificadores de cifrasuite específicos.</span><span class="sxs-lookup"><span data-stu-id="75655-1008">To fill in the cipher table for TLS, you will also need to create a ciphersuite lookup table that maps cryptographic routines to specific ciphersuite identifiers.</span></span> <span data-ttu-id="75655-1009">Os identificadores são valores registados em IANA que são universais.</span><span class="sxs-lookup"><span data-stu-id="75655-1009">The identifiers are IANA-registered values that are universal.</span></span> <span data-ttu-id="75655-1010">Consulte os RFCs TLS para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="75655-1010">See the TLS RFCs for more information.</span></span> <span data-ttu-id="75655-1011">As rotinas representam os 5 métodos separados utilizados em cada cifrasuite (alguns cifrasuites não podem utilizar todos os 5): cifra pública, autenticação de chave pública, cifra de sessão, rotina de haxixe de sessão e Função de Pseudo-Random TLS (PRF).</span><span class="sxs-lookup"><span data-stu-id="75655-1011">The routines represent the 5 separate methods used in each ciphersuite (some ciphersuites may not use all 5): public cipher, public-key authentication, session cipher, session hash routine, and TLS Pseudo-Random Function (PRF).</span></span> <span data-ttu-id="75655-1012">A tabela a seguir explica cada um dos 5 métodos:</span><span class="sxs-lookup"><span data-stu-id="75655-1012">The following table explains each of the 5 methods:</span></span>

| <span data-ttu-id="75655-1013">**Categoria de rotina**</span><span class="sxs-lookup"><span data-stu-id="75655-1013">**Routine category**</span></span>      | <span data-ttu-id="75655-1014">**Descrição**</span><span class="sxs-lookup"><span data-stu-id="75655-1014">**Description**</span></span>                                                                                       | <span data-ttu-id="75655-1015">**Algoritmos de exemplo**</span><span class="sxs-lookup"><span data-stu-id="75655-1015">**Example algorithms**</span></span>                                            |
| ------------------------- | ----------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------- |
| <span data-ttu-id="75655-1016">Cifra pública</span><span class="sxs-lookup"><span data-stu-id="75655-1016">Public cipher</span></span>             | <span data-ttu-id="75655-1017">Usado para trocar chaves durante o aperto de mão TLS</span><span class="sxs-lookup"><span data-stu-id="75655-1017">Used to exchange keys during the TLS handshake</span></span>                                                        | <span data-ttu-id="75655-1018">RSA, Diffie-Hellman, ECC</span><span class="sxs-lookup"><span data-stu-id="75655-1018">RSA, Diffie-Hellman, ECC</span></span>                                          |
| <span data-ttu-id="75655-1019">Autenticação de chaves públicas</span><span class="sxs-lookup"><span data-stu-id="75655-1019">Public-key authentication</span></span> | <span data-ttu-id="75655-1020">Usado para autenticar ou assinar dados durante o aperto de mão TLS</span><span class="sxs-lookup"><span data-stu-id="75655-1020">Used to authenticate or sign data during the TLS handshake</span></span>                                            | <span data-ttu-id="75655-1021">RSA, DSS</span><span class="sxs-lookup"><span data-stu-id="75655-1021">RSA, DSS</span></span>                                                          |
| <span data-ttu-id="75655-1022">Cifra de sessão</span><span class="sxs-lookup"><span data-stu-id="75655-1022">Session cipher</span></span>            | <span data-ttu-id="75655-1023">Algoritmo de chave simétrica usado para encriptar dados de aplicações durante a sessão TLS</span><span class="sxs-lookup"><span data-stu-id="75655-1023">Symmetric-key algorithm used to encrypt application data during the TLS session</span></span>                       | <span data-ttu-id="75655-1024">AES</span><span class="sxs-lookup"><span data-stu-id="75655-1024">AES, RC4</span></span>                                                          |
| <span data-ttu-id="75655-1025">Haxixe de sessão</span><span class="sxs-lookup"><span data-stu-id="75655-1025">Session hash</span></span>              | <span data-ttu-id="75655-1026">Utilizado para preservar a integridade das mensagens durante a sessão TLS (garante que os dados não mudaram)</span><span class="sxs-lookup"><span data-stu-id="75655-1026">Used to preserve the integrity of messages during the TLS session (assures that data has not changed)</span></span> | <span data-ttu-id="75655-1027">SHA-1, SHA-256</span><span class="sxs-lookup"><span data-stu-id="75655-1027">SHA-1, SHA-256</span></span>                                                    |
| <span data-ttu-id="75655-1028">TLS PRF</span><span class="sxs-lookup"><span data-stu-id="75655-1028">TLS PRF</span></span>                   | <span data-ttu-id="75655-1029">Usado para gerar material chave e no haxixe de aperto de mão no aperto de mão TLS</span><span class="sxs-lookup"><span data-stu-id="75655-1029">Used to generate key material and in the handshake hash in the TLS handshake</span></span>                          | <span data-ttu-id="75655-1030">O PRF baseia-se em rotinas de haxixe - SHA-1 + MD5, SHA-256, SHA-512</span><span class="sxs-lookup"><span data-stu-id="75655-1030">The PRF is based on hash routines – SHA-1 + MD5, SHA-256, SHA-512</span></span> |

<span data-ttu-id="75655-1031">A estrutura NX_SECURE_TLS_CIPHERSUITE_INFO é definida da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="75655-1031">The NX_SECURE_TLS_CIPHERSUITE_INFO structure is defined as follows:</span></span>

```C
typedef struct NX_SECURE_TLS_CIPHERSUITE_INFO_struct
{
    /* The IANA value of the ciphersuite as defined by the TLS spec.*/
    USHORT nx_secure_tls_ciphersuite;

    /* The Public Key operation in this suite - RSA or DH. */
    NX_CRYPTO_METHOD *nx_secure_tls_public_cipher;

    /* The Public Authentication method used for signing data. */
    NX_CRYPTO_METHOD *nx_secure_tls_public_auth;

    /* The session cipher being used - AES, RC4, etc. */
    NX_CRYPTO_METHOD *nx_secure_tls_session_cipher;

    /* The size of the initialization vectors for the session cipher (bytes).*/
    USHORT nx_secure_tls_iv_size;

    /* The key size for the session cipher (bytes). */
    UCHAR nx_secure_tls_session_key_size;

    /* The hash being used - MD5, SHA-1, SHA-256, etc. */
    NX_CRYPTO_METHOD *nx_secure_tls_hash;

    /* The size of the hash being used. SHA-1 is 20 bytes, MD5 is 16 bytes.*/
    USHORT nx_secure_tls_hash_size;

    /* The TLS PRF being used – this is only for TLSv1.2. */
    NX_CRYPTO_METHOD *nx_secure_tls_prf;

} NX_SECURE_TLS_CIPHERSUITE_INFO;
```
<span data-ttu-id="75655-1032">O campo nx_secure_tls_ciphersuite contém o valor cifrasuita IANA, e os ponteiros NX_CRYPTO_METHOD representam os 5 métodos utilizados por essa cifrasuite.</span><span class="sxs-lookup"><span data-stu-id="75655-1032">The nx_secure_tls_ciphersuite field contains the IANA ciphersuite value, and the NX_CRYPTO_METHOD pointers represent the 5 methods used by that ciphersuite.</span></span> <span data-ttu-id="75655-1033">Os valores de escala (nx_secure_tls_iv_size, nx_secure_tls_key_size e nx_secure_tls_hash_size) são informativos, fornecendo informações que podem não estar disponíveis nas entradas NX_CRYPTO_METHOD.</span><span class="sxs-lookup"><span data-stu-id="75655-1033">The scalar values (nx_secure_tls_iv_size, nx_secure_tls_key_size, and nx_secure_tls_hash_size) are informational, providing information that might not be available in the NX_CRYPTO_METHOD entries.</span></span>

<span data-ttu-id="75655-1034">Como exemplo, vamos analisar a cifrasumita padrão para TLS, TLS_RSA_WITH_AES_128_CBC_SHA, que especifica a utilização de RSA, AES-CBC com teclas de 128 bits e SHA-1 para hashing de sessão.</span><span class="sxs-lookup"><span data-stu-id="75655-1034">As an example, we will look at the default ciphersuite for TLS, TLS_RSA_WITH_AES_128_CBC_SHA, which specifies the use of RSA, AES-CBC with 128-bit keys, and SHA-1 for session hashing.</span></span> <span data-ttu-id="75655-1035">Não é especificado nenhum PRF TLS para esta cifrasuite, pelo que no modo TLSv1.2, utilizará o PRF SHA-256 predefinido.</span><span class="sxs-lookup"><span data-stu-id="75655-1035">No TLS PRF is specified for this ciphersuite, so in TLSv1.2 mode, it will use the default SHA-256 PRF.</span></span> <span data-ttu-id="75655-1036">Note que todos os cifrasuites utilizam o PRF SHA-1+MD5 em TLS 1.0 e 1.1, independentemente do PRF especificado na tabela.</span><span class="sxs-lookup"><span data-stu-id="75655-1036">Note that all ciphersuites use the SHA-1+MD5 PRF in TLS 1.0 and 1.1, regardless of the PRF specified in the table.</span></span>

<span data-ttu-id="75655-1037">A entrada na tabela NX_SECURE_TLS_CIPHERSUITE_INFO na biblioteca criptográfica genérica é definida da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="75655-1037">The entry in the NX_SECURE_TLS_CIPHERSUITE_INFO table in the generic cryptographic library is defined as follows:</span></span>

```C
{ 
  TLS_RSA_WITH_AES_128_CBC_SHA,     /* Ciphersuite identifier */
  &crypto_method_rsa,               /* Public-key cipher (NX_CRYPTO_METHOD)*/
  &crypto_method_rsa,               /* Authentication method(NX_CRYPTO_METHOD)*/
  &crypto_method_aes_cbc_128,       /* Session cipher method(NX_CRYPTO_METHOD)*/
  16,                               /* Session cipher IV size in bytes */
  16,                               /* Session cipher key size in bytes */
  &crypto_method_hmac_sha1,         /* Session hash routine(NX_CRYPTO_METHOD) */
  20,                               /* Session hash output size in bytes */
  &crypto_method_tls_prf_sha_256    /* TLSv1.2 PRF */
},
```

<span data-ttu-id="75655-1038">Note que para a cifra da sessão o tamanho da chave é determinado pela cifrasuite, mas para os métodos de chave pública o tamanho da chave não é conhecido até que o aperto de mão TLS esteja em andamento uma vez que as chaves públicas estão contidas nos certificados digitais trocados durante o aperto de mão.</span><span class="sxs-lookup"><span data-stu-id="75655-1038">Note that for the session cipher the key size is determined by the ciphersuite, but for the public-key methods the key size is not known until the TLS handshake is underway since the public keys are contained in the digital certificates exchanged during the handshake.</span></span>

### <a name="x509-cipher-lookup-table"></a><span data-ttu-id="75655-1039">X.509 Cipher Lookup Table</span><span class="sxs-lookup"><span data-stu-id="75655-1039">X.509 Cipher Lookup Table</span></span>

<span data-ttu-id="75655-1040">Tal como a tabela NX_SECURE_TLS_CIPHERSUITE_INFO, a estrutura NX_SECURE_X509_CRYPTO mapeia rotinas criptográficas a valores conhecidos.</span><span class="sxs-lookup"><span data-stu-id="75655-1040">Like the NX_SECURE_TLS_CIPHERSUITE_INFO table, the NX_SECURE_X509_CRYPTO structure maps cryptographic routines to known values.</span></span> <span data-ttu-id="75655-1041">No caso de X.509, os identificadores são na verdade OIDs definidos por X.509 e registados nos organismos de normas ISO e UTA.</span><span class="sxs-lookup"><span data-stu-id="75655-1041">In the case of X.509, the identifiers are actually OIDs defined by X.509 and registered with the ISO and ITU standards bodies.</span></span> <span data-ttu-id="75655-1042">Os OIDs são valores de vários bytes de comprimento variável projetados para identificar de forma única várias informações em várias normas de telecomunicações, incluindo rotinas criptográficas usadas em certificados digitais.</span><span class="sxs-lookup"><span data-stu-id="75655-1042">OIDs are variable-length multi-byte values designed to uniquely identify various information in various telecommunication standards, including cryptographic routines used in digital certificates.</span></span> <span data-ttu-id="75655-1043">Devido ao facto de os OIDs serem de comprimento variável, o NetX Secure TLS mapeia os valores oficiais de OID para constantes de comprimento fixo que são utilizados internamente (ver nx_secure_x509.h).</span><span class="sxs-lookup"><span data-stu-id="75655-1043">Due to the fact that OIDs are variable length, NetX Secure TLS maps the official OID values to fixed-length constants that are used internally (see nx_secure_x509.h).</span></span> <span data-ttu-id="75655-1044">Estas constantes são utilizadas na estrutura NX_SECURE_X509_CRYPTO, que é definida da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="75655-1044">These constants are used in the NX_SECURE_X509_CRYPTO structure, which is defined as follows:</span></span>

```C
/* Structure to hold X.509 cryptographic routine information. */
typedef struct NX_SECURE_X509_CRYPTO_struct
{
    /* Internal NetX Secure identifier for certificate "ciphersuite" which consists
       of a hash and a public key operation. These can be mapped to OIDs in X.509.
        */
    USHORT nx_secure_x509_crypto_identifier;

    /* Public-Key Cryptographic method used by certificates. */
    NX_CRYPTO_METHOD *nx_secure_x509_public_cipher_method;

    /* Hash method used by certificates. */
    NX_CRYPTO_METHOD *nx_secure_x509_hash_method;
} NX_SECURE_X509_CRYPTO;
```

<span data-ttu-id="75655-1045">O primeiro campo, *nx_secure_x509_crypto_identifier,* é a representação OID interna utilizada pelo NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="75655-1045">The first field, *nx_secure_x509_crypto_identifier*, is the internal OID representation used by NetX Secure.</span></span>

<span data-ttu-id="75655-1046">O segundo e terceiro campos apontam para NX_CRYPTO_METHOD objetos que representam os métodos criptográficos identificados pelo OID, uma operação de chave pública emparelhada com uma rotina de haxixe.</span><span class="sxs-lookup"><span data-stu-id="75655-1046">The second and third fields point to NX_CRYPTO_METHOD objects that represent the cryptographic methods identified by the OID, a public-key operation paired with a hash routine.</span></span> <span data-ttu-id="75655-1047">Note que cada certificado digital pode ter mais de um OID para rotinas criptográficas.</span><span class="sxs-lookup"><span data-stu-id="75655-1047">Note that each digital certificate may have more than one OID for cryptographic routines.</span></span>

<span data-ttu-id="75655-1048">A tabela de métodos para X.509 é construída da mesma forma que a tabela de procuração cifrasuita.</span><span class="sxs-lookup"><span data-stu-id="75655-1048">The method table for X.509 is constructed in the same manner as the ciphersuite lookup table.</span></span> <span data-ttu-id="75655-1049">Como exemplo, vamos olhar para o OID para RSA_SHA1.</span><span class="sxs-lookup"><span data-stu-id="75655-1049">As an example, we will look at the OID for RSA_SHA1.</span></span> <span data-ttu-id="75655-1050">O OID real para RSA_SHA1 é o seguinte:</span><span class="sxs-lookup"><span data-stu-id="75655-1050">The actual OID for RSA_SHA1 is as follows:</span></span>

```C
{iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-1(1) sha1-with-rsa-
signature(5)}
```
<span data-ttu-id="75655-1051">O OID está representado na sintaxe ASN.1 e tem um valor numérico de 1.2.840.113549.1.1.5.</span><span class="sxs-lookup"><span data-stu-id="75655-1051">The OID is represented in ASN.1 syntax and has a numeric value of 1.2.840.113549.1.1.5.</span></span> <span data-ttu-id="75655-1052">Este valor é então codificado em formato binário, criando os seguintes bytes:</span><span class="sxs-lookup"><span data-stu-id="75655-1052">This value is then encoded in binary format, creating the following bytes:</span></span>

```C
UCHAR RSA_SHA1_OID = { 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05 };
```
<span data-ttu-id="75655-1053">A conversão real de ASN.1 para o formato binário está fora do âmbito deste documento.</span><span class="sxs-lookup"><span data-stu-id="75655-1053">The actual conversion from ASN.1 to the binary format is beyond the scope of this document.</span></span> <span data-ttu-id="75655-1054">Procure codificações ASN.1 para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="75655-1054">Search for ASN.1 encodings for OIDs for more information.</span></span> <span data-ttu-id="75655-1055">A representação binária dos OIDs suportados pelo NetX Secure pode ser encontrada no ficheiro *nx_secure_x509.c*.</span><span class="sxs-lookup"><span data-stu-id="75655-1055">The binary representation of the OIDs supported by NetX Secure can be found in the file *nx_secure_x509.c*.</span></span>

<span data-ttu-id="75655-1056">Uma vez que temos um mapeamento do OID real para uma constante reconhecida internamente, podemos criar uma entrada para RSA_SHA1 na tabela NX_SECURE_X509_CRYPTO:</span><span class="sxs-lookup"><span data-stu-id="75655-1056">Once we have a mapping of the actual OID to an internally-recognized constant, we can create an entry for RSA_SHA1 in the NX_SECURE_X509_CRYPTO table:</span></span>

```C
{ 
    NX_SECURE_TLS_X509_TYPE_RSA_SHA_1,    /* Internal OID constant. */
    &crypto_method_rsa,                   /* RSA method (NX_CRYPTO_METHOD). */ 
    &crypto_method_sha1                   /* SHA-1 method (NX_CRYPTO_METHOD). */
}, 
```
### <a name="default-tls-routines"></a><span data-ttu-id="75655-1057">Rotinas TLS padrão</span><span class="sxs-lookup"><span data-stu-id="75655-1057">Default TLS Routines</span></span>

<span data-ttu-id="75655-1058">Como mencionado acima, o TLS requer algumas rotinas padrão para a geração de chaves e verificação de mensagens durante o aperto de mão.</span><span class="sxs-lookup"><span data-stu-id="75655-1058">As mentioned above, TLS requires some default routines for key generation and message verification during the handshake.</span></span> <span data-ttu-id="75655-1059">A rotina principal é a Função Pseudo-Random TLS, ou PRF.</span><span class="sxs-lookup"><span data-stu-id="75655-1059">The primary routine is the TLS Pseudo-Random Function, or PRF.</span></span> <span data-ttu-id="75655-1060">O PRF baseia-se em rotinas de haxixe e pode ser usado para gerar uma quantidade arbitrária de dados pseudoaleatórios<sup>20</sup> para geração chave ou outros fins.</span><span class="sxs-lookup"><span data-stu-id="75655-1060">The PRF is based on hash routines and can be used to generate an arbitrary amount of pseudo-random data<sup>20</sup> for key generation or other purposes.</span></span>

<span data-ttu-id="75655-1061">Além do PRF, cada versão do TLS utiliza rotinas de haxixe padrão que também precisam de ser fornecidas.</span><span class="sxs-lookup"><span data-stu-id="75655-1061">In addition to the PRF, each version of TLS utilizes default hash routines that also need to be provided.</span></span> <span data-ttu-id="75655-1062">Para as versões TLS 1.0 e 1.1, essas rotinas de haxixe são MD5 e SHA-1.</span><span class="sxs-lookup"><span data-stu-id="75655-1062">For TLS versions 1.0 and 1.1, those hash routines are MD5 and SHA-1.</span></span> <span data-ttu-id="75655-1063">A versão 1.2 do TLS requer apenas SHA-256.</span><span class="sxs-lookup"><span data-stu-id="75655-1063">TLS version 1.2 requires only SHA-256.</span></span>

<span data-ttu-id="75655-1064">Na estrutura NX_SECURE_TLS_CRYPTO, existem NX_CRYPTO_METHOD ponteiros para MD5, SHA-1, SHA-256, a versão TLS 1.0/1.1 PRF e o TLS padrão TLS 1.2 PRF.</span><span class="sxs-lookup"><span data-stu-id="75655-1064">In the NX_SECURE_TLS_CRYPTO structure, there are NX_CRYPTO_METHOD pointers for MD5, SHA-1, SHA-256, the TLS version 1.0/1.1 PRF, and the default TLS 1.2 PRF.</span></span>

<span data-ttu-id="75655-1065">O suporte TLS 1.3 adiciona campos para HKDF (geração-chave), HMAC (para operações específicas de hashing utilizadas durante o aperto de mão) e ECDHE (necessário para a funcionalidade TLS 1.3).</span><span class="sxs-lookup"><span data-stu-id="75655-1065">TLS 1.3 support adds fields for HKDF (key generation), HMAC (for specific hashing operations used during the handshake) and ECDHE (required for TLS 1.3 functionality).</span></span>

<span data-ttu-id="75655-1066">Fornecidas na biblioteca de criptografia de software genérico estão versões de software do TLS PRF.</span><span class="sxs-lookup"><span data-stu-id="75655-1066">Provided in the generic software cryptography library are software versions of the TLS PRF.</span></span> <span data-ttu-id="75655-1067">Para TLS 1.0/1.1, esta função chama-se *nx_crypto_tls_prf_1*.</span><span class="sxs-lookup"><span data-stu-id="75655-1067">For TLS 1.0/1.1, this function is called *nx_crypto_tls_prf_1*.</span></span> <span data-ttu-id="75655-1068">Para TLS 1.2, a função chama-se *nx_secure_tls_prf_sha256*.</span><span class="sxs-lookup"><span data-stu-id="75655-1068">For TLS 1.2, the function is called *nx_secure_tls_prf_sha256*.</span></span> <span data-ttu-id="75655-1069">O sufixo "1" representa o legado TLS 1.0 PRF, e o sufixo "sha256" refere-se ao facto de o PRF padrão TLS 1.2 se basear em SHA-256.</span><span class="sxs-lookup"><span data-stu-id="75655-1069">The suffix "1" represents the legacy TLS 1.0 PRF, and the "sha256" suffix refers to the fact that the TLS 1.2 default PRF is based on SHA-256.</span></span> <span data-ttu-id="75655-1070">Quando o suporte para outras rotinas de PRF é necessário, o sufixo para essas rotinas refletirá o método do haxixe utilizado.</span><span class="sxs-lookup"><span data-stu-id="75655-1070">When support for other PRF routines is needed, the suffix for those routines will reflect the hash method used.</span></span> <span data-ttu-id="75655-1071">Uma vez que as rotinas prf são baseadas em métodos de haxixe, as rotinas de haxixe subjacentes podem ser aceleradas independentemente em diferentes plataformas-alvo.</span><span class="sxs-lookup"><span data-stu-id="75655-1071">Since the PRF routines are based on hash methods, the underlying hash routines may be hardware-accelerated independently on different target platforms.</span></span>

<span data-ttu-id="75655-1072">Além das tabelas de cifrasumita tLS e X.509, com as rotinas predefinidas de PRF e haxixe preenchidas na estrutura NX_SECURE_TLS_CRYPTO podem ser povoadas e usadas para inicializar uma sessão de TLS.</span><span class="sxs-lookup"><span data-stu-id="75655-1072">In addition to the TLS ciphersuite and X.509 lookup tables, with the default PRF and hash routines filled in the NX_SECURE_TLS_CRYPTO structure can be populated and used to initialize a TLS session.</span></span>

20. <span data-ttu-id="75655-1073">"Pseudoaleatório" refere-se ao facto de o PRF ser determinista, o que significa que produzirá sempre a mesma saída dada a mesma entrada, mas aleatória no facto de a saída não ser previsível.</span><span class="sxs-lookup"><span data-stu-id="75655-1073">“Pseudo-random” refers to the fact that the PRF is deterministic, meaning it will always produce the same output given the same input, but random in the fact that the output is not predictable.</span></span> <span data-ttu-id="75655-1074">TLS usa esta propriedade do PRF para gerar as chaves de sessão de vários dados públicos combinados com o segredo mestre trocado durante o aperto de mão usando uma cifra de chave pública como RSA.</span><span class="sxs-lookup"><span data-stu-id="75655-1074">TLS uses this property of the PRF to generate the session keys from various public data combined with the master secret exchanged during the handshake using a public-key cipher like RSA.</span></span>

### <a name="cryptographic-metadata"></a><span data-ttu-id="75655-1075">Metadados criptográficos</span><span class="sxs-lookup"><span data-stu-id="75655-1075">Cryptographic Metadata</span></span>

<span data-ttu-id="75655-1076">Antes de podermos rubricar a sessão TLS com a tabela NX_SECURE_TLS_CRYPTO, precisamos de alocar espaço tampão para os metadados de rotina criptográfico.</span><span class="sxs-lookup"><span data-stu-id="75655-1076">Before we can initialize the TLS session with the NX_SECURE_TLS_CRYPTO table, we need to allocate buffer space for the cryptographic routine metadata.</span></span> <span data-ttu-id="75655-1077">Os metadados são utilizados para armazenar todo o estado associado a uma determinada rotina, representada pelo seu bloco de controlo.</span><span class="sxs-lookup"><span data-stu-id="75655-1077">The metadata is used to store all the state associated with a particular routine, represented by its control block.</span></span> <span data-ttu-id="75655-1078">O campo *nx_crypto_metadata_area_size* de cada NX_CRYPTO_METHOD deve ser definido para o tamanho da estrutura de controlo associada a essa rotina ou a inicialização TLS não terá de prestar contas adequadas ao espaço necessário, possivelmente causando problemas de ultrapassagem do tampão.</span><span class="sxs-lookup"><span data-stu-id="75655-1078">The *nx_crypto_metadata_area_size* field of each NX_CRYPTO_METHOD must be set to the size of the control structure associated with that routine or the TLS initialization will fail to properly account for the space needed, possibly causing buffer overrun issues.</span></span>

<span data-ttu-id="75655-1079">Antes da sessão TLS ser criada, o tampão de metadados deve ser atribuído.</span><span class="sxs-lookup"><span data-stu-id="75655-1079">Before the TLS session is created, the metadata buffer must be allocated.</span></span> <span data-ttu-id="75655-1080">O tampão é automaticamente dividido por nx_secure_tls_session_create e o espaço é reservado para cada uma das rotinas que são fornecidas na tabela de métodos criptográficos.</span><span class="sxs-lookup"><span data-stu-id="75655-1080">The buffer is automatically divided up by nx_secure_tls_session_create and space is reserved for each of the routines that are provided in the cryptographic method table.</span></span> <span data-ttu-id="75655-1081">Note que uma vez que apenas uma cifrasuite está ativa de cada vez numa sessão de TLS, o número de cifrasuites suportados não afeta o espaço de metadados necessário – o espaço é reservado para cada uma das 5 rotinas cifrasuitas utilizando o tamanho máximo do bloco de controlo para essa categoria na tabela de procuração de cifrasuitas.</span><span class="sxs-lookup"><span data-stu-id="75655-1081">Note that since only one ciphersuite is active at a time in a TLS session, the number of supported ciphersuites does not affect the needed metadata space – space is reserved for each of the 5 ciphersuite routines using the maximum control block size for that category in the ciphersuite lookup table.</span></span>

<span data-ttu-id="75655-1082">De forma a facilitar o cálculo do tamanho do tampão de metadados, o serviço *nx_secure_metadata_size_calculate* executa os mesmos cálculos que nx_secure_tls_session_create mas simplesmente devolve o tamanho total do tampão de metadados necessário em bytes.</span><span class="sxs-lookup"><span data-stu-id="75655-1082">In order to make calculating the metadata buffer size easy, the service *nx_secure_metadata_size_calculate* performs the same calculations as nx_secure_tls_session_create but simply returns the total required metadata buffer size in bytes.</span></span>

### <a name="initializing-the-tls-session"></a><span data-ttu-id="75655-1083">Inicialização da sessão TLS</span><span class="sxs-lookup"><span data-stu-id="75655-1083">Initializing the TLS session</span></span>

<span data-ttu-id="75655-1084">Uma vez criados os objetos NX_CRYPTO_METHOD e NX_SECURE_TLS_CRYPTO e reservados os metadados, podemos rubricar uma sessão de TLS da seguinte forma (valores retirados dos exemplos acima):</span><span class="sxs-lookup"><span data-stu-id="75655-1084">Once the NX_CRYPTO_METHOD and NX_SECURE_TLS_CRYPTO objects are created and the metadata area reserved, we can initialize a TLS session as follows (values taken from the above examples):</span></span>

```C
/* Pointer to the platform-specific cipher table. */
extern nx_crypto_tls_ciphers;

/* Cryptographic routine metadata buffer. Size is determined by calling 
nx_secure_tls_metadata_size_calculate with the nx_crypto_tls_ciphers table referenced 
above. */
UCHAR crypto_metadata[4500];

/* Initialize our TLS session using our cipher table and metadata area. Note that we can 
use sizeof for the metadata array because the size parameter expects the size in bytes.*/

nx_secure_tls_session_create(
    &tls_session,            /* Pointer to TLS session.      */
    &nx_crypto_tls_ciphers,  /* Pointer to cipher table.     */
    crypto_metadata,         /* Cryptography metadata buffer.*/
    sizeof(crypto_metadata), /* Size of metadata buffer.     */
);
```
