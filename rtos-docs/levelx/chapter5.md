---
title: Capítulo 5 - Suporte Azure RTOS LevelX NOR
description: Nor flash memory é composto por blocos que são tipicamente divisíveis por 512 bytes. O Azure RTOS LevelX divide cada bloco de flash NOR em sectores lógicos de 512 byte.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 3a0c73c2b45c32bf3f1ef56de684fa83c334b59e
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: MT
ms.contentlocale: pt-PT
ms.lasthandoff: 03/22/2021
ms.locfileid: "104826258"
---
# <a name="chapter-5---azure-rtos-levelx-nor-support"></a><span data-ttu-id="16b77-104">Capítulo 5 - Suporte Azure RTOS LevelX NOR</span><span class="sxs-lookup"><span data-stu-id="16b77-104">Chapter 5 - Azure RTOS LevelX NOR support</span></span>

<span data-ttu-id="16b77-105">Nor flash memory é composto por *blocos* que são tipicamente divisíveis por 512 bytes.</span><span class="sxs-lookup"><span data-stu-id="16b77-105">NOR flash memory is composed of *blocks* that are typically evenly divisible by 512 bytes.</span></span> <span data-ttu-id="16b77-106">Não existem conceito de uma *página* flash na memória flash NOR.</span><span class="sxs-lookup"><span data-stu-id="16b77-106">There are no concept of a flash *page* in NOR flash memory.</span></span> <span data-ttu-id="16b77-107">Além disso, não existem bytes *sobressalentes* na memória flash NOR, pelo que o Azure RTOS LevelX deve utilizar a própria memória flash NOR para todas as informações de gestão.</span><span class="sxs-lookup"><span data-stu-id="16b77-107">Also, there are no *spare* bytes in NOR flash memory, hence Azure RTOS LevelX must use the NOR flash memory itself for all management information.</span></span> <span data-ttu-id="16b77-108">O acesso direto à leitura é possível na memória flash NOR.</span><span class="sxs-lookup"><span data-stu-id="16b77-108">Direct read access is possible in NOR flash memory.</span></span> <span data-ttu-id="16b77-109">O acesso de escrita requer normalmente uma sequência especial de operações.</span><span class="sxs-lookup"><span data-stu-id="16b77-109">Write access typically requires a special sequence of operations.</span></span> <span data-ttu-id="16b77-110">Nem a memória flash pode ser escrita várias vezes, desde que os bits estejam a ser limpos.</span><span class="sxs-lookup"><span data-stu-id="16b77-110">NOR flash memory may be written to multiple times, providing that bits are being cleared.</span></span> <span data-ttu-id="16b77-111">Os bits na memória flash NOR só podem ser definidos uma vez, através da operação do bloco de apagamento.</span><span class="sxs-lookup"><span data-stu-id="16b77-111">Bits in NOR flash memory can only be set once, via the erase block operation.</span></span>

<span data-ttu-id="16b77-112">O LevelX divide cada bloco de flash NOR em *sectores lógicos* de 512 byte.</span><span class="sxs-lookup"><span data-stu-id="16b77-112">LevelX divides each NOR flash block into 512-byte logical *sectors*.</span></span> <span data-ttu-id="16b77-113">Além disso, o LevelX utiliza os primeiros sectores "n" de cada bloco de flash NOR para armazenar informações de gestão.</span><span class="sxs-lookup"><span data-stu-id="16b77-113">Furthermore, LevelX uses the first "n" sectors of each NOR flash block to store management information.</span></span> <span data-ttu-id="16b77-114">O formato da informação de gestão de memória flash LevelX NOR é:</span><span class="sxs-lookup"><span data-stu-id="16b77-114">The format of the LevelX NOR flash memory management information is:</span></span>

<span data-ttu-id="16b77-115">**Formato de bloco LevelX NOR**</span><span class="sxs-lookup"><span data-stu-id="16b77-115">**LevelX NOR Block Format**</span></span>

| <span data-ttu-id="16b77-116">Byte Offset</span><span class="sxs-lookup"><span data-stu-id="16b77-116">Byte Offset</span></span>  | <span data-ttu-id="16b77-117">Conteúdos</span><span class="sxs-lookup"><span data-stu-id="16b77-117">Contents</span></span>                     |
| ------------ | ---------------------------- |
| <span data-ttu-id="16b77-118">0</span><span class="sxs-lookup"><span data-stu-id="16b77-118">0</span></span>            | <span data-ttu-id="16b77-119">[Contagem de Apagamento de Blocos]</span><span class="sxs-lookup"><span data-stu-id="16b77-119">[Block Erase Count]</span></span>          |
| <span data-ttu-id="16b77-120">4</span><span class="sxs-lookup"><span data-stu-id="16b77-120">4</span></span>            | <span data-ttu-id="16b77-121">[Setor mínimo mapeado]</span><span class="sxs-lookup"><span data-stu-id="16b77-121">[Minimum Mapped Sector]</span></span>      |
| <span data-ttu-id="16b77-122">8</span><span class="sxs-lookup"><span data-stu-id="16b77-122">8</span></span>            | <span data-ttu-id="16b77-123">[Sector Mapeado Máximo]</span><span class="sxs-lookup"><span data-stu-id="16b77-123">[Maximum Mapped Sector]</span></span>      |
| <span data-ttu-id="16b77-124">12</span><span class="sxs-lookup"><span data-stu-id="16b77-124">12</span></span>           | <span data-ttu-id="16b77-125">[Mapa do Bit do Sector Livre]</span><span class="sxs-lookup"><span data-stu-id="16b77-125">[Free Sector Bit Map]</span></span>        |
| <span data-ttu-id="16b77-126">m</span><span class="sxs-lookup"><span data-stu-id="16b77-126">m</span></span>            | <span data-ttu-id="16b77-127">[Seção de Mapeamento sector 0]</span><span class="sxs-lookup"><span data-stu-id="16b77-127">[Sector 0 Mapping Entry]</span></span>     |
|              | <span data-ttu-id="16b77-128">…</span><span class="sxs-lookup"><span data-stu-id="16b77-128">…</span></span>                            |
| <span data-ttu-id="16b77-129">m+4\*(n-1)</span><span class="sxs-lookup"><span data-stu-id="16b77-129">m+4\*(n-1)</span></span>    | <span data-ttu-id="16b77-130">[Entrada de Mapeamento sectorial n]</span><span class="sxs-lookup"><span data-stu-id="16b77-130">[Sector "n" Mapping Entry]</span></span>   |
|              | <span data-ttu-id="16b77-131">…</span><span class="sxs-lookup"><span data-stu-id="16b77-131">…</span></span>                            |
| <span data-ttu-id="16b77-132">t</span><span class="sxs-lookup"><span data-stu-id="16b77-132">s</span></span>            | <span data-ttu-id="16b77-133">[Sector 0 Conteúdos]</span><span class="sxs-lookup"><span data-stu-id="16b77-133">[Sector 0 Contents]</span></span>          |
|              | <span data-ttu-id="16b77-134">…</span><span class="sxs-lookup"><span data-stu-id="16b77-134">…</span></span>                            |
| <span data-ttu-id="16b77-135">s+512\*(n-1)</span><span class="sxs-lookup"><span data-stu-id="16b77-135">s+512\*(n-1)</span></span> | <span data-ttu-id="16b77-136">[Sector "n" Conteúdos]</span><span class="sxs-lookup"><span data-stu-id="16b77-136">[Sector "n" Contents]</span></span>         |

<span data-ttu-id="16b77-137">O Conde de *32 bits* de Eliminação de Blocos contém o número de vezes que o bloco foi apagado.</span><span class="sxs-lookup"><span data-stu-id="16b77-137">The 32-bit *Block Erase Count* contains the number of times the block has been erased.</span></span> <span data-ttu-id="16b77-138">O principal objetivo do LevelX é manter a contagem de apagamento de todos os blocos relativamente perto para ajudar a evitar que qualquer bloco se desgaste prematuramente.</span><span class="sxs-lookup"><span data-stu-id="16b77-138">The main goal of LevelX is to keep the erase count of all blocks relatively close to help prevent any one block from wearing out prematurely.</span></span> <span data-ttu-id="16b77-139">Os campos mínimos de 32 bits *do sector mapeado* e *do sector máximo mapeados* só são escritos quando todos os sectores lógicos do bloco foram mapeados e escritos.</span><span class="sxs-lookup"><span data-stu-id="16b77-139">The 32-bit *Minimum Mapped Sector* and *Maximum Mapped Sector* fields are written only when all the logical sectors in the block have been mapped and written to.</span></span> <span data-ttu-id="16b77-140">Estes campos são úteis para otimizar a operação de leitura do sector.</span><span class="sxs-lookup"><span data-stu-id="16b77-140">These fields are useful for optimization of the sector read operation.</span></span> <span data-ttu-id="16b77-141">A entrada *do Mapa do Bit do Sector Livre* é um mapa de um pouco onde cada bit corresponde a um setor não mapeado no bloco.</span><span class="sxs-lookup"><span data-stu-id="16b77-141">The *Free Sector Bit Map* entry is a bit map where each set bit corresponds to an unmapped sector in the block.</span></span> <span data-ttu-id="16b77-142">Para este campo é mais eficaz a pesquisa no sector livre.</span><span class="sxs-lookup"><span data-stu-id="16b77-142">This field is used to make the free sector search more efficient.</span></span> <span data-ttu-id="16b77-143">Este é um campo de comprimento variável que requer uma palavra para cada 32 sectores do bloco.</span><span class="sxs-lookup"><span data-stu-id="16b77-143">This is a variable length field that requires one word for every 32 sectors in the block.</span></span> <span data-ttu-id="16b77-144">A matriz *de entrada de mapeamento sectorial* contém informações de mapeamento para cada sector do bloco.</span><span class="sxs-lookup"><span data-stu-id="16b77-144">The *Sector Mapping Entry* array contains mapping information for each sector in the block.</span></span> <span data-ttu-id="16b77-145">Cada entrada tem o seguinte formato:</span><span class="sxs-lookup"><span data-stu-id="16b77-145">Each entry has the following format:</span></span>

<span data-ttu-id="16b77-146">**Entrada de Mapeamento do Setor**</span><span class="sxs-lookup"><span data-stu-id="16b77-146">**Sector Mapping Entry**</span></span>

| <span data-ttu-id="16b77-147">Bit(s)</span><span class="sxs-lookup"><span data-stu-id="16b77-147">Bit(s)</span></span> | <span data-ttu-id="16b77-148">Significado</span><span class="sxs-lookup"><span data-stu-id="16b77-148">Meaning</span></span>  |
| ------ | -------- |
| <span data-ttu-id="16b77-149">31</span><span class="sxs-lookup"><span data-stu-id="16b77-149">31</span></span>     | <span data-ttu-id="16b77-150">Bandeira válida.</span><span class="sxs-lookup"><span data-stu-id="16b77-150">Valid flag.</span></span> <span data-ttu-id="16b77-151">Quando o setor definido e lógico nem todos indicam que o mapeamento é válido</span><span class="sxs-lookup"><span data-stu-id="16b77-151">When set and logical sector not all ones indicates mapping is valid</span></span> |
| <span data-ttu-id="16b77-152">30</span><span class="sxs-lookup"><span data-stu-id="16b77-152">30</span></span>     | <span data-ttu-id="16b77-153">Bandeira obsoleta.</span><span class="sxs-lookup"><span data-stu-id="16b77-153">Obsolete flag.</span></span> <span data-ttu-id="16b77-154">Quando claro, este mapeamento ou é obsoleto ou está em vias de se tornar obsoleto.</span><span class="sxs-lookup"><span data-stu-id="16b77-154">When clear, this mapping is either obsolete or is in the process of becoming obsolete.</span></span> |
| <span data-ttu-id="16b77-155">29</span><span class="sxs-lookup"><span data-stu-id="16b77-155">29</span></span>     | <span data-ttu-id="16b77-156">Mapeamento da escrita de entrada está completo quando este bit é 0</span><span class="sxs-lookup"><span data-stu-id="16b77-156">Mapping entry write is complete when this bit is 0</span></span> |
| <span data-ttu-id="16b77-157">0-28</span><span class="sxs-lookup"><span data-stu-id="16b77-157">0-28</span></span>   | <span data-ttu-id="16b77-158">Sector lógico mapeado para este setor físico - quando nem todos.</span><span class="sxs-lookup"><span data-stu-id="16b77-158">Logical sector mapped to this physical sector—when not all ones.</span></span> |

<span data-ttu-id="16b77-159">A parte superior do campo de 32 bits (bit 31) é usada para indicar que o mapeamento do sector lógico é válido.</span><span class="sxs-lookup"><span data-stu-id="16b77-159">The upper bit of the 32-bit field (bit 31) is used to indicate the logical sector mapping is valid.</span></span> <span data-ttu-id="16b77-160">Se este bit for 0, a informação nesta entrada (e os correspondentes conteúdos sectoriais) deixaram de ser válidas.</span><span class="sxs-lookup"><span data-stu-id="16b77-160">If this bit is 0, the information in this entry (and corresponding sector contents) is no longer valid.</span></span> <span data-ttu-id="16b77-161">A próxima parte - bit 30 - é utilizada para indicar que este sector está em vias de se tornar obsoleto e está a ser escrito um novo sector.</span><span class="sxs-lookup"><span data-stu-id="16b77-161">The next bit - bit 30 - is used to indicate this sector is in the process of becoming obsolete and a new sector is being written.</span></span> <span data-ttu-id="16b77-162">O bit 29 é utilizado para indicar quando a escrita de entrada de mapeamento está completa.</span><span class="sxs-lookup"><span data-stu-id="16b77-162">Bit 29 is used to indicate when the mapping entry write is complete.</span></span> <span data-ttu-id="16b77-163">Se o bit 29 for 0, a escrita de entrada de mapeamento está completa.</span><span class="sxs-lookup"><span data-stu-id="16b77-163">If bit 29 is 0, the mapping entry write is complete.</span></span> <span data-ttu-id="16b77-164">Se o bit 29 estiver definido, a entrada de mapeamento estava em fase de escrita.</span><span class="sxs-lookup"><span data-stu-id="16b77-164">If bit 29 is set, the mapping entry was in the process of being written.</span></span> <span data-ttu-id="16b77-165">Os bits 30 e 29 são usados na recuperação de uma potencial perda de energia enquanto atualizam um novo mapeamento do setor.</span><span class="sxs-lookup"><span data-stu-id="16b77-165">Bits 30 and 29 are used in recovering from a potential power loss while updating a new sector mapping.</span></span> <span data-ttu-id="16b77-166">Finalmente, os 29 bits mais baixos (28-0) contêm o número do sector lógico para o sector.</span><span class="sxs-lookup"><span data-stu-id="16b77-166">Finally, the lower 29-bits (28-0) contain the logical sector number for the sector.</span></span> <span data-ttu-id="16b77-167">Se um sector não tiver sido mapeado, todas as bits serão definidas, ou seja, terá um valor de 0xFFFFFFFF.</span><span class="sxs-lookup"><span data-stu-id="16b77-167">If a sector has not been mapped, all bits will be set, i.e., it will have a value of 0xFFFFFFFF.</span></span>

## <a name="nor-driver-requirements"></a><span data-ttu-id="16b77-168">NOR Requisitos do condutor</span><span class="sxs-lookup"><span data-stu-id="16b77-168">NOR Driver Requirements</span></span>

<span data-ttu-id="16b77-169">O LevelX requer um controlador de flash NOR subjacente que seja específico da parte de flash subjacente e da implementação de hardware.</span><span class="sxs-lookup"><span data-stu-id="16b77-169">LevelX requires an underlying NOR flash driver that is specific to the underlying flash part and hardware implementation.</span></span> <span data-ttu-id="16b77-170">O controlador é especificado para LevelX durante a inicialização através do ***lx_nor_flash_open*** da API .</span><span class="sxs-lookup"><span data-stu-id="16b77-170">The driver is specified to LevelX during initialization via the API ***lx_nor_flash_open***.</span></span> <span data-ttu-id="16b77-171">O protótipo do condutor LevelX é:</span><span class="sxs-lookup"><span data-stu-id="16b77-171">The prototype of the LevelX driver is:</span></span>

```c
INT nor_driver_initialize(LX_NOR_FLASH *instance);
```

<span data-ttu-id="16b77-172">O parâmetro "*exemplo*" especifica o bloco de controlo LevelX NOR.</span><span class="sxs-lookup"><span data-stu-id="16b77-172">The "*instance*" parameter specifies the LevelX NOR control block.</span></span> <span data-ttu-id="16b77-173">A função de inicialização do controlador é responsável pela configuração de todos os outros serviços ao nível do condutor para a instância de Nível N/ LevelX associada.</span><span class="sxs-lookup"><span data-stu-id="16b77-173">The driver initialization function is responsible for setting up all the other driver-level services for the associated LevelX instance.</span></span> <span data-ttu-id="16b77-174">Os serviços necessários para cada instância LevelX NOR são:</span><span class="sxs-lookup"><span data-stu-id="16b77-174">The services required for each LevelX NOR instance are:</span></span>

- <span data-ttu-id="16b77-175">Setor de Leitura</span><span class="sxs-lookup"><span data-stu-id="16b77-175">Read Sector</span></span>
- <span data-ttu-id="16b77-176">Setor de Escrita</span><span class="sxs-lookup"><span data-stu-id="16b77-176">Write Sector</span></span>
- <span data-ttu-id="16b77-177">Apagamento de blocos</span><span class="sxs-lookup"><span data-stu-id="16b77-177">Block Erase</span></span>
- <span data-ttu-id="16b77-178">Verificação de blocos apagadas</span><span class="sxs-lookup"><span data-stu-id="16b77-178">Block Erased Verify</span></span>
- <span data-ttu-id="16b77-179">Manipulador de erros do sistema</span><span class="sxs-lookup"><span data-stu-id="16b77-179">System Error Handler</span></span>

## <a name="driver-initialization"></a><span data-ttu-id="16b77-180">Inicialização do condutor</span><span class="sxs-lookup"><span data-stu-id="16b77-180">Driver Initialization</span></span>

<span data-ttu-id="16b77-181">Estes serviços são configurados através da definição de ponteiros de função no **LX_NOR_FLASH** instância dentro da função de inicialização do controlador.</span><span class="sxs-lookup"><span data-stu-id="16b77-181">These services are setup via setting function pointers in the **LX_NOR_FLASH** instance within the driver's initialization function.</span></span> <span data-ttu-id="16b77-182">A função de inicialização do controlador também é responsável por:</span><span class="sxs-lookup"><span data-stu-id="16b77-182">The driver initialization function also is responsible for:</span></span>

1. <span data-ttu-id="16b77-183">Especificando o endereço base do flash.</span><span class="sxs-lookup"><span data-stu-id="16b77-183">Specifying the base address of the flash.</span></span>
1. <span data-ttu-id="16b77-184">Especificando o número total de blocos e o número de palavras por bloco.</span><span class="sxs-lookup"><span data-stu-id="16b77-184">Specifying the total number of blocks and the number of words per block.</span></span>
1. <span data-ttu-id="16b77-185">Um tampão RAM para ler um sector de flash (512 bytes) e alinhado para acesso ULONG.</span><span class="sxs-lookup"><span data-stu-id="16b77-185">A RAM buffer for reading one sector of flash (512 bytes) and aligned for ULONG access.</span></span>

<span data-ttu-id="16b77-186">A função de inicialização do controlador provavelmente também executa tarefas adicionais de inicialização do dispositivo e/ou de implementação específicas antes de devolver **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="16b77-186">The driver initialization function likely also performs additional device and/or implementation-specific initialization duties before returning **LX_SUCCESS**.</span></span>

## <a name="driver-read-sector"></a><span data-ttu-id="16b77-187">Setor de Leitura de Motorista</span><span class="sxs-lookup"><span data-stu-id="16b77-187">Driver Read Sector</span></span>

<span data-ttu-id="16b77-188">O serviço "reading sector" do condutor LevelX NOR é responsável pela leitura de um sector específico num bloco específico do flash NOR.</span><span class="sxs-lookup"><span data-stu-id="16b77-188">The LevelX NOR driver "read sector" service is responsible for reading a specific sector in a specific block of the NOR flash.</span></span> <span data-ttu-id="16b77-189">Toda a lógica de verificação e correção de erros é da responsabilidade do serviço de condutor.</span><span class="sxs-lookup"><span data-stu-id="16b77-189">All error checking and correcting logic is the responsibility of the driver service.</span></span> <span data-ttu-id="16b77-190">Se for bem sucedido, o controlador LevelX NOR regressa **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="16b77-190">If successful, the LevelX NOR driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="16b77-191">Se não for bem sucedido, o condutor LevelX NOR regressa *LX_ERROR*.</span><span class="sxs-lookup"><span data-stu-id="16b77-191">If not successful, the LevelX NOR driver returns *LX_ERROR*.</span></span> <span data-ttu-id="16b77-192">O protótipo do serviço "ler sector de leitura" do condutor LevelX NOR é:</span><span class="sxs-lookup"><span data-stu-id="16b77-192">The prototype of the LevelX NOR driver "read sector" service is:</span></span>

```c
INT nor_driver_read_sector(
    ULONG *flash_address,
    ULONG *destination, 
    ULONG words);
```

<span data-ttu-id="16b77-193">Onde "*flash_address*" especifica o endereço de um sector lógico dentro de um bloco de memória NOR e "*destino*" e "*palavras*" especificam onde colocar o conteúdo do sector e quantas palavras de 32 bits para ler.</span><span class="sxs-lookup"><span data-stu-id="16b77-193">Where "*flash_address*" specifies the address of a logical sector within a NOR flash block of memory and "*destination*" and "*words*" specify where to place the sector contents and how many 32-bit words to read.</span></span>

## <a name="driver-write-sector"></a><span data-ttu-id="16b77-194">Setor de Escrita de Motorista</span><span class="sxs-lookup"><span data-stu-id="16b77-194">Driver Write Sector</span></span>

<span data-ttu-id="16b77-195">O serviço "sector de escrita" LevelX NOR é responsável por escrever um sector específico num bloco do flash NOR.</span><span class="sxs-lookup"><span data-stu-id="16b77-195">The LevelX NOR driver "write sector" service is responsible for writing a specific sector into a block of the NOR flash.</span></span> <span data-ttu-id="16b77-196">Toda a verificação de erros é da responsabilidade do serviço de motorista.</span><span class="sxs-lookup"><span data-stu-id="16b77-196">All error checking is the responsibility of the driver service.</span></span> <span data-ttu-id="16b77-197">Se for bem sucedido, o controlador LevelX NOR regressa **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="16b77-197">If successful, the LevelX NOR driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="16b77-198">Se não for bem sucedido, o condutor LevelX NOR regressa **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="16b77-198">If not successful, the LevelX NOR driver returns **LX_ERROR**.</span></span> <span data-ttu-id="16b77-199">O protótipo do serviço "sector de escrita" do condutor LevelX NOR é:</span><span class="sxs-lookup"><span data-stu-id="16b77-199">The prototype of the LevelX NOR driver "write sector" service is:</span></span>

```c
INT nor_driver_write_sector(
    ULONG *flash_address,
    ULONG *source, 
    ULONG words);
```

<span data-ttu-id="16b77-200">Onde "*flash_address*" especifica o endereço de um sector lógico dentro de um bloco de memória NOR flash e "*fonte*" e "*palavras*" especificam a fonte da escrita e quantas palavras de 32 bits para escrever.</span><span class="sxs-lookup"><span data-stu-id="16b77-200">Where "*flash_address*" specifies the address of a logical sector within a NOR flash block of memory and "*source*" and "*words*" specify the source of the write and how many 32-bit words to write.</span></span>

> [!NOTE]
> <span data-ttu-id="16b77-201">O LevelX conta com o condutor para verificar se o sector da escrita foi bem sucedido.</span><span class="sxs-lookup"><span data-stu-id="16b77-201">LevelX relies on the driver to verify that the write sector was successful.</span></span> <span data-ttu-id="16b77-202">Isto é normalmente feito lendo o valor programado para garantir que corresponde ao valor solicitado a ser escrito.</span><span class="sxs-lookup"><span data-stu-id="16b77-202">This is typically done by reading back the programmed value to ensure it matches the requested value to be written.</span></span>

## <a name="driver-block-erase"></a><span data-ttu-id="16b77-203">Apagamento do bloco de motorista</span><span class="sxs-lookup"><span data-stu-id="16b77-203">Driver Block Erase</span></span>

<span data-ttu-id="16b77-204">O serviço de "apagar blocos" levelX NOR é responsável por apagar o bloco especificado do flash NOR.</span><span class="sxs-lookup"><span data-stu-id="16b77-204">The LevelX NOR driver "block erase" service is responsible for erasing the specified block of the NOR flash.</span></span> <span data-ttu-id="16b77-205">Se for bem sucedido, o controlador LevelX NOR regressa **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="16b77-205">If successful, the LevelX NOR driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="16b77-206">Se não for bem sucedido, o condutor LevelX NOR regressa **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="16b77-206">If not successful, the LevelX NOR driver returns **LX_ERROR**.</span></span> <span data-ttu-id="16b77-207">O protótipo do serviço de "eliminação de blocos" levelX NOR é:</span><span class="sxs-lookup"><span data-stu-id="16b77-207">The prototype of the LevelX NOR driver "block erase" service is:</span></span>

```c
INT nor_driver_block_erase(ULONG block,  
    ULONG erase_count);
```

<span data-ttu-id="16b77-208">Onde "*bloco*" identifica que BLOCO PARA apagar.</span><span class="sxs-lookup"><span data-stu-id="16b77-208">Where "*block*" identifies which NOR block to erase.</span></span> <span data-ttu-id="16b77-209">O parâmetro "*erase_count*" é fornecido para fins de diagnóstico.</span><span class="sxs-lookup"><span data-stu-id="16b77-209">The parameter "*erase_count*" is provided for diagnostic purposes.</span></span> <span data-ttu-id="16b77-210">Por exemplo, o condutor pode querer alertar outra parte do software da aplicação quando a contagem de apagamento exceder um limiar específico.</span><span class="sxs-lookup"><span data-stu-id="16b77-210">For example, the driver may want to alert another portion of the application software when the erase count exceeds a specific threshold.</span></span>

> [!NOTE]
> <span data-ttu-id="16b77-211">O LevelX conta com o controlador para examinar todos os bytes do bloco para garantir que são apagados (conter todos os).</span><span class="sxs-lookup"><span data-stu-id="16b77-211">LevelX relies on the driver to examine all bytes of the block to ensure they are erased (contain all ones).</span></span>

## <a name="driver-block-erased-verify"></a><span data-ttu-id="16b77-212">Verificação apagada do bloco de motorista</span><span class="sxs-lookup"><span data-stu-id="16b77-212">Driver Block Erased Verify</span></span>

<span data-ttu-id="16b77-213">O serviço de "verificar o bloqueio do bloco" LevelX NOR é responsável por verificar se o bloco especificado do flash NOR é apagado.</span><span class="sxs-lookup"><span data-stu-id="16b77-213">The LevelX NOR driver "block erased verify" service is responsible for verifying that the specified block of the NOR flash is erased.</span></span> <span data-ttu-id="16b77-214">Se for apagado, o condutor LevelX NOR regressa **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="16b77-214">If it is erased, the LevelX NOR driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="16b77-215">Se o bloco não for apagado, o condutor LevelX NOR regressa **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="16b77-215">If the block is not erased, the LevelX NOR driver returns **LX_ERROR**.</span></span> <span data-ttu-id="16b77-216">O protótipo do serviço "blocked check" do controlador LevelX NOR é:</span><span class="sxs-lookup"><span data-stu-id="16b77-216">The prototype of the LevelX NOR driver "block erased verify" service is:</span></span>

```c
INT nor_driver_block_erased_verify(ULONG block);
```

<span data-ttu-id="16b77-217">Onde "*bloco*" especifica qual bloco para verificar se é apagado.</span><span class="sxs-lookup"><span data-stu-id="16b77-217">Where "*block*" specifies which block to verify that it is erased.</span></span>

> [!NOTE]
> <span data-ttu-id="16b77-218">O LevelX conta com o controlador para examinar todos os bytes do especificado para garantir que são apagados (conter todos os).</span><span class="sxs-lookup"><span data-stu-id="16b77-218">LevelX relies on the driver to examine all bytes of the specified to ensure they are erased (contain all ones).</span></span>

## <a name="driver-system-error"></a><span data-ttu-id="16b77-219">Erro do sistema do controlador</span><span class="sxs-lookup"><span data-stu-id="16b77-219">Driver System Error</span></span>

<span data-ttu-id="16b77-220">O serviço "manipulador de erros do sistema" LevelX NOR é responsável pela definição de erros do sistema de manuseamento detetados pelo LevelX.</span><span class="sxs-lookup"><span data-stu-id="16b77-220">The LevelX NOR driver "system error handler" service is responsible for setting handling system errors detected by LevelX.</span></span> <span data-ttu-id="16b77-221">O processamento nesta rotina é dependente da aplicação.</span><span class="sxs-lookup"><span data-stu-id="16b77-221">The processing in this routine is application dependent.</span></span> <span data-ttu-id="16b77-222">Se for bem sucedido, o condutor LevelX NOR regressa **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="16b77-222">If it is successful, the LevelX NOR driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="16b77-223">Se não for bem sucedido, o condutor LevelX NOR regressa **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="16b77-223">If it is not successful, the LevelX NOR driver returns **LX_ERROR**.</span></span> <span data-ttu-id="16b77-224">O protótipo do serviço "erro do sistema" do controlador LevelX NOR é:</span><span class="sxs-lookup"><span data-stu-id="16b77-224">The prototype of the LevelX NOR driver "system error" service is:</span></span>

```c
INT nor_driver_system_error(UINT error_code);
```

<span data-ttu-id="16b77-225">Onde "*error_code*" representa o erro que ocorreu.</span><span class="sxs-lookup"><span data-stu-id="16b77-225">Where "*error_code*" represents the error that occurred.</span></span>

## <a name="nor-simulated-driver"></a><span data-ttu-id="16b77-226">NOR Simulado Condutor</span><span class="sxs-lookup"><span data-stu-id="16b77-226">NOR Simulated Driver</span></span>

<span data-ttu-id="16b77-227">O LevelX fornece um controlador de flash NOR simulado que simplesmente utiliza RAM para simular o funcionamento de uma peça de flash NOR.</span><span class="sxs-lookup"><span data-stu-id="16b77-227">LevelX provides a simulated NOR flash driver that simply uses RAM to simulate the operation of a NOR flash part.</span></span> <span data-ttu-id="16b77-228">Por predefinição, o controlador simulado NOR fornece 8 blocos de flash NOR com 16 sectores de 512 bytes por bloco.</span><span class="sxs-lookup"><span data-stu-id="16b77-228">By default, the NOR simulated driver provides 8 NOR flash blocks with 16 512-byte sectors per block.</span></span>

<span data-ttu-id="16b77-229">A função de inicialização simulada do condutor de flash NOR é ***lx_nor_flash_simulator_initialize** _ e é definida em _*_lx_nor_flash_simulator.c_\*\*.</span><span class="sxs-lookup"><span data-stu-id="16b77-229">The simulated NOR flash driver initialization function is ***lx_nor_flash_simulator_initialize** _ and is defined in _*_lx_nor_flash_simulator.c_\*\*.</span></span> <span data-ttu-id="16b77-230">Este controlador também fornece um bom modelo para escrever controladores flash NOR específicos.</span><span class="sxs-lookup"><span data-stu-id="16b77-230">This driver also provides a good template for writing specific NOR flash drivers.</span></span>

## <a name="nor-filex-integration"></a><span data-ttu-id="16b77-231">INTEGRAÇÃO NOR FileX</span><span class="sxs-lookup"><span data-stu-id="16b77-231">NOR FileX Integration</span></span>

<span data-ttu-id="16b77-232">Como mencionado anteriormente, o LevelX não depende do FileX para funcionamento.</span><span class="sxs-lookup"><span data-stu-id="16b77-232">As mentioned earlier, LevelX does not rely on FileX for operation.</span></span> <span data-ttu-id="16b77-233">Todas as APIs do LevelX podem ser chamadas diretamente pelo software de aplicação para armazenar/recuperar dados brutos para os sectores lógicos fornecidos pelo LevelX.</span><span class="sxs-lookup"><span data-stu-id="16b77-233">All the LevelX APIs may be called directly by the application software to store/retrieve raw data to the logical sectors provided by LevelX.</span></span> <span data-ttu-id="16b77-234">No entanto, o LevelX também suporta o FileX.</span><span class="sxs-lookup"><span data-stu-id="16b77-234">However, LevelX also supports FileX.</span></span>

<span data-ttu-id="16b77-235">O ficheiro ***fx_nor_flash_simulated_driver.c*** contém um exemplo de controlador FileX para utilização com a simulação de flash NOR.</span><span class="sxs-lookup"><span data-stu-id="16b77-235">The file ***fx_nor_flash_simulated_driver.c*** contains an example FileX driver for use with the NOR flash simulation.</span></span> <span data-ttu-id="16b77-236">O controlador NOR flash FileX para o LevelX fornece um bom ponto de partida para a escrita de controladores FileX personalizados.</span><span class="sxs-lookup"><span data-stu-id="16b77-236">The NOR flash FileX driver for LevelX provides a good starting point for writing custom FileX drivers.</span></span>

> [!NOTE]
> <span data-ttu-id="16b77-237">O formato flash FileX NOR deve ser um tamanho de bloco completo de sectores menos do que o flash NOR fornece.</span><span class="sxs-lookup"><span data-stu-id="16b77-237">The FileX NOR flash format should be one full block size of sectors less than the NOR flash provides.</span></span> <span data-ttu-id="16b77-238">Isto ajudará a garantir um melhor desempenho durante o processamento do nível de desgaste.</span><span class="sxs-lookup"><span data-stu-id="16b77-238">This will help ensure best performance during the wear level processing.</span></span> <span data-ttu-id="16b77-239">Técnicas adicionais para melhorar o desempenho da escrita no algoritmo de nivelamento de desgaste LevelX incluem:</span><span class="sxs-lookup"><span data-stu-id="16b77-239">Additional techniques to improve write performance in the LevelX wear leveling algorithm include:</span></span>
> 1. <span data-ttu-id="16b77-240">Certifique-se de que todas as escritas são exatamente um ou mais clusters de tamanho e começar em limites exatos do cluster.</span><span class="sxs-lookup"><span data-stu-id="16b77-240">Ensure that all writes are exactly one or more clusters in size and start on exact cluster boundaries.</span></span>
> 2. <span data-ttu-id="16b77-241">Pré-alocar clusters antes de realizar grandes operações de escrita de ficheiros através da classe ***de APIs fx_file_allocate*** FileX.</span><span class="sxs-lookup"><span data-stu-id="16b77-241">Pre-allocate clusters before performing large file write operations via the FileX ***fx_file_allocate*** class of APIs.</span></span>
> 3.  <span data-ttu-id="16b77-242">O uso periódico de ***lx_nor_flash_defragment*** para libertar o maior número possível de blocos NOR e assim melhorar o desempenho da escrita.</span><span class="sxs-lookup"><span data-stu-id="16b77-242">Periodic use of ***lx_nor_flash_defragment*** to free up as many NOR blocks as possible and thus improve write performance.</span></span>
> 4. <span data-ttu-id="16b77-243">Certifique-se de que o controlador FileX está habilitado a receber informações do sector de libertação e os pedidos feitos ao condutor para libertar os sectores são tratados no condutor, chamando ***lx_nor_flash_sector_release***.</span><span class="sxs-lookup"><span data-stu-id="16b77-243">Ensure the FileX driver is enabled to receive release sector information and requests made to the driver to release sectors are handled in the driver by calling ***lx_nor_flash_sector_release***.</span></span>
