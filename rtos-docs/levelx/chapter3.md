---
title: Suporte Azure RTOS LevelX NAND
description: A memória flash NAND é comumente utilizada dentro do LevelX para grande armazenamento de dados, que é típico dos sistemas de ficheiros.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 3286e4ea7f16b28ff55fc95a87a1e0c313ec4240
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: MT
ms.contentlocale: pt-PT
ms.lasthandoff: 03/22/2021
ms.locfileid: "104826269"
---
# <a name="chapter-3---azure-rtos-levelx-nand-support"></a><span data-ttu-id="cfd1b-103">Capítulo 3 - Suporte Azure RTOS LevelX NAND</span><span class="sxs-lookup"><span data-stu-id="cfd1b-103">Chapter 3 - Azure RTOS LevelX NAND support</span></span>

<span data-ttu-id="cfd1b-104">A memória flash NAND é comumente utilizada para o armazenamento de dados de grande porte, que é típico dos sistemas de ficheiros.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-104">NAND flash memory is commonly utilized for large data storage, which is typical of file systems.</span></span> <span data-ttu-id="cfd1b-105">A memória NAND consiste em *blocos.*</span><span class="sxs-lookup"><span data-stu-id="cfd1b-105">NAND memory consists of *blocks*.</span></span> <span data-ttu-id="cfd1b-106">Dentro de cada bloco NAND há uma série de *páginas.*</span><span class="sxs-lookup"><span data-stu-id="cfd1b-106">Within each NAND block is a series of *pages*.</span></span> <span data-ttu-id="cfd1b-107">Os blocos NAND são apagáveis, o que significa que todas as páginas dentro do bloco NAND são apagadas (definidas para todas as).</span><span class="sxs-lookup"><span data-stu-id="cfd1b-107">NAND blocks are erasable, which means that all pages within the NAND block are erased (set to all ones).</span></span> <span data-ttu-id="cfd1b-108">Cada página de bloco NAND tem um conjunto de *bytes sobressalentes* que são utilizados pelo Azure RTOS LevelX para contabilidade, má gestão de blocos e deteção de erros.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-108">Each NAND block page has a set of *spare bytes* that are utilized by Azure RTOS LevelX for bookkeeping, bad block management, and error detection.</span></span> <span data-ttu-id="cfd1b-109">As páginas de blocos NAND estão disponíveis em vários tamanhos.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-109">NAND block pages are available in a variety of sizes.</span></span> <span data-ttu-id="cfd1b-110">Os tamanhos de página mais comuns são:</span><span class="sxs-lookup"><span data-stu-id="cfd1b-110">The most common page sizes are:</span></span> 

| <span data-ttu-id="cfd1b-111">**Tamanho da Página**</span><span class="sxs-lookup"><span data-stu-id="cfd1b-111">**Page Size**</span></span> | <span data-ttu-id="cfd1b-112">**Bytes de reserva**</span><span class="sxs-lookup"><span data-stu-id="cfd1b-112">**Spare Bytes**</span></span> |
| ------------- | --------------- |
| <span data-ttu-id="cfd1b-113">256</span><span class="sxs-lookup"><span data-stu-id="cfd1b-113">256</span></span>           | <span data-ttu-id="cfd1b-114">8</span><span class="sxs-lookup"><span data-stu-id="cfd1b-114">8</span></span>               |
| <span data-ttu-id="cfd1b-115">512</span><span class="sxs-lookup"><span data-stu-id="cfd1b-115">512</span></span>           | <span data-ttu-id="cfd1b-116">16</span><span class="sxs-lookup"><span data-stu-id="cfd1b-116">16</span></span>              |
| <span data-ttu-id="cfd1b-117">2048</span><span class="sxs-lookup"><span data-stu-id="cfd1b-117">2048</span></span>          | <span data-ttu-id="cfd1b-118">64</span><span class="sxs-lookup"><span data-stu-id="cfd1b-118">64</span></span>              |

<span data-ttu-id="cfd1b-119">A memória NAND difere da memória NOR na medida em que não existe acesso direto, ou seja, a memória NAND não pode ser lida diretamente do processador como a memória NOR.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-119">NAND memory differs from NOR memory in that there is no direct access, i.e., NAND memory cannot be read directly from the processor like NOR memory.</span></span> <span data-ttu-id="cfd1b-120">A memória NAND só pode ser escrita após uma apagar um número limitado de vezes.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-120">NAND memory can only be written to after an erase a limited number of times.</span></span> <span data-ttu-id="cfd1b-121">Mais uma vez, isto difere da memória NOR que pode ser escrita um número ilimitado de vezes desde que o pedido de escrita é limpar bits definidos.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-121">Again, this differs from NOR memory that can be written an unlimited number of times providing the write request is clearing set bits.</span></span> <span data-ttu-id="cfd1b-122">Finalmente, os bytes sobressalentes associados a cada página são exclusivos do flash NAND.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-122">Finally, the spare bytes associated with each page are unique to NAND flash.</span></span> <span data-ttu-id="cfd1b-123">As configurações típicas de bytes de reposição são como mostrado na tabela abaixo.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-123">Typical spare byte configurations are as shown in the table below.</span></span>

| <span data-ttu-id="cfd1b-124">**Bytes de reserva**</span><span class="sxs-lookup"><span data-stu-id="cfd1b-124">**Spare Bytes**</span></span> | <span data-ttu-id="cfd1b-125">**Números byte**</span><span class="sxs-lookup"><span data-stu-id="cfd1b-125">**Byte numbers**</span></span> | <span data-ttu-id="cfd1b-126">**Configuração**</span><span class="sxs-lookup"><span data-stu-id="cfd1b-126">**Configuration**</span></span>     |
| ------------------------- | -------------- | --------------------- |
| <span data-ttu-id="cfd1b-127">8</span><span class="sxs-lookup"><span data-stu-id="cfd1b-127">8</span></span>                         | <span data-ttu-id="cfd1b-128">Bytes 0-2:</span><span class="sxs-lookup"><span data-stu-id="cfd1b-128">Bytes 0-2:</span></span>     | <span data-ttu-id="cfd1b-129">Bytes ECC</span><span class="sxs-lookup"><span data-stu-id="cfd1b-129">ECC bytes</span></span>             |
|                           | <span data-ttu-id="cfd1b-130">Bytes 3,4,6,7:</span><span class="sxs-lookup"><span data-stu-id="cfd1b-130">Bytes 3,4,6,7:</span></span> | <span data-ttu-id="cfd1b-131">Mapeamento do setor levelX</span><span class="sxs-lookup"><span data-stu-id="cfd1b-131">LevelX Sector Mapping</span></span> |
|                           | <span data-ttu-id="cfd1b-132">Byte 5:</span><span class="sxs-lookup"><span data-stu-id="cfd1b-132">Byte 5:</span></span>        | <span data-ttu-id="cfd1b-133">Bandeira de bloco mau</span><span class="sxs-lookup"><span data-stu-id="cfd1b-133">Bad block flag</span></span>        |
| <span data-ttu-id="cfd1b-134">16</span><span class="sxs-lookup"><span data-stu-id="cfd1b-134">16</span></span>                        | <span data-ttu-id="cfd1b-135">Bytes 0-3,6-7:</span><span class="sxs-lookup"><span data-stu-id="cfd1b-135">Bytes 0-3,6-7:</span></span> | <span data-ttu-id="cfd1b-136">Bytes ECC</span><span class="sxs-lookup"><span data-stu-id="cfd1b-136">ECC bytes</span></span>             |
|                           | <span data-ttu-id="cfd1b-137">Bytes 8-11:</span><span class="sxs-lookup"><span data-stu-id="cfd1b-137">Bytes 8-11:</span></span>    | <span data-ttu-id="cfd1b-138">Mapeamento do setor levelX</span><span class="sxs-lookup"><span data-stu-id="cfd1b-138">LevelX Sector Mapping</span></span> |
|                           | <span data-ttu-id="cfd1b-139">Bytes 12-15:</span><span class="sxs-lookup"><span data-stu-id="cfd1b-139">Bytes 12-15:</span></span>   | <span data-ttu-id="cfd1b-140">Não é bem-de-suso</span><span class="sxs-lookup"><span data-stu-id="cfd1b-140">Unused</span></span>                |
|                           | <span data-ttu-id="cfd1b-141">Byte 5:</span><span class="sxs-lookup"><span data-stu-id="cfd1b-141">Byte 5:</span></span>        | <span data-ttu-id="cfd1b-142">Bandeira de bloco mau</span><span class="sxs-lookup"><span data-stu-id="cfd1b-142">Bad block flag</span></span>        |
| <span data-ttu-id="cfd1b-143">64</span><span class="sxs-lookup"><span data-stu-id="cfd1b-143">64</span></span>                        | <span data-ttu-id="cfd1b-144">Byte 0:</span><span class="sxs-lookup"><span data-stu-id="cfd1b-144">Byte 0:</span></span>        | <span data-ttu-id="cfd1b-145">Bandeira de bloco mau</span><span class="sxs-lookup"><span data-stu-id="cfd1b-145">Bad block flag</span></span>        |
|                           | <span data-ttu-id="cfd1b-146">Bytes 2-5:</span><span class="sxs-lookup"><span data-stu-id="cfd1b-146">Bytes 2-5:</span></span>     | <span data-ttu-id="cfd1b-147">Mapeamento do setor levelX</span><span class="sxs-lookup"><span data-stu-id="cfd1b-147">LevelX Sector Mapping</span></span> |
|                           | <span data-ttu-id="cfd1b-148">Bytes 6-39:</span><span class="sxs-lookup"><span data-stu-id="cfd1b-148">Bytes 6-39:</span></span>    | <span data-ttu-id="cfd1b-149">Não é bem-de-suso</span><span class="sxs-lookup"><span data-stu-id="cfd1b-149">Unused</span></span>                |
|                           | <span data-ttu-id="cfd1b-150">Bytes 40-63:</span><span class="sxs-lookup"><span data-stu-id="cfd1b-150">Bytes 40-63:</span></span>   | <span data-ttu-id="cfd1b-151">Bytes ECC</span><span class="sxs-lookup"><span data-stu-id="cfd1b-151">ECC bytes</span></span>             |

<span data-ttu-id="cfd1b-152">LevelX Utiliza 4 dos bytes sobressalentes de cada página NAND para acompanhar o sector lógico mapeado para a página física NAND.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-152">LevelX Utilizes 4 of the spare bytes of each NAND page for keeping track of the logical sector mapped to the physical NAND page.</span></span> <span data-ttu-id="cfd1b-153">Estes 4 bytes são usados para implementar um número inteiro de 32 bits não assinado com um formato proprietário LevelX.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-153">These 4 bytes are used to implement a 32-bit unsigned integer with a LevelX proprietary format.</span></span> <span data-ttu-id="cfd1b-154">A parte superior do campo de 32 bits (bit 31) é usada para indicar que o mapeamento lógico sector-a-página é válido.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-154">The upper bit of the 32-bit field (bit 31) is used to indicate the logical sector-to-page mapping is valid.</span></span> <span data-ttu-id="cfd1b-155">Se esta bit for 0, a informação nesta página já não é válida.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-155">If this bit is 0, the information in this page is no longer valid.</span></span> <span data-ttu-id="cfd1b-156">A próxima bit - bit 30 - é usada para indicar que esta página está em processo de tornar-se obsoleta e um novo setor está sendo escrito.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-156">The next bit—bit 30—is used to indicate this page is in the process of becoming obsolete and a new sector is being written.</span></span> <span data-ttu-id="cfd1b-157">O bit 29 é utilizado para indicar quando a escrita de entrada de mapeamento está completa.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-157">Bit 29 is used to indicate when the mapping entry write is complete.</span></span> <span data-ttu-id="cfd1b-158">Se o bit 29 for 0, a escrita de entrada de mapeamento está completa.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-158">If bit 29 is 0, the mapping entry write is complete.</span></span> <span data-ttu-id="cfd1b-159">Se o bit 29 estiver definido, a entrada de mapeamento estava em fase de escrita.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-159">If bit 29 is set, the mapping entry was in the process of being written.</span></span> <span data-ttu-id="cfd1b-160">Os bits 30 e 29 são utilizados na recuperação de uma potencial perda de energia enquanto atualizam uma nova página flash.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-160">Bits 30 and 29 are used in recovering from a potential power loss while updating a new flash page.</span></span> <span data-ttu-id="cfd1b-161">Finalmente, os 29 bits inferiores (28-0) contêm o número do sector lógico para a página.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-161">Finally, the lower 29-bits (28-0) contain the logical sector number for the page.</span></span>

<span data-ttu-id="cfd1b-162">**Entrada de mapeamento levelX**</span><span class="sxs-lookup"><span data-stu-id="cfd1b-162">**LevelX Mapping Entry**</span></span>

| <span data-ttu-id="cfd1b-163">Bit(s)</span><span class="sxs-lookup"><span data-stu-id="cfd1b-163">Bit(s)</span></span> | <span data-ttu-id="cfd1b-164">Significado</span><span class="sxs-lookup"><span data-stu-id="cfd1b-164">Meaning</span></span> |
| ------ | ------- |
| <span data-ttu-id="cfd1b-165">31</span><span class="sxs-lookup"><span data-stu-id="cfd1b-165">31</span></span>     | <span data-ttu-id="cfd1b-166">Bandeira válida.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-166">Valid flag.</span></span> <span data-ttu-id="cfd1b-167">Quando o setor definido e lógico não é todos os que indicam que o mapeamento é válido</span><span class="sxs-lookup"><span data-stu-id="cfd1b-167">When set and logical sector is not all ones indicates mapping is valid</span></span> |
| <span data-ttu-id="cfd1b-168">30</span><span class="sxs-lookup"><span data-stu-id="cfd1b-168">30</span></span>     | <span data-ttu-id="cfd1b-169">Bandeira obsoleta.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-169">Obsolete flag.</span></span> <span data-ttu-id="cfd1b-170">Quando claro, este mapeamento ou é obsoleto ou está em vias de se tornar obsoleto.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-170">When clear, this mapping is either obsolete or is in the process of becoming obsolete.</span></span> |
| <span data-ttu-id="cfd1b-171">29</span><span class="sxs-lookup"><span data-stu-id="cfd1b-171">29</span></span>     | <span data-ttu-id="cfd1b-172">Mapeamento da escrita de entrada está completo quando este bit é 0</span><span class="sxs-lookup"><span data-stu-id="cfd1b-172">Mapping entry write is complete when this bit is 0</span></span> |
| <span data-ttu-id="cfd1b-173">0-28</span><span class="sxs-lookup"><span data-stu-id="cfd1b-173">0-28</span></span>   | <span data-ttu-id="cfd1b-174">Sector lógico mapeado para esta página física - quando nem todos.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-174">Logical sector mapped to this physical page—when not all ones.</span></span> |

<span data-ttu-id="cfd1b-175">O LevelX também utiliza a primeira página de cada bloco NAND para a contagem de apagamento de blocos, bem como a lista de páginas mapeadas quando o bloco está cheio.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-175">LevelX also utilizes the first page of each NAND block for the block erase count as well as the list of mapped pages when the block is full.</span></span> <span data-ttu-id="cfd1b-176">O formato da primeira página de um bloco NAND no LevelX é mostrado abaixo:</span><span class="sxs-lookup"><span data-stu-id="cfd1b-176">The format of the first page of a NAND block in LevelX is shown below:</span></span>

| <span data-ttu-id="cfd1b-177">Formato LevelX Block Page 0</span><span class="sxs-lookup"><span data-stu-id="cfd1b-177">LevelX Block Page 0 Format</span></span> |
|:--------------------------:|
| <span data-ttu-id="cfd1b-178">[Contagem de Apagamento de Blocos]</span><span class="sxs-lookup"><span data-stu-id="cfd1b-178">[Block Erase Count]</span></span>        |
| <span data-ttu-id="cfd1b-179">[Mapeamento do Sector da Página 1]</span><span class="sxs-lookup"><span data-stu-id="cfd1b-179">[Page 1 Sector Mapping]</span></span>    |
| <span data-ttu-id="cfd1b-180">...</span><span class="sxs-lookup"><span data-stu-id="cfd1b-180">...</span></span>                        |
| <span data-ttu-id="cfd1b-181">[Página "n" Mapeamento do Sector]</span><span class="sxs-lookup"><span data-stu-id="cfd1b-181">[Page "n" Sector Mapping]</span></span>  |
| <span data-ttu-id="cfd1b-182">[0xF0F0F0F0]</span><span class="sxs-lookup"><span data-stu-id="cfd1b-182">[0xF0F0F0F0]</span></span>               |

> [!NOTE]
> <span data-ttu-id="cfd1b-183">A informação de mapeamento da página só é escrita quando o bloco está cheio, ou seja, todas as páginas do bloco foram escritas.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-183">The page mapping information is only written when the block is full, i.e., all the pages of the block have been written to.</span></span> <span data-ttu-id="cfd1b-184">Isto permite uma pesquisa mais rápida de páginas gratuitas e mapeamento do setor lógico durante o tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-184">This enables faster search for free pages and logical sector mapping during run-time.</span></span>

## <a name="nand-bad-block-support"></a><span data-ttu-id="cfd1b-185">Suporte de bloco mau NAND</span><span class="sxs-lookup"><span data-stu-id="cfd1b-185">NAND Bad Block Support</span></span>

<span data-ttu-id="cfd1b-186">A memória NAND também é mais provável de ter blocos maus do que a memória NOR.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-186">NAND memory is also more likely to have bad blocks than NOR memory.</span></span> <span data-ttu-id="cfd1b-187">Isto deve-se, em grande parte, ao aumento do rendimento dos fabricantes de NAND, permitindo blocos ruins e exigindo que o software funcione em torno de tais blocos maus.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-187">This is largely because NAND manufacturers can increase yield by allowing bad blocks and requiring software to work-around such bad blocks.</span></span> <span data-ttu-id="cfd1b-188">LevelX lida com a gestão de blocos maus NAND simplesmente mapeando em torno de blocos maus.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-188">LevelX handles NAND bad block management by simply mapping around bad blocks.</span></span>

<span data-ttu-id="cfd1b-189">O LevelX também fornece APIs para códigos de correção de erros de hamming de 256 byte (ECC) para que o controlador de Nível NºX subjacente utilize para calcular novos códigos ECC ou para executar uma correção de erro de 1 bit na leitura de página em cada secção de 256 bytes da página.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-189">LevelX also provides APIs for 256-byte Hamming Error Correction Codes (ECC) for the underlying LevelX driver to utilize for calculating new ECC codes or to perform 1-bit error correction on page reading within each 256-byte section of the page.</span></span>

## <a name="nand-driver-requirements"></a><span data-ttu-id="cfd1b-190">Requisitos do condutor nand</span><span class="sxs-lookup"><span data-stu-id="cfd1b-190">NAND Driver Requirements</span></span>

<span data-ttu-id="cfd1b-191">O LevelX requer um flash driver NAND subjacente que seja específico da parte de flash subjacente e da implementação de hardware.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-191">LevelX requires an underlying NAND flash driver that is specific to the underlying flash part and hardware implementation.</span></span> <span data-ttu-id="cfd1b-192">O controlador é especificado para LevelX durante a inicialização através do ***lx_nand_flash_open*** da API .</span><span class="sxs-lookup"><span data-stu-id="cfd1b-192">The driver is specified to LevelX during initialization via the API ***lx_nand_flash_open***.</span></span> <span data-ttu-id="cfd1b-193">O protótipo do condutor LevelX é o seguinte.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-193">The prototype of the LevelX driver is as follows.</span></span>

```c
INT nand_driver_initialize(LX_NAND_FLASH *instance);
```

<span data-ttu-id="cfd1b-194">O parâmetro *de instância* especifica o bloco de controlo NAND LevelX.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-194">The *instance* parameter specifies the LevelX NAND control block.</span></span> <span data-ttu-id="cfd1b-195">A função de inicialização do controlador é responsável pela configuração de todos os outros serviços ao nível do condutor para a instância de Nível N/ LevelX associada.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-195">The driver initialization function is responsible for setting up all the other driver-level services for the associated LevelX instance.</span></span> <span data-ttu-id="cfd1b-196">Os serviços necessários para cada instância NAND LevelX são apresentados na lista abaixo.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-196">The services required for each LevelX NAND instance are shown in the list below.</span></span>

- <span data-ttu-id="cfd1b-197">Ler Página</span><span class="sxs-lookup"><span data-stu-id="cfd1b-197">Read Page</span></span>
- <span data-ttu-id="cfd1b-198">Escrever Página</span><span class="sxs-lookup"><span data-stu-id="cfd1b-198">Write Page</span></span>
- <span data-ttu-id="cfd1b-199">Apagamento de blocos</span><span class="sxs-lookup"><span data-stu-id="cfd1b-199">Block Erase</span></span>
- <span data-ttu-id="cfd1b-200">Verificação de blocos apagadas</span><span class="sxs-lookup"><span data-stu-id="cfd1b-200">Block Erased Verify</span></span>
- <span data-ttu-id="cfd1b-201">Verificação de página apagada</span><span class="sxs-lookup"><span data-stu-id="cfd1b-201">Page Erased Verify</span></span>
- <span data-ttu-id="cfd1b-202">Estado de bloqueio obter</span><span class="sxs-lookup"><span data-stu-id="cfd1b-202">Block Status Get</span></span>
- <span data-ttu-id="cfd1b-203">Conjunto de estado de bloqueio</span><span class="sxs-lookup"><span data-stu-id="cfd1b-203">Block Status Set</span></span>
- <span data-ttu-id="cfd1b-204">Bloquear bytes extra obter</span><span class="sxs-lookup"><span data-stu-id="cfd1b-204">Block Extra Bytes Get</span></span>
- <span data-ttu-id="cfd1b-205">Conjunto de bytes extra de blocos</span><span class="sxs-lookup"><span data-stu-id="cfd1b-205">Block Extra Bytes Set</span></span>
- <span data-ttu-id="cfd1b-206">Manipulador de erros do sistema</span><span class="sxs-lookup"><span data-stu-id="cfd1b-206">System Error Handler</span></span>

## <a name="driver-initialization"></a><span data-ttu-id="cfd1b-207">Inicialização do condutor</span><span class="sxs-lookup"><span data-stu-id="cfd1b-207">Driver Initialization</span></span>

<span data-ttu-id="cfd1b-208">Estes serviços são configurados através da definição de ponteiros de função no **LX_NAND_FLASH** instância dentro da função de inicialização do condutor.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-208">These services are setup via setting function pointers in the **LX_NAND_FLASH** instance within the driver's initialization function.</span></span> <span data-ttu-id="cfd1b-209">A função de inicialização do controlador também especifica o número total de blocos, páginas por bloco, bytes por página e uma área de RAM suficientemente grande para ler uma página na memória.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-209">The driver initialization function also specifies the total number of block, pages per block, bytes per page, and a RAM area large enough to read one page into memory.</span></span> <span data-ttu-id="cfd1b-210">A função de inicialização do controlador provavelmente também executa tarefas adicionais de inicialização do dispositivo e/ou de implementação específicas antes de devolver **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-210">The driver initialization function likely also performs additional device and/or implementation-specific initialization duties before returning **LX_SUCCESS**.</span></span>

## <a name="driver-read-page"></a><span data-ttu-id="cfd1b-211">Página de leitura do motorista</span><span class="sxs-lookup"><span data-stu-id="cfd1b-211">Driver Read Page</span></span>

<span data-ttu-id="cfd1b-212">O serviço de "página de leitura" do controlador LevelX NAND é responsável pela leitura de uma página específica num bloco específico do flash NAND.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-212">The LevelX NAND driver "read page" service is responsible for reading a specific page in a specific block of the NAND flash.</span></span> <span data-ttu-id="cfd1b-213">Toda a lógica de verificação e correção de erros é da responsabilidade do serviço de condutor.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-213">All error checking and correcting logic is the responsibility of the driver service.</span></span> <span data-ttu-id="cfd1b-214">Se for bem sucedido, o condutor NaND LevelX regressa **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-214">If successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="cfd1b-215">Se não for bem sucedido, o condutor NaND LevelX regressa **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-215">If not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="cfd1b-216">O protótipo do serviço "ler página" do condutor nand LevelX é dado abaixo.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-216">The prototype of the LevelX NAND driver "read page" service is given below.</span></span>

```c
INT nand_driver_read_page(
    ULONG block,
    ULONG page,
    ULONG *destination, 
    ULONG words);
```

<span data-ttu-id="cfd1b-217">Onde *o bloco* e a *página* identificam qual página para ler e *destino* e *palavras* especificam onde colocar o conteúdo da página e quantas palavras de 32 bits para ler.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-217">Where *block* and *page* identify which page to read and *destination* and *words* specify where to place the page contents and how many 32-bit words to read.</span></span>

## <a name="driver-write-page"></a><span data-ttu-id="cfd1b-218">Página de escrita do motorista</span><span class="sxs-lookup"><span data-stu-id="cfd1b-218">Driver Write Page</span></span>

<span data-ttu-id="cfd1b-219">O serviço de "página de escrita" do controlador LevelX NAND é responsável por escrever uma página específica no bloco especificado do flash NAND.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-219">The LevelX NAND driver "write page" service is responsible for writing a specific page into the specified block of the NAND flash.</span></span> <span data-ttu-id="cfd1b-220">Toda a verificação de erros e a computação ECC é da responsabilidade do serviço de motorista.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-220">All error checking and ECC computation is the responsibility of the driver service.</span></span> <span data-ttu-id="cfd1b-221">Se for bem sucedido, o condutor NaND LevelX regressa **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-221">If successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="cfd1b-222">Se não for bem sucedido, o condutor NaND LevelX regressa **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-222">If not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="cfd1b-223">O protótipo do serviço "write page" do controlador NaND LevelX é apresentado abaixo.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-223">The prototype of the LevelX NAND driver "write page" service is shown below.</span></span>

```c
INT nand_driver_write_page(
    ULONG block, 
    ULONG page,
    ULONG *source, 
    ULONG words);
```

<span data-ttu-id="cfd1b-224">Onde *o bloco* e a *página* identificam qual página para escrever e *origem* e *palavras* especificam a origem da escrita e quantas palavras de 32 bits para escrever.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-224">Where *block* and *page* identify which page to write and *source* and *words* specify the source of the write and how many 32-bit words to write.</span></span>

> [!NOTE]
> <span data-ttu-id="cfd1b-225">O LevelX depende do controlador para deteção de erros de baixo nível ao escrever na página flash, que normalmente envolve ler a página de volta e comparar com o tampão de escrita para garantir que a escrita foi bem sucedida.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-225">LevelX relies on the driver for low-level error detection when writing to the flash page, which typically involves reading back the page and comparing with the write buffer to ensure the write was successful.</span></span>

## <a name="driver-block-erase"></a><span data-ttu-id="cfd1b-226">Apagamento do bloco de motorista</span><span class="sxs-lookup"><span data-stu-id="cfd1b-226">Driver Block Erase</span></span>

<span data-ttu-id="cfd1b-227">O serviço de "apagar bloco" do controlador LevelX NAND é responsável por apagar o bloco especificado do flash NAND.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-227">The LevelX NAND driver "block erase" service is responsible for erasing the specified block of the NAND flash.</span></span> <span data-ttu-id="cfd1b-228">Se for bem sucedido, o condutor NaND LevelX regressa **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-228">If successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="cfd1b-229">Se não for bem sucedido, o condutor NaND LevelX regressa **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-229">If not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="cfd1b-230">O protótipo do serviço de "apagar bloco" do condutor LevelX NAND é o seguinte.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-230">The prototype of the LevelX NAND driver "block erase" service is as follows.</span></span>

```c
INT nand_driver_block_erase(ULONG block,  
    ULONG erase_count);
```

<span data-ttu-id="cfd1b-231">Onde *o bloco* identifica qual bloco apagar.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-231">Where *block* identifies which block to erase.</span></span> <span data-ttu-id="cfd1b-232">O parâmetro *erase_count* é fornecido para fins de diagnóstico.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-232">The parameter *erase_count* is provided for diagnostic purposes.</span></span> <span data-ttu-id="cfd1b-233">Por exemplo, o condutor pode querer alertar outra parte do software da aplicação quando a contagem de apagamento exceder um limiar específico.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-233">For example, the driver may want to alert another portion of the application software when the erase count exceeds a specific threshold.</span></span>

> [!NOTE]
> <span data-ttu-id="cfd1b-234">O LevelX depende do controlador para a deteção de erros de baixo nível quando o bloco é apagado, o que normalmente envolve garantir que todas as páginas do bloco são todas.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-234">LevelX relies on the driver for low-level error detection when the block is erased, which typically involves ensuring that all pages of the block are all ones.</span></span>

## <a name="driver-block-erased-verify"></a><span data-ttu-id="cfd1b-235">Verificação apagada do bloco de motorista</span><span class="sxs-lookup"><span data-stu-id="cfd1b-235">Driver Block Erased Verify</span></span>

<span data-ttu-id="cfd1b-236">O serviço de "verificar o bloqueio do bloco" LevelX é responsável por verificar se o bloco especificado do flash NAND é apagado.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-236">The LevelX NAND driver "block erased verify" service is responsible for verifying that the specified block of the NAND flash is erased.</span></span> <span data-ttu-id="cfd1b-237">Se for apagado, o condutor NaND LevelX regressa **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-237">If it is erased, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="cfd1b-238">Se o bloco não for apagado, o condutor NaND LevelX regressa **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-238">If the block is not erased, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="cfd1b-239">O protótipo do serviço "blocked check" do condutor LevelX NAND é:</span><span class="sxs-lookup"><span data-stu-id="cfd1b-239">The prototype of the LevelX NAND driver "block erased verify" service is:</span></span>

```c
INT nand_driver_block_erased_verify(ULONG block);
```

<span data-ttu-id="cfd1b-240">Onde *o bloco* especifica qual o bloco para verificar se é apagado.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-240">Where *block* specifies which block to verify that it is erased.</span></span>

> [!NOTE]
> <span data-ttu-id="cfd1b-241">O LevelX conta com o controlador para examinar todas as páginas e todos os bytes de cada página – incluindo bytes de reposição e dados – para garantir que são apagados (conter todas as).</span><span class="sxs-lookup"><span data-stu-id="cfd1b-241">LevelX relies on the driver to examine all pages and all bytes of each page – including spare and data bytes – to ensure they are erased (contain all ones).</span></span>

## <a name="driver-page-erased-verify"></a><span data-ttu-id="cfd1b-242">Página do condutor apagada Verificar</span><span class="sxs-lookup"><span data-stu-id="cfd1b-242">Driver Page Erased Verify</span></span>

<span data-ttu-id="cfd1b-243">O serviço "page apagar a página" do controlador LevelX NAND é responsável por verificar se a página especificada do bloco especificado do flash NAND é apagada.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-243">The LevelX NAND driver "page erased verify" service is responsible for verifying that the specified page of the specified block of the NAND flash is erased.</span></span> <span data-ttu-id="cfd1b-244">Se for apagado, o condutor NaND LevelX regressa **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-244">If it is erased, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="cfd1b-245">Se a página não for apagada, o controlador NAND LevelX regressa **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-245">If the page is not erased, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="cfd1b-246">O protótipo do serviço "verificação de página apagada" do controlador LevelX NAND é:</span><span class="sxs-lookup"><span data-stu-id="cfd1b-246">The prototype of the LevelX NAND driver "page erased verify" service is:</span></span>

```c
INT nand_driver_page_erased_verify(
    ULONG block,  
    ULONG page);
```
<span data-ttu-id="cfd1b-247">Quando *o bloco* especifica qual o bloco e a *página* especifica a página para verificar se é apagada.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-247">Where *block* specifies which block and *page* specifies the page to verify that it is erased.</span></span>

> [!NOTE]
> <span data-ttu-id="cfd1b-248">O LevelX conta com o controlador para examinar todos os bytes da página especificada – incluindo bytes de reposição e dados – para garantir que são apagados (contêm todos os).</span><span class="sxs-lookup"><span data-stu-id="cfd1b-248">LevelX relies on the driver to examine all bytes of the specified page – including spare and data bytes – to ensure they are erased (contain all ones).</span></span>

## <a name="driver-block-status-get"></a><span data-ttu-id="cfd1b-249">Estado do bloqueio do motorista obter</span><span class="sxs-lookup"><span data-stu-id="cfd1b-249">Driver Block Status Get</span></span>

<span data-ttu-id="cfd1b-250">O serviço "block status get" do controlador LevelX NAND é responsável pela recuperação da bandeira de bloco mau do bloco especificado do flash NAND.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-250">The LevelX NAND driver "block status get" service is responsible for retrieving the bad block flag of the specified block of the NAND flash.</span></span> <span data-ttu-id="cfd1b-251">Se for bem sucedido, o condutor NaND LevelX regressa **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-251">If it is successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="cfd1b-252">Se não for bem sucedido, o condutor NaND LevelX regressa **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-252">If it is not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="cfd1b-253">O protótipo do serviço "block status get" do condutor LevelX NAND é: mostrado abaixo.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-253">The prototype of the LevelX NAND driver "block status get" service is: shown below.</span></span>

```c
INT nand_driver_block_status_get(
    ULONG block,  
    UCHAR *bad_block_byte);
```

<span data-ttu-id="cfd1b-254">Onde *o bloco* especifica qual bloco e *bad_block_byte* especifica o destino para a bandeira de bloco ruim.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-254">Where *block* specifies which block and *bad_block_byte* specifies the destination for the bad block flag.</span></span>

## <a name="driver-block-status-set"></a><span data-ttu-id="cfd1b-255">Conjunto de estado do bloqueio do motorista</span><span class="sxs-lookup"><span data-stu-id="cfd1b-255">Driver Block Status Set</span></span>

<span data-ttu-id="cfd1b-256">O serviço "conjunto de estado de bloqueio" do controlador LevelX NAND é responsável pela definição da bandeira de bloco mau do bloco especificado do flash NAND.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-256">The LevelX NAND driver "block status set" service is responsible for setting the bad block flag of the specified block of the NAND flash.</span></span> <span data-ttu-id="cfd1b-257">Se for bem sucedido, o condutor NaND LevelX regressa **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-257">If it is successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="cfd1b-258">Se não for bem sucedido, o condutor NaND LevelX regressa **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-258">If it is not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="cfd1b-259">O protótipo do serviço "conjunto de estado do bloco" do condutor LevelX NAND é:</span><span class="sxs-lookup"><span data-stu-id="cfd1b-259">The prototype of the LevelX NAND driver "block status set" service is:</span></span>

```c
INT nand_driver_block_status_set(
    ULONG block,
    UCHAR bad_block_byte);
```

<span data-ttu-id="cfd1b-260">Quando *o bloco* especificar qual o bloco e *bad_block_byte* especifica o valor da bandeira de bloco mau.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-260">Where *block* specifies which block and *bad_block_byte* specifies the value of the bad block flag.</span></span>

## <a name="driver-block-extra-bytes-get"></a><span data-ttu-id="cfd1b-261">Driver Block Extra Bytes Get</span><span class="sxs-lookup"><span data-stu-id="cfd1b-261">Driver Block Extra Bytes Get</span></span>

<span data-ttu-id="cfd1b-262">O serviço "block extra bytes get" do controlador LevelX NAND é responsável pela recuperação de bytes extra associados a uma página específica de um bloco específico do flash NAND.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-262">The LevelX NAND driver "block extra bytes get" service is responsible for retrieving extra bytes associated with a specific page of a specific block of the NAND flash.</span></span> <span data-ttu-id="cfd1b-263">Se for bem sucedido, o condutor NaND LevelX regressa **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-263">If it is successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="cfd1b-264">Se não for bem sucedido, o condutor NaND LevelX regressa **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-264">If it is not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="cfd1b-265">O protótipo do serviço "block extra bytes get" do condutor LevelX NAND é:</span><span class="sxs-lookup"><span data-stu-id="cfd1b-265">The prototype of the LevelX NAND driver "block extra bytes get" service is:</span></span>

```c
INT nand_driver_block_extra_bytes_get(
    ULONG block,  
    ULONG page, 
    UCHAR *destination, 
    UINT size);
```

<span data-ttu-id="cfd1b-266">Quando *o bloco* especifica qual o bloco, a *página* especifica a página e o *destino* específicos especifica o destino para os bytes extra.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-266">Where *block* specifies which block, *page* specifies the specific page and *destination* specifies the destination for the extra bytes.</span></span> <span data-ttu-id="cfd1b-267">O *tamanho* do parâmetro especifica quantos bytes extras obter.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-267">The parameter *size* specifies how many extra bytes to get.</span></span>

## <a name="driver-block-extra-bytes-set"></a><span data-ttu-id="cfd1b-268">Conjunto de bytes extra do bloco do motorista</span><span class="sxs-lookup"><span data-stu-id="cfd1b-268">Driver Block Extra Bytes Set</span></span>

<span data-ttu-id="cfd1b-269">O serviço "block extra bytes set" do controlador LevelX NAND é responsável pela definição de bytes extra numa página específica de um bloco específico do flash NAND.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-269">The LevelX NAND driver "block extra bytes set" service is responsible for setting extra bytes in a specific page of a specific block of the NAND flash.</span></span> <span data-ttu-id="cfd1b-270">Se for bem sucedido, o condutor NaND LevelX regressa **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-270">If it is successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="cfd1b-271">Se não for bem sucedido, o condutor NaND LevelX regressa **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-271">If it is not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="cfd1b-272">O protótipo do serviço "block extra bytes set" do condutor LevelX NAND é:</span><span class="sxs-lookup"><span data-stu-id="cfd1b-272">The prototype of the LevelX NAND driver "block extra bytes set" service is:</span></span>

```c
INT nand_driver_block_extra_bytes_set(
    ULONG block,  
    ULONG page, 
    UCHAR *source, 
    UINT size);
```

<span data-ttu-id="cfd1b-273">Quando *o bloco* especifica qual o bloco, a *página* especifica a página específica e a *fonte* especifica a origem dos bytes extra.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-273">Where *block* specifies which block, *page* specifies the specific page and *source* specifies the source of the extra bytes.</span></span> <span data-ttu-id="cfd1b-274">O *tamanho* do parâmetro especifica quantos bytes extras para definir.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-274">The parameter *size* specifies how many extra bytes to set.</span></span>

## <a name="driver-system-error"></a><span data-ttu-id="cfd1b-275">Erro do sistema do controlador</span><span class="sxs-lookup"><span data-stu-id="cfd1b-275">Driver System Error</span></span>

<span data-ttu-id="cfd1b-276">O serviço "manipulador de erros do sistema" LevelX NAND é responsável pela definição de erros de sistema de manuseamento detetados pelo LevelX.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-276">The LevelX NAND driver "system error handler" service is responsible for setting handling system errors detected by LevelX.</span></span> <span data-ttu-id="cfd1b-277">O processamento nesta rotina é dependente da aplicação.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-277">The processing in this routine is application dependent.</span></span> <span data-ttu-id="cfd1b-278">Se for bem sucedido, o condutor NaND LevelX regressa **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-278">If it is successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="cfd1b-279">Se não for bem sucedido, o condutor NaND LevelX regressa **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-279">If it is not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="cfd1b-280">O protótipo do serviço "erro de sistema" do controlador NAND LevelX é:</span><span class="sxs-lookup"><span data-stu-id="cfd1b-280">The prototype of the LevelX NAND driver "system error" service is:</span></span>

```c
INT nand_driver_system_error(
    UINT error_code,  
    ULONG block, 
    ULONG page);
```

<span data-ttu-id="cfd1b-281">Quando *o bloco* especifica qual o bloco e a *página* especifica a página específica, o erro representado por *error_code* ocorreu.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-281">Where *block* specifies which block, and *page* specifies the specific page the error represented by *error_code* occurred.</span></span>

## <a name="nand-simulated-driver"></a><span data-ttu-id="cfd1b-282">Condutor simulado nand</span><span class="sxs-lookup"><span data-stu-id="cfd1b-282">NAND Simulated Driver</span></span>

<span data-ttu-id="cfd1b-283">O LevelX fornece um flash driver NAND simulado que simplesmente utiliza RAM para simular o funcionamento de uma peça de flash NAND.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-283">LevelX provides a simulated NAND flash driver that simply uses RAM to simulate the operation of a NAND flash part.</span></span> <span data-ttu-id="cfd1b-284">Por predefinição, o controlador simulado NAND fornece 8 blocos de flash NAND com 16 páginas por bloco e 2048 bytes por página.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-284">By default, the NAND simulated driver provides 8 NAND flash blocks with 16 pages per block and 2048 bytes per page.</span></span>

<span data-ttu-id="cfd1b-285">A função de inicialização simulada do flash driver NAND é ***lx_nand_flash_simulator_initialize** _ e é definida em _*_lx_nand_flash_simulator.c_\*\*.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-285">The simulated NAND flash driver initialization function is ***lx_nand_flash_simulator_initialize** _ and is defined in _*_lx_nand_flash_simulator.c_\*\*.</span></span> <span data-ttu-id="cfd1b-286">Este controlador também fornece um bom modelo para escrever controladores flash NAND específicos.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-286">This driver also provides a good template for writing specific NAND flash drivers.</span></span>

## <a name="nand-filex-integration"></a><span data-ttu-id="cfd1b-287">Integração NAND FileX</span><span class="sxs-lookup"><span data-stu-id="cfd1b-287">NAND FileX Integration</span></span>

<span data-ttu-id="cfd1b-288">Como mencionado anteriormente, o LevelX não depende do FileX para funcionamento.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-288">As mentioned earlier, LevelX does not rely on FileX for operation.</span></span> <span data-ttu-id="cfd1b-289">Todas as APIs do LevelX podem ser chamadas diretamente pelo software de aplicação para armazenar/recuperar dados brutos para os sectores lógicos fornecidos pelo LevelX.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-289">All the LevelX APIs may be called directly by the application software to store/retrieve raw data to the logical sectors provided by LevelX.</span></span> <span data-ttu-id="cfd1b-290">No entanto, o LevelX também suporta o FileX.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-290">However, LevelX also supports FileX.</span></span>

<span data-ttu-id="cfd1b-291">O ficheiro ***fx_nand_flash_simulated_driver.c*** contém um exemplo de controlador FileX para utilização com a simulação de flash NAND.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-291">The file ***fx_nand_flash_simulated_driver.c*** contains an example FileX driver for use with the NAND flash simulation.</span></span> <span data-ttu-id="cfd1b-292">Um aspeto interessante deste condutor é que combina setores lógicos de 512 bytes tipicamente utilizados pelo FileX em pedidos de leitura/escrita de um único sector lógico para o simulador LevelX usando páginas de 2048 byte.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-292">An interesting aspect of this driver is that it combines 512-byte logical sectors typically used by FileX into single logical sector read/write requests to the LevelX simulator using 2048-byte pages.</span></span> <span data-ttu-id="cfd1b-293">Isto resulta numa utilização mais eficiente da memória flash NAND.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-293">This results in more efficient use of the NAND flash memory.</span></span> <span data-ttu-id="cfd1b-294">O controlador nand flash FileX para LevelX fornece um bom ponto de partida para escrever controladores FileX personalizados.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-294">The NAND flash FileX driver for LevelX provides a good starting point for writing custom FileX drivers.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="cfd1b-295">O formato flash NAND filex deve ter um tamanho de bloco completo de sectores menos do que o flash NAND fornece.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-295">The FileX NAND flash format should be one full block size of sectors less than the NAND flash provides.</span></span> <span data-ttu-id="cfd1b-296">Isto ajudará a garantir um melhor desempenho durante o processamento do nível de desgaste.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-296">This will help ensure best performance during the wear level processing.</span></span> <span data-ttu-id="cfd1b-297">Técnicas adicionais para melhorar o desempenho da escrita no algoritmo de nivelamento de desgaste LevelX incluem o seguinte.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-297">Additional techniques to improve write performance in the LevelX wear leveling algorithm include the following.</span></span>

1. <span data-ttu-id="cfd1b-298">Certifique-se de que todas as escritas são exatamente um ou mais clusters de tamanho e começar em limites exatos do cluster.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-298">Ensure that all writes are exactly one or more clusters in size and start on exact cluster boundaries.</span></span>
1. <span data-ttu-id="cfd1b-299">Pré-alocar clusters antes de realizar grandes operações de escrita de ficheiros através da classe ***de APIs fx_file_allocate*** FileX.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-299">Pre-allocate clusters before performing large file write operations via the FileX ***fx_file_allocate*** class of APIs.</span></span>
1. <span data-ttu-id="cfd1b-300">Certifique-se de que o controlador FileX está habilitado a receber informações do sector de libertação e os pedidos feitos ao condutor para libertar os sectores são tratados no condutor, chamando ***lx_nor_flash_sector_release***.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-300">Ensure the FileX driver is enabled to receive release sector information and requests made to the driver to release sectors are handled in the driver by calling ***lx_nor_flash_sector_release***.</span></span>
1. <span data-ttu-id="cfd1b-301">O uso periódico de ***lx_nand_flash_defragment*** para libertar o maior número possível de blocos NAND e assim melhorar o desempenho da escrita.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-301">Periodic use of ***lx_nand_flash_defragment*** to free up as many NAND blocks as possible and thus improve write performance.</span></span>
1. <span data-ttu-id="cfd1b-302">Utilize a ***API lx_nand_flash_extended_cache_enable*** para fornecer uma cache RAM de vários recursos de bloco NAND para um desempenho mais rápido.</span><span class="sxs-lookup"><span data-stu-id="cfd1b-302">Utilize the ***lx_nand_flash_extended_cache_enable*** API to provide a RAM cache of various NAND block resources for faster performance.</span></span>
